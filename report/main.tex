%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[12pt,a4paper]{report}

\usepackage{fontspec,xltxtra,xunicode}
\setmainfont[Ligatures=TeX]{Times New Roman}
\setsansfont{Arial}

% \usepackage[utf8x]{inputenc}
% \usepackage[mongolian]{babel}
%\usepackage{natbib}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\setlength{\headheight}{29.03363pt}
%\usepackage{fancyheadings} fancyheadings is obsolete: replaced by fancyhdr. JL
\usepackage{fancyhdr}
% Set up page numbering style
\pagestyle{fancy}
\fancyhf{} % Clear all headers and footers
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{float}
\usepackage{afterpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsbsy}
\usepackage{dcolumn,array}
\usepackage{tocloft}
\usepackage{styles/dics}
% Ensure proper page numbering after dics.sty is loaded
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{nomencl}
\usepackage{upgreek}
\newcommand{\argmin}{\arg\!\min}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}

% Packages for better text wrapping and line breaking
\usepackage{microtype} % Improves text appearance and reduces overfull boxes
\usepackage{ragged2e} % Better text justification
\usepackage{hyphenat} % Better hyphenation control
\usepackage{url} % Better URL line breaking

% Emergency stretch to prevent overfull hboxes
\emergencystretch=1em

% Additional settings for better text handling
\tolerance=1000
\hyphenpenalty=50
\exhyphenpenalty=50

% Set line breaking parameters
\linespread{1.05} % Slightly increase line spacing
\clubpenalty=10000 % Prevent single lines at bottom of page
\widowpenalty=10000 % Prevent single lines at top of page

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{listings}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\makeatletter
\usepackage{caption}
\captionsetup[table]{belowskip=0.5pt}
\renewcommand{\tablename}{Хүснэгт}
\usepackage{longtable}
\usepackage{subfiles}

\usepackage{listings}
\renewcommand{\lstlistingname}{Код}
\renewcommand{\lstlistlistingname}{\lstlistingname ын жагсаалт}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.99,0.99,0.99}
\definecolor{lightgray}{rgb}{0.83,0.83,0.83}
\definecolor{darkgray}{rgb}{0.3,0.3,0.3}

% Define JavaScript language for listings
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, const, let, async, await, export, import, class, extends},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={boolean, number, string, any, void},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
 
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=false,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=true,
    showtabs=false,                  
    tabsize=2,
    % Additional settings for better line breaking
    breakindent=1.5em,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    frame=single,
    rulecolor=\color{lightgray},
    columns=flexible,
    % Ensure lines don't exceed margins
    xleftmargin=2em,
    xrightmargin=2em
}
 
\lstset{style=mystyle, label=DescriptiveLabel} 

\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\makenomenclature
\begin{document}


%----------------------------------------------------------------------------------------
%   Өөрийн мэдээллээ оруулах хэсэг
%----------------------------------------------------------------------------------------

% Дипломийн ажлын сэдэв
\title{Микросервис архитектурт суурилсан хиймэл оюун агентууд}
% Дипломын ажлын англи нэр
\titleEng{AI agents for microservices}
% Өөрийн овог нэрийг бүтнээр нь бичнэ
\author{Булганы Раднаабазар}
% Өөрийн овгийн эхний үсэг нэрээ бичнэ
\authorShort{Б.Раднаабазар}
% Удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\supervisor{Дэд профессор Б.Сувдаа}
% Хамтарсан удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\cosupervisor{}

% СиСи дугаар 
\sisiId{22B1NUM0286}
% Их сургуулийн нэр
\university{МОНГОЛ УЛСЫН ИХ СУРГУУЛЬ}
% Бүрэлдэхүүн сургуулийн нэр
\faculty{МЭДЭЭЛЛИЙН ТЕХНОЛОГИ, ЭЛЕКТРОНИКИЙН СУРГУУЛЬ}
% Тэнхимийн нэр
\department{МЭДЭЭЛЭЛ, КОМПЬЮТЕРЫН УХААНЫ ТЭНХИМ}
% Зэргийн нэр
\degreeName{Дипломын ажлын тайлан}
% Суралцаж буй хөтөлбөрийн нэр
\programeName{Мэдээллийн технологи (D061304)}
% Хэвлэгдсэн газар
\cityName{Улаанбаатар}
% Хэвлэгдсэн огноо
\gradyear{2025 оны 12 сар}


%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
\include{src/main-pre}

% Удиртгалыг оруулж ирэх ба abstract.tex файлд удиртгалаа бичнэ
\include{src/abstract}

% Нэр томьёоны тайлбар
\include{src/terminology}

%----------------------------------------------------------------------------------------
%   Дипломын үндсэн хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------



\textbf{Зорилго:}

Энэхүү судалгааны ажлын гол зорилго нь хиймэл оюун агентуудыг микросервис архитектур хэлбэрээр нэвтрүүлэх боломжийг онол, практикийн хувьд судалж, үйл явдлаар удирдагдах архитектур (EDA) ашиглан уян хатан, өргөжих боломжтой системийн зохиомж гаргах юм. Уг зохиомжийн үр ашигтай байдлыг баталгаажуулахын тулд Монголын хөрөнгийн биржийн бодит өгөгдөлд суурилсан демо систем хөгжүүлж туршина.

\textbf{Зорилт:}

\begin{enumerate}
    \item Хиймэл оюуны инженерчлэл, суурь загвар, RAG систем, агентуудын онолын үндсийг судлах
    \item Микросервис архитектур болон үйл явдлаар удирдагдах архитектурын давуу талыг тодорхойлох
    \item Apache Kafka, Apache Flink ашиглан агентуудыг тархмал микросервист нэгтгэсэн зохиомж гаргах
    \item Монголын хөрөнгийн биржийн өгөгдөлд суурилсан демо систем хөгжүүлж, санал болгосон зохиомжийг туршиж үзэх
\end{enumerate}

\chapter{Хиймэл оюуны инженерчлэл ба агентууд}

Энэхүү бүлэгт хиймэл оюуны инженерчлэлийн үндсэн ойлголтууд, суурь загварын хөгжил, промпт инженерчлэл, дараа нь RAG систем, агентуудын архитектурыг тайлбарлана. Мөн ижил төстэй системүүдийн судалгааг хийж, энэхүү судалгааны ажлын онцлог байр суурийг тодорхойлно.

\section{Хиймэл оюуны инженерчлэл гэж юу вэ}

Хиймэл оюуны инженерчлэл гэдэг нь бэлэн бэлтгэгдсэн суурь загвар дээр аппликейшн хөгжүүлэх үйл явцийг хэлнэ. Энэ нь уламжлалт машин сургалтын инженерчлэлээс ялгаатай байдаг ~\cite{huyen2024}. Хэрэв уламжлалт машин сургалтын инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн бол, хиймэл оюуны инженерчлэл нь бэлтгэгдсэн загварыг программ хангамжид интеграц хийхэд чиглэсэн байдаг. Энэ ч утгаараа фүллстэк хөгжүүлэгч заавал машин сургалтын 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/aiAndML.png}
    \caption{Хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэл ~\cite{huyen2024}}
    \label{fig:home}
\end{figure}

Зураг \ref{fig:home}-д хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэлийн ялгааг дүрсэлсэн. Зураг \ref{fig:home}-оос харахад хиймэл оюуны инженерчлэл нь бэлэн загварыг ашиглахад чиглэсэн бол машин сургалтын инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн байна.

OpenAI, Anthropic зэрэг компаниудын гаргасан хүчирхэг суурь загварын хүртээмж нь гурван гол хүчин зүйлээс шалтгаалан хиймэл оюуны инженерчлэлийг хурдан өсч буй салбар болгожээ. ~\cite{goldman2023} Эхнийх нь өндөр эрэлт юм. Компаниуд хиймэл оюуныг бусад бизнесээс ялгарах өрсөлдөөнт давуу тал болгон үзэж байна. FactSet-ийн судалгаагаар 2023 оны хоёрдугаар улиралд S\&P 500 компаниудын гуравны нэг нь өөрсдийн санхүүгийн тайланд хиймэл оюуныг дурдсан тоо нь өмнөх оноос гурав дахин их байна. Хоёр дахь нь технологийн хөгжилтэй холбоотой. Өмнө нь хиймэл оюун систем бүтээхэд өндөр мэргэжлийн ур чадвар, их хэмжээний өгөгдөл, тооцооллын нөөц шаардлагатай байсан бол одоо суурь загвар ашиглан хэрэглээнд нэвтрүүлэх нь илүү боломжтой болов. Улмаас хиймэл оюуны инженерүүд программ хангамжийг хүртээмжтэй загварууд ашигласнаар өндөр түвшний математикийн мэдлэг өндөр түвшинд байх шаардлагагүй болов. Гурав дахь нь том боломж юм. Хиймэл оюун технологи нь ажил хэргийг автоматжуулах, шинэ бүтээгдэхүүнүүдийг бий болгох зэрэг асар том боломжуудыг санал болгож байна. Энэхүү хандлагын нотолгоо болох хиймэл оюунт аппликейшний нээлттэй эхийн кодууд (AutoGPT, Stable Diffusion WebUI, LangChain, Ollama) нь GitHub дээр Bitcoin-оос ч илүү од цуглуулсан нь энэхүү салбарын хурдацтай өсөлтийг тод илэрхийлж байна. ~\cite{huyen2024}.

\section{Суурь загварын хөгжил}

Хэл загваруудээс том хэлний загвар болон суурь загвар руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Энэхүү хэсэгт гол түлхүүр үйл явдлыг тайлбарлах болно. ~\cite{huyen2024}

\subsection{Хэл загварын үндэс}

Хэл загвар гэдэг нь нэг буюу олон хэлүүдийг статистик өгөгдөл рүү кодлодог загвар юм. Энэхүү мэдээлэл нь өгөгдсөн контекстэд уг үг гарах магадлалыг илэрхийлдэг. Жишээлбэл, "Миний дуртай өнгө бол \_\_" гэсэн контекст өгөхөд монгол хэлээр кодолсон хэл загвар нь "машин" биш, харин "цэнхэр" гэсэн үгийг таамаглах ёстой. ~\cite{huyen2024}

Анхны текстийг токен болгон хуваах үйл явцыг токенжуулалт гэнэ. GPT-4 суурь загварын хувьд дунджаар нэг токен нь үгийн ойролцоогоор 75\%-ийн уртад тохирно. Тиймээс 100 токен нь ойролцоогоор 75 үг юм.

Хэл загвард хоёр үндсэн төрөл байдаг. Эхний төрөл нь далдлагдсан хэлний загварууд бөгөөд эдгээр нь өгүүлбэр доторх далдлагдсан үгсийг таамаглах замаар сурдаг. BERT нь энэ төрлийн алдартай жишээ юм. Хоёр дахь төрөл нь автoрегрессив хэл загварууд бөгөөд өмнөх токенуудад үндэслэн дараагийн токенийг таамаглах замаар сурдаг. Одоогийн ChatGPT, Claude зэрэг өргөн ашиглагдаж буй системүүд нь энэ ангилалд хамаарагддаг.

\subsection{Өөрийгөө удирдсан сургалт (Self-Supervised Learning)}

Хэл загварын хамгийн чухал давуу тал нь өөрийгөө удирдсан сургалтыг ашиглах чадвар юм ~\cite{huyen2024}. Өөрийгөө удирдсан сургалт нь удирдлагатай сургалтаас ялгаатай байдаг. Удирдлагатай сургалт нь тэмдэглэгдсэн өгөгдөл шаарддаг бөгөөд энэ үйл явц нь цаг хугацаа их зарцуулдаг. ~\cite{huyen2024}

Энэ нь хэл загварыг номнуудаас, блог нийтлэлээс, өгүүллүүд, Reddit-ийн сэтгэгдэл зэргээс ашиглан сургаж болно. Энэ нь асар их сургалтын өгөгдөл бүрдүүлэх боломжийг олгож, хэл загварыг том хэлний загвар буюу LLM болтол өргөжүүлэх боломжтой болгосон.

\subsection{Том хэлний загвараас суурь загвар руу}

2017 онд Transformer архитектур гарч ирснээр хэл загварын чадамж харьцангуй өндөр нэмэгдсэн. Attention механизм нь загваруудад өгөгдлийн хамаарлыг илүү сайн ойлгох боломжийг олгосон. ~\cite{huyen2024}

Том хэлний загварууд нь хэл загварын томорсон хувилбар бөгөөд тэрбум тооны параметр агуулдаг. Параметр гэдэг нь сургалтын явцад загварын сурч авдаг утга юм. Жишээлбэл, GPT-3 нь 175 тэрбум параметртэй, харин GPT-4 нь 1.2 их наяд параметртэй байдаг. 

Суурь загварууд нь LLM-ээс цааш өргөжсөн ойлголт юм. Эдгээр нь зөвхөн текст биш, зураг, аудио, видео зэрэг олон төрлийн өгөгдөл боловсруулж чаддаг том мульти модал загварууд юм. Суурь загварын гол онцлог нь тодорхой үүрэгтэй загвараас цаашлаад ерөнхий зориулалтын загвар руу шилжсэн юм.

\section{Хиймэл оюуны агент ба бизнесийн үйл ажиллагаа}

Энтерпрайзийн хувьд хиймэл оюун нь дахин давтагддаг нэхэмжлэл үүсгэх, харилцагчийн асуултад хариулах, өгөгдөл бүртгэх зэрэг үйл ажиллагааг автоматжуулах боломж гаргаж байдаг. Нэгэн сонирхолтой хиймэл оюуны нэвтрүүлэлтийн хэлбэр нь өгөгдлийг дахин сайжруулах арга зам юм. Энэ нь өөрийнхөө өгөгдөлд тэмдэглэгээ хийгээд, дараа нь энэ тэмдэглэгээний үр дүнгээс хамаарч жинхэнэ хүний тусламжтайгаар алдааг багасгахын тулд олон дахин уг тэмдэглэгээнүүдийг сайжруулах юм. Энтерпрайзуудад хамгийн алдартай хиймэл оюуны хэрэглээ нь харилцагчийн туслах бот юм. Туслах бот нь хүнээс хурдан хариулснаар харилцагчийн туршлагыг сайжруулж, бас бизнесийн хувьд зардал хэмнэх боломжийг бүрдүүлдэг. ~\cite{huyen2024} ~\cite{goldman2023}

Хиймэл оюунд гадна орчинтой хандах хэрэглүүр өгөх нь маш олон боломжийг нээж өгдөг. Ресторанд цаг захиалахад сул цаг харах, захиалга өгөх зэрэг үйлдлийг хэрэглүүрүүд хийх боломжтой ба хиймэл оюунд уг хэрэглүүр өгснөөр харилцагчийн өмнөөс уг үйлдлийг автоматаар хийж болох юм. Уг үйлдлүүдийг зохион байгуулж, хэрэглүүр ашигладаг программ хангамжийг хиймэл оюун агентууд гэнэ.     

\section{Суурь загварын сургалт}

Суурь загварыг бэлтгэх нь хоёр үндсэн үе шаттай:

\subsection{Урьдчилан сургалт}

Урьдчилан сургалт нь өөрийгөө удирдсан сургалт ашиглан их хэмжээний өгөгдөл дээр загварыг сургах үйл явц юм. Энэ үе шатанд загвар нь хэл, ерөнхий мэдлэг, дүрэм, баримт бичгүүдээс суралцдаг. 2022 онд сургалтын дата олохын тулд нэгэн ашгийн бус байгууллага 2-3 тэрбум веб хуудсуудыг автоматаар авч сургасан байна. Гэвч худал хуурмаг мэдээлэл, хүнд сурталтай мэдээлэл их байдаг тул хьюристик филтер хийдэг. Жишээ нь реддит платформд 5-аас олон эерэг хариу үйлдэлтэй бол уг өгөгдлийг авах юм.  ~\cite{huyen2024}

Суурь загвар нь олон төрөлтэй байна. Нэгт, тодорхой зорилготой агентууд нь домейнд л хамаарагдах өгөгдлийг ашиглаж тооцоолол хийдэг. Үүнд эм эмчилгээний жорыг гаргах, ДНХ, хавдрын, уурагны симуляц явах зэрэг үйлдлүүдтэй байна. Хоёрт, ерөнхий зориулалттай хиймэл оюуны загвар байна. Сургагдсан өгөгдлийн талаас дээш хувийг технологи, бизнес, үйлдвэр, мэдээ, урлаг уран сайхны өгөгдлүүд эзлэх ба үлдсэн хувийг бусад бага бага хувьтай гэр, аялал зэрэг секторууд эзлэж байна.

Олон улсын хэлүүд суурь загвар дээр өөр өөр ажиллах зарчимтай байна. Сургалтан дээр суурь загварын ойролцоогоор тал хувийг англи хэл эзэлдэг бол орос, герман хэл 10 хувийг эзлэж байна. GPT-4 суурь загварын хувьд ашиглах токений хэмжээ ба төөрөгдөл хамгийн бага байх ба, Бирм хэл англи хэлээс 70 дахин их токен ашиглаж, төөрөгдөл хамгийн өндөр байна. Шалтгаан нь уг хэлний соёлийн бүтэц юм. Жишээлбэл зарим хэлд эзэн бие ашигладаггүй учир хэл хөрвөхөд оновчтой байх магадлал бага юм. 

Иймээс суурь загварын хэлний хязгаарлалтыг давахын тулд өөрсдийн хэл дээр суурь загвар хөгжүүлж байна. Жишээлбэл, хятадын "Llama-Chinese", францийн "Croissant-LLM", Виетнамын "PhoGPT" гэх зэрэг. Монгол улсын хувьд "Чимэгэ систем" нь монгол хэл дээр суурь загвар хөгжүүлж байгаа. 

Урьдчилан сургагдсан үе шатд хэрэглэгчдийн хүсэлтэд нийцсэн хариулт өгөхөд сайн биш байдаг. Учир нь харилцан яриа өрнүүлэх гэхээс илүүтэйгээр зөвхөн өгүүлбэрийн гүйцээлт рүү тулгуурлан сургагдсан байдаг. Иймээс дараах сургалт, sampling техникүүд, нарийвчилсан сургалтууд шаардалагатай байдаг.

\subsection{Дараах сургалт}

Урьдчилан сургасан загварыг хэрэглэгчдийн хүсэлтэд тохируулахын тулд дараах сургалт хийдэг. Энэ нь хоёр үе шаттай. Эхний үе шат нь удирдлагатай нарийвчилсан сургалт юм. Энэ үе шатанд өндөр чанартай зааварчилгааны өгөгдөл дээр загварыг нарийвчлан сургаж, зөвхөн өгүүлбэрийн гүйцээлт биш харин харилцан ярианы горимд оновчтой болгоно. Хоёр дахь үе шат нь сонголтын нарийвчилсан сургалт юм. Энэ үе шатанд загварыг хүний сонголттой нийцсэн хариулт өгөхийн тулд цаашид нарийвчлан сургана. Үүнд хүний санал хүсэлтээр бэхжүүлсэн сургалт, хиймэл оюуны санал хүсэлтээр бэхжүүлсэн сургалт зэрэг аргууд ордог. ~\cite{huyen2024}

\subsection{Sampling стратегиуд}

Суурь загвараас гарах гаралт нь адилхан асуулт өгсөн ч хариулт бүр тогтмол биш, ялгаатай байх нь магадлалын шинж чанарыг илтгэдэг. Уг суурь загварын гаралтыг sampling процессоор хийх ба sampling нь хиймэл оюуны гаралтын магадлалд шууд нөлөөлдөг ~\cite{huyen2024}. Үүний чухал параметр болох температур нь загварын бүтээлч чанарыг удирдах гол параметр юм. Температур өндөр байх тусам загвар илүү бүтээлч, гэнэтийн хариулт өгдөг бол температур бага байвал хамгийн илэрхий хариултыг сонгож, илүү баттай хариулт өгдөг. Top-k нь хамгийн их магадлалтай k ширхэг токеноос сонгодог арга юм. Үүнийг өөрчилснөөр хариултын олон янзтай байх байдлыг удирдаж болно. Энэхүү арга нь таамаглагдашгүй содон урт уран зохиол бичихэд чухал. Түүнчлэн nucleus sampling буюу Top-p арга байдаг. Энэ нь нийлбэр магадлал нь p-д хүрэх хамгийн бага токенуудын багцаас сонгодог. Энэ нь тийм, үгүй эсвэл урт хариулт, богино хариултын загварыг тодорхойлдог. Иймээс хэрэглээнээс хамаарч samping стратеги сонгох нь чухал. Жишээлбэл тийм, үгүй сонголттой асуулт хариулт гаргах, урт тэмдэгт мөртэй хариулт гаргах гэх мэт байж болно. 

\subsection{Загварын үр дүнг хэмжих}

Суурь загварыг үнэлэх нь эрсдэлийг бууруулах, цаашлаад боломжуудыг илрүүлэх тал дээр чухал ач холбогдолтой. Үнэлгээ нь загвар сонгох, үр дүнг хэмжих, аппликейшн ашиглалтад бэлэн эсэхийг тодорхойлох, асуудал болон боломжуудыг илрүүлэх зэрэгт шаардлагатай. ~\cite{huyen2024}

Сүүлийн жилүүдэд бага параметртэй загвар нь өмнөх үеийн их параметртэй загвараас илүү чадалтай байна. Жишээлбэл, 2024 оны Llama 3-8B загвар нь 2023 оны Llama 2-70B загвараас ч илүү сайн үр дүнг MMLU benchmark дээр харуулжээ. Энэ нь зөвхөн загварын хэмжээ биш, сургалтын аргууд болон өгөгдлийн чанар хамгийн чухал болохыг харуулж байна.

Үнэлгээний хувьд гурван гол асуудал тулгардаг. Нэг дүгээрт, суурь загваруудыг зөвхөн гаралтуудын өгөгдлөөс дүгнэж үнэлэхэд хэцүү байдаг. Үүнийг хар хайрцаг гэх ба дотоод ажиллаж байгаа үйл явц биш зөвхөн эцсийн гаралт нь л мэдэгдэж байдаг. Хоёр дугаарт, загвар нь ижил эсвэл бага зэрэг өөр асуулт асуухад маш өөр хариулт өгч болох тогтворгүй байдал байдаг. Үүнээс хиймэл оюуны суурь загварын хариулт нь магадлалаас үүсдгийг ажиглаж болно. Гуравдугаарт, загвар нь баримт дээр үндэслээгүй буруу хариулт буюу төөрөгдөл үүсгэж болдог.

\section{Промпт инженерчлэл}

Промпт инженерчлэл гэдэг нь загвараас хүссэн үр дүнг гаргуулахын тулд промпт заавар бичих үйл явц юм ~\cite{openai2023}. Энэ нь загварын жинг өөрчлөхгүйгээр зан үйлийг удирдах хамгийн хялбар бөгөөд түгээмэл загварын дасан зохицох арга юм.

\subsection{Промпт бичих шилдэг арга барил}

Промпт заавруудыг хэрэглээнд тохирсон стратегиудын дагуу бичих нь илүү сайн үр дүн өгдөг. ~\cite{openai2023} OpenAI-ийн санал болгож буй промпт бичих шилдэг арга барил нь эхлээд юу хийлгэхээ хоёрдмол утгагүй байдлаар тодорхой тайлбарлах хэрэгтэй. Дараа нь загвараар тодорхой дүрд тоглуулж болно. Жишээ нь "Та том компанид 20 жил ажилласан туршлагатай программист. Кодыг шалгаад сайжруулж өг" гэх мэт. Anthropic-ийн зөвлөмжөөр промптод 500 хуудас бүхий номын урттай тэмдэгт мөр багтаж чадах тул промптод урт жишээ өгснөөр хариултын формат болон хариултын хоёрдмол утгыг багасгадаг. Цар хүрээ, агуулгыг мэдээлүүлснээр төөрөгдлийг багасгадаг. Хэрэв загвар шаардлагатай мэдээллээр хангагдаагүй бол өөрийн дотоод мэдлэгтээ найдах бөгөөд энэ нь найдваргүй байж болдог. Түүнчлэн нарийн төвөгтэй даалгавруудыг хялбар дэд даалгавруудад хувааж өгөх нь үр дүнтэйгээр бага токен ашиглах боломжийг олгоно.



\subsection{Зааврын инженерчлэлийн хамгаалалт}

Аппликейшн олон нийтэд ашиглагдах үе шатанд ормогц довтолгооноос хамгаалах шаардлагатай болдог. Тэдгээрийн нэг нь загварын зөвшөөрөөгүй үйлдэл хийлгэх оролдлого юм. Нөгөө нь загварын сургалтын өгөгдөл эсвэл контекстын мэдээллийг задруулах оролдлого юм. ~\cite{huyen2024}

Иймээс хиймэл оюуны агент эсвэл загвар угсарч буй тохиолдолд оролт болон гаралтыг үнэлж хамгаалах функц нэвтрүүлэх нь мэдээллийн аюулгүй байдлыг хангадаг. 

\section{Хайлтаар нэмэгдүүлсэн үүсгэлт (RAG)}

RAG буюу хайлтаар нэмэгдүүлсэн үүсгэлт нь загварын мэдлэгийг гадаад эх сурвалжаар өргөтгөх арга юм. Энэ нь загварын дотоод мэдлэг нь хангалтгүй, хуучирсан эсвэл алдаатай байх асуудлыг шийддэг. ~\cite{huyen2024}

Хэдийгээр загварын контекстийн урт тогтмол нэмэгдэж байгаа ч RAG-ийн ач холбогдол алдагдахгүй байна. Зарим аппликейшнд өгөгдлийн хэмжээ байнга өсч байдаг. Иймээс RAG удааширж магадгүй тул үүнийг сайтар үнэлж, тасралтгүй хөгжүүлэлт хийснээр бодит хэрэглээнд үр нөлөө алдахгүй байх боломжийг бүрдүүлнэ. Урт контекстыг боловсруулж чаддаг гэдэг нь тэр контекстыг сайн ашигладаг гэсэн үг биш. Контекст урт байх тусам загвар буруу хэсэгт анхаарал хандуулах магадлал өсдөг. Түүнчлэн контекстын токен бүр нэмэлт өртөг, нэмэлт хоцрогдол авчирдаг. RAG нь асуулт бүрт зөвхөн хамгийн холбогдолтой мэдээллийг ашиглах боломжийг олгоно.

Anthropic-ийн зөвлөмжөөр хэрэв мэдээлэл нь 200,000 токеноос бага (ойролцоогоор 500 хуудас бүхий өгөгдөл) бол RAG ашиглалгүй бүх мэдлэгийг промпт зааварт оруулж болно гэжээ.

\subsection{RAG системийн бүтэц}

RAG систем нь хоёр гол бүрэлдэхүүнтэй. Хайгч нь асуултад хамгийн холбогдолтой баримтуудыг олж авдаг. Үүсгэгч нь олж авсан баримтуудыг асуултад ашиглан хариулт үүсгэдэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/RAG.png}
    \caption{RAG-ийн бүтэц}
    \label{fig:rag}
\end{figure}

Зураг \ref{fig:rag}-аас харахад хайгч нь асуултад хамгийн их холбоотой баримтуудыг олж авдаг бол үүсгэгч нь олж авсан баримтуудыг ашиглан хариулт үүсгэдэг.

\subsection{Хайлтын алгоритмууд}

Хайлтаар олдсон өгөгдөл нь хэр оновчтой байх нь RAG-ийн хамгийн чухал хэсгүүдийн нэг ~\cite{huyen2024}. Өгөгдлийг вектор эсвэл өгөгдлийн бааз руу оруулах хялбар ч үүнээс хайлт хийх нь харьцангуй хүнд байдаг. Хамгийн түгээмэл алдаа нь векторд хэсэгчилж хуваагдахад өгүүлбэрүүд утга зүй бусаар хуваагдаж, хайлт хийх боломжгүй болдог. Иймээс хайлтын алгоритмээ зөв сонгох нь маш чухал. Дараах үндсэн хайлтын аргууд байдаг ~\cite{huyen2024}. 

\subsubsection{Нэр томьёо суурилсан хайлт}


Энэ арга нь түлхүүр үгээр баримт хайдаг. Энэ арга Google, Bing зэрэг хөтчийн хайлтын алгоритмд ашиглагдсаар ирсэн. Нэр томьёоны давтамж нь баримт доор нэр томьёо хэдэн удаа гарч байгааг хэмждэг бол баримтын урвуу давтамж нь нэр томьёо хэдэн баримтад гарч байгааг үндэслэн түүний чухлыг хэмждэг. Түгээмэл шийдлүүд нь Elasticsearch, BM25 зэрэг байдаг. Эдгээр нь урвуу индекс ашигладаг.

\subsubsection{Утга зүй дээр суурилсан хайлт}

Утга зүйн хайлт гэж нэрлэгддэг энэ арга нь утга зүйн түвшинд холбоотой байдлаар тооцож ажилладаг. Баримт бүр хуваагдаж embedding загвар болгон хувиргагдаж, векторын өгөгдлийн санд хадгалагдана. Асуулт ирэх үед түүний embedding загвартай хамгийн ойр векторуудыг хайдаг.

Векторын хайлтын алгоритмууд нь олон янз байдаг. Хамгийн ойр хөршүүд нь энгийн арга боловч өгөгдөл их бол удаан байдаг. Ойролцоо хамгийн ойр хөршүүд нь хурдан боловч ойролцоогоор хайдаг. Иймээс өгөгдлийн ангилал, форматаас шалтгаалж өөр өөр хайлтын алгоритм ашигладаг. Locality-Sensitive Hashing нь ижил төстэй векторуудыг нэг bucket-д hash хийдэг. Hierarchical Navigable Small World нь олон давхаргат граф ашигладаг. Inverted File Index нь K-means clustering ашиглан векторуудыг бүлэглэдэг. Алдартай векторын өгөгдлийн сангууд нь FAISS, Milvus, Pinecone, Weaviate, Qdrant зэрэг байна.

\subsection{RAG-ын үнэлгээ}

RAG системийг үнэлэхэд олон метрикүүд ашигладаг. ~\cite{huyen2024}. Context Precision нь олж авсан баримтуудын хэдэн хувь нь асуулттай холбоотой эсэхийг хэмжинэ. Context Recall нь асуулттай холбоотой бүх баримтуудын хэдэн хувийг олж авсан эсэхийг илэрхийлнэ. Эцсийн хариултын чанар нь хариултын ерөнхий чанарыг үнэлдэг.

\subsection{RAG-ыг сайжруулах аргууд}

RAG системийг сайжруулах олон арга байдаг. Баримтуудыг хэрхэн хэсэглэж салгах нь чухал ~\cite{huyen2024}. Тогтмол уртаар хэсэглэх, өгүүлбэр догол мөрөөр хэсэглэх, утга зүйгээр хэсэглэх зэрэг олон ялгаатай арга байдаг. Нэр томьёо болон утга зүйн хайлтыг хослуулсан арга ашиглаж болно. Асуултыг дахин найруулж илүү сайн хайлт хийж болно. Хэсэг бүрийг metadata, түлхүүр үг, холбогдох асуултуудаар баяжуулах нь хайлтын чанарыг сайжруулдаг. Аливаа ажиллаж байгаа RAG-аас ялгаатай гаралтуудыг хадгалж үнэлвэл тохирсон хайлтын аргыг сонгоход ойлгомжтой болдог.


\section{Хиймэл оюуны агентууд}

\subsection{Агент}

Агент гэдэг нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. ~\cite{huyen2024}. Хиймэл оюунаар дэмжигдсэн агентууд нь суурь загварын хүч чадлаар дамжуулан бидний туслах, хамтран ажиллагч, багш байж чадна. Агент нь вебсайт бүтээх, өгөгдөл цуглуулах, аялал төлөвлөх, зах зээлийн судалгаа хийх, харилцагчийн данс удирдах, өгөгдөл оруулалтыг автоматжуулах зэрэг олон ажил хэрэгт тусалж чадна.

\subsection{Агентын бүрэлдэхүүн хэсгүүд}

Хиймэл оюун агентыг тодорхойлдог хоёр гол зүйл байдаг. ~\cite{huyen2024}. Орчин нь агент ажиллах орчин бөгөөд түүний хэрэглээний тохиолдлоор тодорхойлогдоно. Жишээ нь интернэт, гал тогоо, хөдөлгүүрт хэрэгсэл зэрэг байж болно. Агентын хийж чадах үйлдлүүд нь түүний хандах боломжтой хэрэглүүрүүдээр өргөжинө.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/agentPre.png}
    \caption{Агентын бүрэлдэхүүн хэсгүүд}
    \label{fig:agentComponents}
\end{figure}

Зураг \ref{fig:agentComponents}-т агентын бүрэлдэхүүн хэсгүүдийг дүрсэлсэн. Зураг \ref{fig:agentComponents}-аас харахад агент нь орчин, үйлдэл, даалгавар гэсэн гурван гол бүрэлдэхүүнтэй.

\subsection{Хэрэглүүрүүд}

Гадаад хэрэглүүр байхгүй бол агентын чадавхи маш хязгаарлагдмал байх болно. Хэрэглүүр нь агентыг илүү чадварлаг болгодог. Цаашлаад уян хатан шийдвэр гаргалт, найдвартай гүйцэтгэлийн хоорондох хоосон зайг нөхдөг. Хэрэглүүрийг гурван ангилалд хуваах боломжтой.

Мэдлэг нэмэгдүүлэх хэрэглүүрүүд нь хайлтаар нэмэгдүүлсэн үүсгэлт систем буюу RAG-ын бүрэлдэхүүн хэсгүүд юм. Үүнд текст хайгч, зураг хайгч, SQL гүйцэтгэгч, интернэт хайлтын програмчлалын интерфэйс, дотоод хайлтын системүүд зэрэг багтана.

Чадавх өргөтгөх хэрэглүүрүүд нь агентын үндсэн чадварыг өргөжүүлдэг. Хиймэл оюун загварууд математикт сул байдаг тул агентд бэлэн тооны машины програмчлалын интерфэйс өгснөөр тооцоог оновчтой, хурдан, токены бага зарцуулалтаар гүйцэтгэдэг. Хэрэглэгчийн код уншигч нь код бичиж, ажиллуулах, үр дүн гаргах чадвартай. Энэ нь кодчилолын туслах, өгөгдөл шинжлэгч, судалгааны туслах боломжийг олгоно.

Бичих үйлдлийн хэрэглүүрүүд нь зөвхөн унших биш, өөрчлөлт оруулах хэрэглүүрүүд юм. Үүнд өгөгдлийн санд өгөгдөл нэмэх, засварлах, устгах, мэйл илгээх, банкны шилжүүлэг хийх, календарт тэмдэглэл нэмэх зэрэг үйлдлүүд багтана. Бичих үйлдэл нь өндөр эрсдэлтэй байдаг. Иймээс хортой промптын довтолгооноос болгоомжлох хэрэгтэй.

\subsection{Хиймэл оюун агентийн төлөвлөлт}

Хиймэл оюун агентийн төлөвлөлт нь агентын гол үүрэг бөгөөд олон үе шаттай. Зураг \ref{fig:agentPlanning}-т эхний үе шат нь төлөвлөгөө үүсгэх юм. Төлөвлөгч нь аливаа даалгаврын дагуу аливаа процессийг гүйцэтгэх төлөвлөгөө боловсруулна. Хоёр дахь үе шат нь эргэцүүлэн бодох ба алдаа засах юм. Үүсгэсэн төлөвлөгөөг үнэлэх бөгөөд муу байвал шинэ төлөвлөгөө гаргана. Гурав дахь үе шат нь гүйцэтгэл юм. Төлөвлөгөөнд заасан үйлдлүүдийг хийнэ. Эцсийн үе шат нь үр дүнг үнэлэх явдал юм. Үйлдлийн үр дүнг хүлээн авсны дараа зорилго биелсэн эсэхийг тодорхойлж, алдааг засна.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/agentPost.png}
    \caption{Агентын төлөвлөлт}
    \label{fig:agentPlanning}
\end{figure}

\subsection{Суурь загварууд төлөвлөгч болж чадах уу}

Зарим судлаачид том хэлний загвар нь төлөвлөгч болж чадахгүй гэж үздэг. ~\cite{falconer2025agents}. Учир нь төлөвлөлт нь үндсэндээ хайлтын асуудал бөгөөд авторегрессив буюу магадлалт суурилсан загвар нь зөвхөн үргэлж ялгаатай, буруу хариулт өгдөг. Гэвч бодит байдал дээр загвар өөр өөрийнхөө үүсгэсэн төлөвлөгөөг үнэлээд дахин эхэлж чаддаг тул сургалт сайн хийснээр сайн төлөвлөгөө гарч болно.

Төлөвлөлтийг сайжруулах олон арга байдаг. Илүү сайн системийн промпт заавар бичиж, жишээ олноор өгөх нь чухал. Хэрэглүүрүүдын тайлбарыг илүү сайн бичих хэрэгтэй. Функцүүдийг хялбарчлах, задлах нь төлөвлөлтийг хөнгөвчилдөг. Илүү хүчтэй загвар ашиглах нь илүү сайн төлөвлөгөө гаргах боломжийг олгоно. Төлөвлөлтөд зориулж загварыг нарийвчлан сургах нь бас үр дүнтэй. Зарим судалгаагаар оновчтой хэрэглүүр өгөх нь нарийвчилсан сургалт хийснээс илүү үр дүнтэй бас хямд гэж үзжээ ~\cite{huyen2024}.

\subsection{Эргэцүүлэн бодох ба алдаа засах}

Хамгийн сайн төлөвлөгөө байнга үнэлэгдэж, тохируулагдах шаардлагатай. Эргэцүүлэн бодох нь агентын амжилтад чухал үүрэг гүйцэтгэнэ. Үүнийг хоёр аргаар хийж болно. Эхний арга нь өөрийгөө шүүмжлэх арга юм. Ижил загвар өөртэйгөө ярилцаж алдааг илрүүлдэг. Хоёр дахь арга нь тусдаа үнэлэгч ашиглах явдал юм. Тусдаа загвар эсвэл функц үр дүнд оноо өгдөг.

\subsection{Агентын санах ой}

Хиймэл оюун загвар нь гурван санах ойн механизмтай ~\cite{huyen2024}. Дотоод мэдлэг нь загварын өөрийн дотоод мэдээлэл юм. Энэ нь сургалтын өгөгдлөөс олж авсан мэдлэг бөгөөд загварыг шинэчлэхгүй л бол өөрчлөгдөхгүй. Богино хугацааны санах ой нь загварын контекст юм. Өмнөх мессежүүд контекстэд нэмэгдэж болно. Даалгавар дууссаны дараа устдаг. Хурдан боловч устдаг шинжээр хязгаарлагдмал. Урт хугацааны санах ой нь гадаад өгөгдлийн эх сурвалж буюу хайлтаар нэмэгдүүлсэн үүсгэлт (RAG) юм.

\subsection{Яагаад олон агентын зохиомж хэрэгтэй вэ?}

Агент нь тодорхой даалгаврын хүрээнд л процесс гүйцэтгэх чадвартай байдаг. Жинхэнэ бизнесийн үйл ажиллагаа нь олон дэд процессд хуваагдаж болдог шиг агентийн хэрэглээ мөн адил олон хуваагдаж болдог. Тиймээс олон агентийн зохиомж нь ялгаатай орчинд нарийн төвөгтэй асуудлыг шийдэх, дасан зохицох, үр дүнтэй хамтран ажиллах боломжийг олгодог.
Жишээлбэл байгууллага өөрсдийн сургасан үнэтэй загвартай байлаа гэж үзэхэд уг загварыг зөвхөн хэрэгтэй процессд нь ажиллуулаад, харин хямдхан GPT-2 зэрэг загвараар чиглүүлэгч, ангилагч зэрэг хямд процессд үлдээж болно. Иймээс олон агент зохиомжтой байх нь тооцооллын зардлыг бууруулж болох ба практикт тохиромжтой арга зам юм.

\section{Жишээ хиймэл оюунт программ хангамжийн зохиомж}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/charAIAgent.png}
    \caption{Хиймэл оюунт аппликейшн}
    \label{fig:charAIAgent}
\end{figure}

Зураг \ref{fig:charAIAgent}-т олон агентийн архитектурын зохиомжийг дүрсэлнэ. Программ хангамж хөгжүүлэхэд бэлэн суурь загвар эсвэл өөрсдөө байршуулсан загварыг ашиглаж болдог. Суурь загвар нь илүү их тооцоолол шаардаж, мөн хоцрогдол өндөр байдаг учраас үр ашигтай дасан зохицуулалт хийх шаардлагатай байдаг. Зурган дээрхээр хүсэлтийг ангилахад хямд агент болох RAG, чиглүүлэгч ашиглаж мөн эдгээр нь бусад үнэтэй агент руу шилжүүлж болно. Мэдээллийн аюулгүй байдлын үүднээс хиймэл оюуны оролт эсвэл гаралтыг хамгаалж болдог. 

\section{Ижил төстэй системүүдийн судалгаа}

Хиймэл оюун агентийг нэвтрүүлсэн хэд хэдэн үйлдвэрийн түвшний шийдлүүд байдаг. Эдгээр системүүдтэй харьцуулалт хийснээр энэ судалгааны санал болгож буй зохиомжийн онцлог байр суурийг тодорхойлно ~\cite{inngest} ~\cite{camunda} ~\cite{bpmnEngine}.

\textbf{Inngest} нь serverless workflow платформ бөгөөд үйл явдлаар удирдагдах архитектур (Event-Driven Architecture) суурилсан, хэрэглэгчийн функцийн түвшинд ажилладаг. LLM интеграци байдаг ч RAG систем дутмаг байна. Голдуу startup, жижиг багуудад зориулагдсан.

\textbf{Temporal} нь даалгаврын төлөв байдлаа хадгалж, унасан ч яг өмнөх төлөв дээр буцан сэргэж чаддаг платформ бөгөөд олон хэлний дэмжлэгтэй. Гэвч тодорхой процессийг л гүйцэтгэх тул өөрийгөө удирдах агент болж чадахгүй. Uber, Netflix, Stripe зэрэг томоохон компаниуд ашигладаг.

\textbf{Camunda} нь BPMN 2.0 стандартад суурилсан процессын автоматжуулалтын платформ. Enterprise түвшний шийдэл боловч хиймэл оюуны дэмжлэг хязгаарлагдмал.

Дээрх системүүдээс ялгаатай нь энэ судалгааны санал болгож буй зохиомж нь хиймэл оюун агентуудыг анхнаасаа салангид микросервис болгон хөгжүүлж, төлөвлөгч нь микросервис бүр рүү чиглүүлж, Kafka-Flink ашиглан бодит цагийн урсгал боловсруулалт хийж, Temporal шиг дахин сэргэх чадвартайгаар нээлттэй эхийн технологи ашиглаж, хэвтээгээр өргөжих боломжтой байхаар зохиомжилсон. Энэ нь байгууллагын дотоод системд бие даасан байдлаар ажиллах боломжтой юм.

\section{Бүлгийн дүгнэлт}

Энэхүү бүлэгт хиймэл оюуны инженерчлэлийн үндсэн ойлголтуудыг авч үзлээ. Хиймэл оюуны инженерчлэл нь бэлтгэгдсэн суурь загвар дээр програм хангамж хөгжүүлэхэд чиглэсэн шинэ салбар юм ~\cite{huyen2024}. Суурь загварын хөгжлийн замнал нь хэл загвараас том хэлний загвар, улмаар суурь загвар руу шилжих үйл явц байсан. Өөрийгөө удирдсан сургалт, Transformer архитектур, дараах сургалт аргууд нь өнөөгийн хүчирхэг хиймэл оюун системүүдийн суурь болсон.

Промпт инженерчлэл нь загварыг дасан зохицуулах хамгийн хялбар арга бөгөөд машин сургалт хийхгүйгээр программ хангамжид хиймэл оюун интеграц хийх боломжийг олгодог. RAG систем нь загварын дотоод мэдлэгийн хязгаарлалтыг даван, гадаад эх сурвалжаас мэдээлэл авч хариултын найдвартай байдлыг нэмэгдүүлдэг.

Хиймэл оюун агент нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. Агентын гурван гол бүрэлдэхүүн нь орчин, үйлдэл, даалгавар юм. Олон агентын зохиомж нь нарийн төвөгтэй бизнес процессуудыг шийдэхэд илүү тохиромжтой бөгөөд агент бүр мэргэшсэн даалгавартай байснаар системийг өргөжүүлэх боломжтой болгодог.

Inngest, Temporal, Camunda зэрэг одоо байгаа системүүдтэй харьцуулахад энэ судалгааны санал болгож буй зохиомж нь хиймэл оюун агентуудад зориулан тусгайлан бүтээгдсэн, Kafka-Flink суурилсан, нээлттэй эхийн технологи ашигласан онцлогтой.

\chapter{Микросервис ба агентууд}

Энэхүү бүлэгт микросервис архитектурын онолыг судлах ба үйл явдлаар удирдагдах архитектур (EDA), Apache Kafka, Apache Flink технологиудыг тайлбарлаж, агентуудыг микросервис болгон хөгжүүлэх үндэслэлийг тодорхойлно.

\section{Монолитоос микросервис рүү}

\subsection{Монолитын эрин үе}

Вэб аппликейшн хөгжүүлэлтийн эхэн үед гол архитектурын зохиомж нь монолит байв. Бүх бизнес логик, өгөгдлийн логикууд нэг том, нэгдсэн кодын санд амьдардаг байв. Программ хангамжийн хөгжүүлэгчид монолитуудыг хөгжүүлэхэд, нэвтрүүлэлт хийхэд энгийн, хялбар байв. ~\cite{wolff2016}

\subsection{Монолитыг өргөжүүлэх сорилт}

Гэвч аппликейшнууд томрох тусам асуудлууд нэмэгдсээр ирсэн. Монолитыг өргөжүүлэх нь бүх зүйлийг нэгтгэсэн байдлаар өргөжүүлдэг. Нэг модульд хийсэн жижиг өөрчлөлт аливаа кодын санд орсноор энэ нь шинэчлэлтийг удаашруулж, унах эрсдлийг нэмэгдүүлдэг. Өөр өөр дэд процесс дээр ажиллаж байгаа багууд бие биенийхээ кодод хамаарал бүхий харилцаагаар холбогдож, хөгжлийг удаашруулж, алдаа гарах эрсдлийг нэмэгдүүлсээр ирсэн.

Монолит архитектураас эхэлсэн компаниуд эдгээр асуудлууд тулгарж хурдан үйл ажиллагаагаа явуулахын тулд багууд системийг шинэчлэх хүртэл хүлээх шаардлагатай байв. Энэ нь компанийн бизнесийн үйл ажиллагаанд маш том саад бэрхшээл болов.

\subsection{Микросервис рүү шилжих}

Эдгээр хязгаарлалтаас ангижрахын тулд компаниуд микросервис архитектур руу шилжиж эхлэв ~\cite{wolff2016}. Энэ өөрчлөлт нь багуудад салангид байдлаар өөрчлөлтийг хурдан байршуулалт хийх, аппликейшнийг дахин байршуулалт хийхгүйгээр шинэчлэл гаргах боломжийг олгосон. Микросервис рүү шилжих нь зөвхөн өргөжүүлэх чадварыг сайжруулаад зогсохгүй, багуудад бие даасан байдал өгч, хамтын ажиллагааны ачааллыг бууруулж, инновацийг хурдасгасан.

\subsection{Микросервисийн тодорхойлолт}

Микросервис архитектур нь програм хангамжийн гол зохиомжийн аргуудын нэг бөгөөд аппликейшныг жижиг, бие даасан сервисүүдэд хувааж, өргөтгөхөд хялбар байдлаар хөгжүүлдэг. Энэхүү архитектурын гол онцлог нь дөрвөн чухал шинж чанарт илэрхийлэгддэг. ~\cite{wolff2016}.

Эхний шинж чанар нь бие даасан байдал юм. Микросервис бүр өөрийн тодорхой үүрэгтэй бөгөөд шаардлагатай бол өөрийн өгөгдлийн сантай байдаг. Энэ нь сервис бүр бусад сервисээс хараат бус ажиллах боломжийг олгодог. Хоёр дахь шинж чанар нь уян хатан хөгжүүлэлт юм. Өөр өөр багууд өөр өөр технологи, програмчлалын хэл ашиглан өөрсдийн сервисийг хөгжүүлж болдог. Энэ нь багууд өөрсдийн мэргэжлийн чиглэлд тохирсон технологи сонгох чөлөөг өгдөг. Гурав дахь шинж чанар нь өргөжих чадвар юм. Бүх системийг өргөжүүлэх шаардлагагүй бөгөөд зөвхөн ачаалал их эсвэл илүү их нөөц шаарддаг сервисийг л өргөжүүлэх боломжтой. Дөрөв дэхь шинж чанар нь найдвартай байдал юм. Хэрэв нэг сервис алдаа гарч унавал бусад сервисүүд хэвийн ажиллаж үргэлжлэх бөгөөд энэ нь системийн ерөнхий тогтвортой байдлыг хангадаг.

\section{Микросервисийн давуу тал}

Микросервис архитектур нь монолит системээс олон талаараа давуу талтай байдаг. Технологийн олон янз байдлын талаас авч үзвэл, сервис бүр өөрийн хэрэгцээнд хамгийн тохирсон технологи сонгох боломжтой. Жишээлбэл, нэг сервис Python програмчлалын хэл ашиглаж өгөгдөл боловсруулалт хийж болох бол нөгөө сервис Go ашиглан өндөр гүйцэтгэлтэй серверийн хэсэг хариуцаж, өөр нэг сервис Node.js ашиглан бодит цагийн холболт зэргийг удирдаж болно. ~\cite{nadareishvili2016}.

Багуудын бие даасан ажиллагааны хувьд баг бүр өөрийн сервисийг хараат бусаар хөгжүүлж, шууд хэрэглээнд нэвтрүүлэх чадвартай. Энэ нь багуудын хурд, уян хатан байдлыг нэмэгдүүлдэг. Хурдан нэвтрүүлэлтийн талаас авч үзвэл том системийг бүхэлд нь дахин нэвтрүүлэх шаардлагагүй бөгөөд зөвхөн өөрчлөлт орсон сервисийг л нэвтрүүлэхэд цаг хугацааг ихээхэн хэмнэдэг. Илүү сайн өргөжих чадварт ачаалал их байгаа тодорхой сервисийг л өргөжүүлэх нь бүх системийг бүхэлд нь өргөжүүлэхээс илүү үр ашигтай бөгөөд зардал хэмнэлттэй. Эцэст нь алдааны тусгаарлалтын талаас авч үзвэл нэг сервисийн алдаа нь бусад сервист шууд дамжихгүй тул системийн бусад хэсэг хэвийн үргэлжлэн ажилладаг.

\section{Микросервисийн сорилтууд}

Микросервис архитектур олон давуу талтай боловч практикт тулгарах сорилтууд ч багагүй байдаг. Нарийн төвөгтэй байдлын хувьд олон сервисүүдийг зэрэг удирдах, тэдгээрийн харилцааг хянах, байршуулалтыг хийх нь монолит системээс илүү төвөгтэй бөгөөд тусгай хяналтын хэрэгслүүд шаарддаг. ~\cite{nadareishvili2016}.

Өгөгдлийн тогтмол байдлын асуудал нь сервис бүр өөрийн өгөгдлийн сантай байдгаас үүсдэг. Олон сервисийн өгөгдлийн нийцтэй, уялдаатай байдлыг хангах нь уламжлалт транзакцийн удирдлагаар шийдэгдэхгүй асуудал болдог. Сүлжээний хоцрогдлын талаас авч үзвэл сервисүүд хоорондоо сүлжээгээр харилцдаг учир нэмэлт хоцрогдол гардаг бөгөөд энэ нь системийн ерөнхий гүйцэтгэлд нөлөөлдөг. Алдаа илрүүлэх хэцүү байдал нь олон сервисүүдээр дамжин явах хүсэлтийн алдааг олж тодорхойлох, засах ажил үйл ажиллагаа төвөгтэй болдог. Сервис хоорондын харилцааны асуудал нь сервисүүд хэрхэн үр дүнтэй харилцах, ямар протокол ашиглах, өгөгдлийн формат хэрхэн нийцүүлэх зэрэг олон нарийн асуудлыг шийдэхийг шаарддаг. Эцэст нь транзакцийн удирдлагын асуудал нь олон сервисүүдээр транзакци явуулах нь өгөгдлийн сангууд түгжигдэх, тогтворгүй байдал үүсэх эрсдлийг нэмэгдүүлдэг. 

\section{Микросервис хоорондын харилцаа}

Микросервисүүд хоорондоо хоёр гол аргаар харилцдаг: ~\cite{nadareishvili2016}.

\subsection{Синхрон харилцаа}

Синхрон харилцаа нь HTTP REST програмчлалын интерфэйс эсвэл gRPC ашиглан шууд хүсэлт илгээж хариу хүлээдэг арга юм. Энэ арга нь хэрэгжүүлэхэд харьцангуй энгийн боловч сул талтай. Эхний сул тал нь нягт хамаарал буюу tight coupling үүсгэдэг. Сервисүүд бие биенээсээ шууд хамаарч байдаг учир нэг сервис өөрчлөгдөх үед бусад сервист нөлөөлдөг. Хоёр дахь сул тал нь нэг сервис унавал түүнээс хамааралтай бусад сервисүүд ч гэсэн алдаа гаргаж зогсдог. Энэ нь системийн найдвартай байдлыг бууруулдаг. Гурав дахь сул тал нь хоцрогдол нэмэгддэг. Сервисүүд бие биенээсээ хариу хүлээж байдаг учир хариултын цаг удаан байх тусам ерөнхий системийн хоцрогдол нэмэгддэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/microservice.png}
    \caption{Синхрон микросервис}
    \label{fig:microservicesync}
\end{figure}

Сервисийн тоогоор NxM холболтын харьцаагаар холболт нэмэгдэх учир үүнийг найдвартай удирдахад маш хүндрэлтэй болно.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/conMonolith.png}
    \caption{Синхрон микросервисийн NxM холбоо}
    \label{fig:conmicroservicesync}
\end{figure}

\subsection{Асинхрон харилцаа}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/microserviceEda.png}
    \caption{Асинхрон микросервис}
    \label{fig:microserviceasync}
\end{figure}

Асинхрон харилцаа нь мессежийн дараалал ашигладаг арга бөгөөд RabbitMQ, Apache Kafka зэрэг технологиудыг ашиглан мессеж солилцдог. Энэхүү аргууд дараах онцлогтой. Эхний онцлог нь салангид байдлыг үүсгэдэг. Сервисүүд шууд бус мессежийн брокероор дамжин харилцдаг учир бие биенээсээ хараат бус байдаг. Хоёр дахь онцлог нь илүү найдвартай байдаг. Нэг сервис түр зуур унасан ч мессеж хадгалагдсан байх тул дараа нь боловсруулагдах боломжтой. Гурав дахь онцлог нь синхрон харилцаанаас илүү төвөгтэй хэрэгжилттэй байдаг. Мессежийн формат тодорхойлох, алдааны менежмент хийх, мессежийн дараалал хангах зэрэг нэмэлт асуудлыг шийдэх шаардлагатай.

\section{Үйл явдлаар удирдагдах архитектур буюу EDA}

\subsection{EDA гэж юу вэ}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/conMicroservice.png}
    \caption{Үйл явдлаар удирдагдах архитекурт микросервис}
    \label{fig:microserviceaconsync}
\end{figure}

Микросервисүүд гарч ирснээр шинэ сорилт бий болсон ~\cite{nadareishvili2016}.: эдгээр сервисүүд хэрхэн үр дүнтэй харилцах вэ? Хэрэв бид сервисүүдийг шууд gRPC эсвэл API-ээр холбовол бид асар том хамаарлын сүлжээ үүсгэнэ. Хэрэв нэг сервис унавал энэ нь холбогдсон замын дагуух бүх node-д нөлөөлнө. Мөн гацалт маш ихээр үүснэ.

EDA нь энэхүү асуудлыг шийдэж болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Сервисүүд бие биенийгээ хүлээхгүй. Бодит цагт юу болж байгааг мэдээд хариу үйлдэл үзүүлдэг.



\subsection{EDA-ын давуу тал}

EDA нь дөрвөн гол давуу талтай. Салангид байдлын хувьд сервисүүд үйл явдлаар харилцдаг учир тэд бие биенээсээ бүрэн хараат бус байдаг. Нэг сервис өөрчлөгдөх эсвэл түр зуур унах нь бусад сервист шууд нөлөөлөхгүй бөгөөд энэ нь системийн уян хатан чанар байдлыг дээшлүүлдэг.

Өргөжүүлэх чадварын талаас авч үзвэл сервис бүр үйл явдлыг бие даан боловсруулдаг учир шаардлагатай сервисийг л өргөжүүлэх боломжтой. Энэ нь бүх системийг өргөжүүлэхээс хамаагүй хялбар бөгөөд зардал хэмнэлттэй. Уян хатан байдлын хувьд шинэ сервис нэмэх эсвэл одоо байгаа сервисийг өөрчлөх нь бусад сервист өөрчлөлт шаардахгүй. Үйл явдлын формат өөрчлөгдөөгүй бол өөр бусад сервисүүд хэвээр ажилладаг. Эцэст нь бодит цагийн боловсруулалтын талаас авч үзвэл үйл явдлууд тэр даруйдаа боловсруулагдах тул систем нь өөрчлөлт, шинэ мэдээлэлд маш хурдан хариу үйлдэл үзүүлэх чадвартай.

\subsection{Apache Kafka}

Apache Kafka нь салангид, өндөр дамжуулалттай, бага хоцрогдолтой EDA-ийн төв мэдээллийн систем болж чаддаг. ~\cite{kreps2014}.

\subsubsection{Kafka-ийн үндсэн ойлголтууд}

Apache Kafka-ийн архитектур нь таван үндсэн ойлголт дээр суурилдаг. ~\cite{kreps2014}. Сэдэв буюу topic нь үйл явдлуудыг ангилах логик сувагийн үүрэг гүйцэтгэдэг. Жишээлбэл "user-events", "order-events" гэх мэт нэршлээр үйл явдлуудыг ангилж хадгалдаг. Үйлдвэрлэгч буюу producer нь үйл явдлыг topic руу бичдэг аппликейшн юм. Хэрэглэгч буюу consumer нь эсрэгээр сэдвээс үйл явдлыг уншиж боловсруулдаг аппликейшн болно. Хэсэглэл буюу partition нь topic-ийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог механизм юм. Нэг topic олон partition-д хуваагдаж, параллель уншигдаж боловсруулагдах боломжтой. Эцэст нь хэрэглэгчийн груп буюу consumer group нь олон consumer нэг баг болон зохион байгуулагдаж ачааллыг хуваарилан боловсруулах боломжийг олгодог.

\subsubsection{Kafka-ийн давуу тал}

Apache Kafka дараах давуу талуудтай. ~\cite{kreps2014} Хэвтээ өргөжих чадварын хувьд Kafka-ийн салангид зохиомж нь саадгүйгээр шинэ агент эсвэл хэрэглэгч нэмэх боломжийг олгодог. Системийн ачаалал нэмэгдэх тусам partition нэмж, хэрэглэгч нэмж өргөжүүлэх нь маш энгийн.

Бодит цагийн үйл явдал боловсруулалт нь агентуудад өөрчлөлтөд шууд хариу үйлдэл үзүүлэх боломжийг олгодог. Мессеж миллисекундын дотор дамжих учир бодит цагийн систем бүтээхэд тохиромжтой. Салангид хамааралын талаас авч үзвэл сэдвүүдээр харилцах нь агентууд хараат бус, өргөжүүлэх боломжтой байхыг баталгаажуулдаг. Агент нэмэх, хасах, өөрчлөх нь бусад агентад нөлөөлөхгүй. Үйл явдлын хадгалалтын талаас авч үзвэл тогтвортой мессежийн хадгалалт нь өгөгдөл дамжилтын явцад алга болохгүй гэдгийг баталгаажуулдаг. Мессеж диск дээр хадгалагддаг учир хэрэглэгч алдаатай байсан ч мессеж хадгалагдсан байна. Эцэст нь дахин ачааллуулж гүйцэтгэх боломжийн хувьд Kafka нь салангид лог ашигладаг учраас үйл явдал бүр хадгалагдаж, алдаа засах, үнэлгээ хийх, загвар дахин сургахад дахин тоглуулж ашиглах боломжтой.

\subsection{Apache Flink}

Apache Flink нь сүүлийн төлвөөр тооцоолол, үйл явдал цагийн боловсруулалт хийх чадвартай салангид урсгал тооцооллын фреймворк юм. ~\cite{flink} Flink нь Kafka-тай хамт ашиглах замаар хүчирхэг бодит цагийн өгөгдөл боловсруулалтын систем бүтээх боломжийг олгоно.

\subsubsection{Flink-ийн давуу тал}

Apache Flink нь дараах давуу талуудтай. Flink нь төлөв байдлыг найдвартай удирдаж, нарийн төвөгтэй тооцоолол хийх боломжийг олгодог. Үйл явдлуудын хоорондох хамаарлыг хадгалж, өөр бусад цар хүрээтэй өгөгдлийг ашиглан нарийн шинжилгээ хийж чаддаг. Үйл явдлын цаг дээр үндэслэн бодит цагийн шинжилгээ хийх чадвартай. Энэ нь хоцрогдсон мессежүүдийг зөв цагийн дагуу боловсруулах боломжийг олгодог. Flink нь секундэд сая сая үйл явдлыг боловсруулах чадвартай бөгөөд параллель боловсруулалт ашиглан асар их хэмжээний өгөгдлийг боловсруулж чаддаг. Эцэст нь "яг ганц" семантикийн талаас авч үзвэл мэдээлэл яг нэг удаа л боловсруулагдахаар баталгааждаг. Энэ нь өгөгдөл алдагдах эсвэл давхардах асуудлыг шийддэг.

\subsection{Flink ба хиймэл оюун}

Flink нь том хэлний загвартай ажиллах чадвартай. ~\cite{falconer2025future} Flink нь өгөгдлийг авч, том хэлний загвар руу илгээж, хариу авах боломжийг олгодог. Энэ нь төлөвлөгч агентыг Flink аппликейшн болгон хөгжүүлэх боломжийг олгодог.

Ажиллах зарчмыг жишээгээр авч үзье. Эхлээд Kafka сэдвээс үйл явдлыг уншина. Дараа нь том хэлний загвар ашиглан цар хүрээг ойлгох, даалгаврыг задлах, төлөвлөгөө гаргах үйл явцыг гүйцэтгэнэ. Үр дүнг өөр Kafka topic руу бичинэ. Эцэст нь бусад агентууд энэ үр дүнг уншиж тодорхой үүргүүдээ гүйцэтгэнэ. Иймээс рекурисв байдлаар ажиллаж чаддаг. Энэхүү зохион байгуулалт нь урсгал боловсруулалтын давуу талыг хиймэл оюун агенттай нэгтгэж чаддаг.

\subsubsection{Flink болон RAG}

Төөрөгдлийг багасгахын тулд том хэлний загварыг бодит өгөгдөлд суурилуулах хэрэгтэй. Flink нь хайлтаар нэмэгдүүлсэн үүсгэлтийн зохион байгуулалтыг бүтээхэд чухал үүрэг гүйцэтгэдэг.  ~\cite{polak2025}

Энэ үйл явц нь таван үндсэн алхамтай. Эхлээд Flink нь өгөгдлийг боловсруулж, цэвэрлэж, хувиргана. Дараа нь загварын гаралтыг ашиглан өгөгдлийг embedding болгон хөрвүүлнэ. Гурав дахь алхамд векторчилсан хэсгийн төлөөлөл буюу embedding-г Kafka topic руу бичиж хадгална. Дөрөв дэхь алхамд Kafka Connect ашиглан векторчилсан хэсгийн төлөөллийг векторын өгөгдлийн сан руу синхрончилдог. Эцсийн алхамд агентууд хайлтаар нэмэгдүүлсэн үүсгэлт ашиглан бодит өгөгдөл дээр суурилсан найдвартай хариулт өгөх боломжтой болно. Энэ урсгал нь бодит цагт өгөгдлийг боловсруулж, том хэлний загварын мэдлэгийг тасралтгүй шинэчилж байх боломжийг олгодог.

\subsection{Агентууд ба EDA}

Хиймэл оюун агентуудыг өргөжүүлэх нь үндсэндээ салангид систем байж болох талаарх асуудал юм. Агентууд нь шийдвэр гаргаж, үйлдэл хийхийн тулд олон эх сурвалж, бусад агентууд, хэрэглүүрүүд, гадаад системүүдээс мэдээлэл цуглуулах шаардлагатай.  ~\cite{huyen2024} 

Агентууд яагаад үйл явдлаар удирдагдах архитектур шаарддаг вэ гэдэг нь гурван гол шалтгаанаас үүдэлтэй. Асинхрон шинж чанарын хувьд агентууд хүн шиг ажилладаг. Агент нь олон эх сурвалжаас мэдээлэл цуглуулж, өгөгдлийг шинжилж, бүх талын мэдээлэлд үндэслэн шийдвэр гаргах хэрэгтэй. Эдгээр үйл явцууд нь асинхрон шинжтэй бөгөөд тодорхой дарааллаар биш параллель явагддаг.  ~\cite{falconer2025future}

Агентууд нь өмнөх үйлдлүүдийн үр дүн, бусад агентуудын гаралт, хэрэглэгчийн түүх зэрэг олон мэдээллийг нэгтгэж ашигладаг. Энэ нь хамаарлыг оновчтой удирдах, бодит цагийн өгөгдлийн урсгалыг гаргах онцгой шаардлагыг бий болгоно. Агентын гаралт нь зөвхөн хиймэл оюунт аппликейшн рүү биш, харин өгөгдлийн сан, CRM, харилцагчийн төлбөр тооцоо зэрэг бусад чухал системүүд рүү урсаж болно. Мөн алдаа засах, шинжилгээ хийх зорилгоор лог хадгалах шаардлагатай.

Агентуудыг синхрон холболттой gRPC болон API-аар холбож болно, гэвч энэ нь нягт холбогдсон системүүдийг бий болгодог. Энэхүү нягт холбоос нь өргөжүүлэх, дасан зохицох, эсвэл ижил өгөгдлийн олон хэрэглэгчдийг дэмжихэд хэцүү болгодог. Агентууд нь уян хатан байдлыг шаарддаг. Тэдний гаралт нь бусад агентууд, сервисүүд, платформуудад тодорхой дүрмийн дагуу үр дүн дамжих ёстой.

\section{Бүлгийн дүгнэлт}

Энэхүү бүлэгт микросервис архитектурын онол, практик, түүнчлэн үйл явдлаар удирдагдах архитектурын давуу талыг дэлгэрүүлэн судалсан. Монолит системээс микросервис рүү шилжих нь программ хангамжийн хөгжлийн чухал дэвшил болов. ~\cite{falconer2025future}

Микросервис хоорондын харилцаа нь хоёр гол аргаар хэрэгждэг. Синхрон харилцаа нь HTTP REST эсвэл gRPC ашигладаг боловч нягт хамаарал үүсгэж, нэг сервис унавал бусад сервисүүдэд алдаа гаргадаг. Сервисийн тоогоор NxM холболтын нарийн төвөгтэй байдал нь системийг удирдахад хүндрэлтэй болгодог. Асинхрон харилцаа нь мессежийн брокер ашигладаг бөгөөд салангид байдлыг бий болгож, найдвартай боловч илүү төвөгтэй хэрэгжилттэй.

EDA нь микросервисийн энэхүү харилцааны хамгийн үр дүнтэй шийдэл болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Салангид байдал, өргөжүүлэх чадвар, уян хатан байдал, бодит цагийн боловсруулалт зэрэг давуу талууд нь EDA-г орчин үеийн микросервис архитектурын суурь болгосон.

Apache Kafka нь EDA-ын хүчирхэг хэрэглүүр ба "Topic, producer, consumer, partition, consumer group" зэрэг үндсэн ойлголтууд нь системийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог. ~\cite{polak2025} Kafka-ийн хэвтээ өргөжих чадвар, бага хоцрогдол, салангид байдал, үйл явдлын хадгалалт, дахин тоглуулах боломж зэрэг онцлогууд нь өргөн ашиглагддаг шалтгаан болов.

Apache Flink нь Kafka-тай хамт ашиглахад илүү хүчирхэг болдог. Өгөгдөл холбож дамжуулах боловсруулалт, өндөр дамжуулалт, "яг л нэг" зарчим зэрэг давуу талууд нь нарийн төвөгтэй урсгал боловсруулалтад тохиромжтой. Flink нь хиймэл оюуны загвартай холбогдож, төлөвлөгч агентыг Flink app болгон хөгжүүлэх боломжийг олгодог. Flink болон RAG-ийг хослуулах нь төөрөгдлийг багасгаж, бодит өгөгдөлд суурилсан хиймэл оюун систем бүтээхэд тусалдаг.

Хиймэл оюун агентууд бүр өөр өөрийн гэсэн даалгаврын цар хүрээ хариуцах учраас микросервис шиг салангид байдлаар ашиглагдвал цаашдын хиймэл оюунт программ хөгжүүлэхэд үр дүнтэй. Агентуудын олон цар хүрээт мэдээллийн хамаарлаар, олон хэрэглэгчдэд үйлчлэхэд EDA зайлшгүй шаардлагатай болгодог. Агентуудыг gRPC эсвэл API-аар холбох нь боломжтой боловч нягт холбоос үүсгэж, өргөжүүлэх, дасан зохицоход хүндрэлтэй болгодог. EDA нь агентуудыг салангид микросервис болгон хөгжүүлэх, өргөжүүлэх, найдвартай байлгах хамгийн тохиромжтой арга замуудын нэг болох юм.

Энэхүү бүлгээс харахад микросервис архитектур нь монолитын асуудлуудыг шийдэж чадсан боловч шинэ сорилтууд авчирсан. Үйл явдлаар удирдагдах архитектур, Kafka, Flink зэрэг технологиуд нь эдгээр сорилтуудыг шийдэж, илүү уян хатан, өргөжих боломжтой, найдвартай систем бүтээх суурийг бүрдүүлсэн. Дараагийн бүлэгт эдгээр онолуудыг ашиглан тодорхой асуудлуудыг хэрхэн шийдэх талаар авч үзнэ.

% Асуудлын тодорхойлолт ба шийдэл - Нэгдсэн бүлэг
\include{src/problem-solution}

% Хэрэгжүүлэлт бүлэг
\include{src/implementation}

%----------------------------------------------------------------------------------------
%   Дүгнэлт эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\conclusion{Дүгнэлт}

Энэхүү судалгааны ажлаар хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг судалж, шийдлийн зохиомжийг санал болголоо. Судалгааны явцад дараах гол үр дүнд хүрсэн:

\textbf{Онолын хувьд:}

Хиймэл оюуны инженерчлэл нь програм хангамж хөгжүүлэлтийн шинэ салбар болж хөгжиж байгаа нь тодорхой. Суурь загвар гарч ирэх нь аппликейшн хөгжүүлэлтийн саад бэрхшээлийг эрс багасгасан. Хэл загвараас суурь загвар хүртлээ хөгжих үйл явц нь арван жилийн технологийн дэвшлийн үр дүн юм. Өөрийгөө удирдсан сургалт, Transformer архитектур, дараах сургалт аргууд зэрэг гол түлхүүрүүд нь өнөөгийн хүчирхэг хиймэл оюун системүүдийн суурь болгосон.

Хиймэл оюун агентуудын онол нь орчин, үйлдэл, даалгавар гэсэн гурван гол бүрэлдэхүүн дээр суурилдаг. Агентууд нь төлөвлөлт, хэрэглүүрийн хэрэглээ, эргэцүүлэн бодох чадвартайгаар уламжлалт програмуудаас давуу талтай. RAG систем нь агентуудын мэдлэгийг өргөтгөж, илүү найдвартай, бодит мэдээлэл дээр суурилсан хариулт өгөх боломжийг олгодог.

\textbf{Практикийн хувьд:}

Микросервис архитектур дахь сервис хоорондын нарийн төвөгтэй логик, өгөгдлийн нэгтгэл, динамик routing зэрэг асуудлуудыг хиймэл оюун агентууд ашиглан шийдэж болох нь тодорхой болсон. Санал болгосон Orchestrator Agent, Service Agent, Knowledge Agent, Monitoring Agent зэрэг бүрэлдэхүүн хэсгүүд нь уян хатан, өргөжүүлэх боломжтой системийг бий болгодог.

Гэхдээ агентуудыг болит түвшинд өргөжүүлэхийн тулд зөвхөн агентын ур чадвар биш, тэдгээрийг холбодог архитектур чухал гэдгийг ойлгосон. Монолит болон gRPC/API суурилсан холболт нь монолит архитектурт тулгарсан асуудалтай адил саад болдог. Үүнийг шийдэхийн тулд үйл явдлаар EDA ашиглан агентуудыг салангид микросервис болгон хөгжүүлэх шаардлагатай.

Микросервис архитектурт хиймэл оюун агентууд нэвтрүүлэх нь системийг илүү ухаалаг, уян хатан, хэрэглэгчид ээлтэй болгох боломжийг олгоно. Хэдийгээр одоогоор хязгаарлалтууд(Жич:хоцрогдол, өртөг, найдвартай байдал) байгаа ч технологи хурдацтай хөгжиж байгаа тул ойрын ирээдүйд эдгээр асуудлууд шийдэгдэх болно гэж найдаж байна.

Энэхүү дипломын ажил нь хиймэл оюуны инженерчлэлийн үндсийг тавьж, микросервис архитектурт агент суурилсан шийдлийг практикт хэрхэн хэрэглэж болохыг харуулсан. 


% Техникийн хөгжүүлэлтийн хувьд Next.js React фронтенд, Node.js Express бэкенд, TypeScript, MySQL ашиглан SOLID зарчмыг дагасан архитектур бүтээсэн. Merchant Super App OAuth механизм, ҮЦТХТ SOAP API интеграци, 300,000+ мөртэй өгөгдлөөс binary search алгоритмаар хурдан хайлт хийх(5-40ms), үнэт цаасны real-time дата WebSocket ашиглан дамжуулах систем зэрэг олон чухал арга техникийг амжилттай хэрэгжүүлсэн.

% Фүллстек веб хөгжүүлэлт, API интеграци, real-time дата боловсруулалт, Docker containerization, DevOps практик зэрэг олон чиглэлийн техникийн чадваруудыг эзэмшсэн. Мөн багийн ажиллагаа, төслийн удирдлага, Git workflow, CI/CD pipeline зэрэг мэргэжлийн ур чадваруудыг хөгжүүлсэн.

% Энэхүү дадлагын үр дүнд санхүүгийн технологийн салбарт бодит ажлын туршлага олж авч, ирээдүйд илүү том, нарийн төвөгтэй системүүд хөгжүүлэх, санхүүгийн технологийн салбарт хувь нэмрээ оруулах чадварыг эзэмшсэн.

%----------------------------------------------------------------------------------------
%   Дипломын номзүй, хавсралтын хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------

\singlespace
\addcontentsline{toc}{part}{НОМ ЗҮЙ}
\begin{thebibliography}{99}
	% Үндсэн ном зохиол
	\bibitem{huyen2024}
	Huyen, Chip. \textit{AI Engineering}. O'Reilly Media, 2024.
	
	\bibitem{goldman2023}
	Goldman Sachs Research. "Generative AI Could Raise Global GDP by 7\%", 2023. 
	\url{https://www.goldmansachs.com/intelligence/pages/generative-ai-could-raise-global-gdp-by-7-percent.html}
	
	% Foundation Models
	\bibitem{vaswani2017}
	Vaswani, A., et al. "Attention Is All You Need". \textit{Advances in Neural Information Processing Systems}, 2017.
	
	
	% RAG
	\bibitem{gao2023}
	Gao, Y., et al. "Retrieval-Augmented Generation for Large Language Models: A Survey". \textit{arXiv preprint arXiv:2312.10997}, 2023.
	
	% AI Agents
	\bibitem{yao2023}
	Yao, S., et al. "ReAct: Synergizing Reasoning and Acting in Language Models". \textit{ICLR}, 2023.
	
	\bibitem{schick2023}
	Schick, T., et al. "Toolformer: Language Models Can Teach Themselves to Use Tools". \textit{arXiv preprint arXiv:2302.04761}, 2023.
	
	% Prompt Engineering
	\bibitem{openai2023}
	OpenAI. "Prompt Engineering Guide", 2023. \url{https://platform.openai.com/docs/guides/prompt-engineering}
	
	% Microservices
	\bibitem{newman2015}
	Newman, Sam. \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media, 2015.
	
	
	\bibitem{fowler2014}
	Fowler, Martin and Lewis, James. "Microservices: A Definition of This New Architectural Term", 2014. \url{https://martinfowler.com/articles/microservices.html}
	
	
	% API & Integration
	\bibitem{fielding2000}
	Fielding, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.
	
	% Python & Tools
	\bibitem{python}
	Python Software Foundation. "Python 3 Documentation". \url{https://docs.python.org/3/}
	
	\bibitem{fastapi}
	Ramírez, Sebastián. "FastAPI Documentation". \url{https://fastapi.tiangolo.com/}
	
	\bibitem{openai-api}
	OpenAI. "OpenAI API Reference". \url{https://platform.openai.com/docs/api-reference}
	
	\bibitem{anthropic2024}
	Anthropic. "Claude Model Card", 2024. \url{https://www.anthropic.com/claude}
	
	
	\bibitem{faiss}
	Facebook AI Research. "FAISS: A Library for Efficient Similarity Search". \url{https://github.com/facebookresearch/faiss}
	
	% Event-Driven Architecture & Streaming
	\bibitem{falconer2025agents}
	Falconer, Sean. "AI Agents are Microservices with Brains". Medium, March 2025. \url{https://medium.com/@seanfalconer}
	
	\bibitem{falconer2025future}
	Falconer, Sean. "The Future of AI Agents is Event-Driven". BigDataWire, March 2025.
	
	\bibitem{polak2025}
	Polak, Adi. "Building AI Agents with Event-Driven Microservices". Confluent Developer Advocate, 2025.
	
	\bibitem{kafka}
	Apache Kafka Documentation. "Apache Kafka: A Distributed Streaming Platform". \url{https://kafka.apache.org/documentation/}
	
	\bibitem{kreps2014}
	Kreps, Jay, Narkhede, Neha, and Rao, Jun. "Kafka: A Distributed Messaging System for Log Processing". \textit{Proceedings of the NetDB}, 2011.
	
	\bibitem{flink}
	Apache Flink Documentation. "Stateful Computations over Data Streams". \url{https://flink.apache.org/}

	\bibitem{camunda}
	Camunda Documentation. \url{https://camunda.com/}

	\bibitem{inngest}
	Inngest Documentation. \url{https://www.inngest.com/}
	\bibitem{bpmnEngine}
	BPMN Engine Documentation. \url{https://workflowengine.io/features/bpmn/}
	
	\bibitem{carbone2017}
	Carbone, Paris, et al. "State Management in Apache Flink: Consistent Stateful Distributed Processing". \textit{Proceedings of the VLDB Endowment}, 2017.
	
	% Microservices Evolution
	\bibitem{wolff2016}
	Wolff, Eberhard. \textit{Microservices: Flexible Software Architecture}. Addison-Wesley Professional, 2016.
	
	\bibitem{nadareishvili2016}
	Nadareishvili, Irakli, et al. \textit{Microservice Architecture: Aligning Principles, Practices, and Culture}. O'Reilly Media, 2016.
	
	% Anthropic MCP
	\bibitem{anthropic2024mcp}
	Anthropic. "Model Context Protocol: A Universal Standard for AI Integration", 2024. \url{https://www.anthropic.com/news/model-context-protocol}
	
\end{thebibliography}


%----------------------------------------------------------------------------------------
%   Хавсралтууд эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\appendix
\addcontentsline{toc}{part}{ХАВСРАЛТ}

% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
\chapter{Веб хуудсууд}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/homePage.png}
    \caption{Нэвтрэх хуудас}
    \label{fig:homePage}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/dashboardPage.png}
    \caption{Нүүр хуудас}
    \label{fig:dashboardPage}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/mailRegistration.jpg}
    \caption{Бүртгэлийн мэдэгдлийг э-мэйлээр авах}
    \label{fig:mailRegistration}
\end{figure}

Хэрэглэгч системд бүртгүүлэхэд хөрөнгө оруулах зорилго, эрсдлийн үнэлгээ, хөрөнгө оруулах зорилго зэрэг мэдээлэл оруулж байгаа ба бүртгэлийн дараа хиймэл оюун агентд уг мэдээллийг өгч, тохирсон э-мэйл агуулга гаргаж хэрэглэгч рүү илгээх

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/ra.png}
    \caption{Өдөр тутмын мэдээний э-мэйл авах}
    \label{fig:dailyEmail}
\end{figure}

Хэрэглэгч өөрийн сонирхсон хувьцааны мэдээллээ системд бүртгүүлж болох ба, хиймэл оюун ашиглаж бүх хэрэглэгчдэд өдөр тутмын сонирхсон мэдээг нь илгээж болно. FinnHub api ашиглана. Хэрвээ мэдээлэл олдохгүй бол ерөнхий мэдээ илгээнэ.  
\chapter{Кодын жишээ}

\section{Зохион байгуулагч агент: Intent Classification}

Хэрэглэгчийн асуултыг ангилж, зохих агент руу чиглүүлэх Gemini AI ашигласан intent classification:

\begin{lstlisting}[language=JavaScript, caption=Intent Classification (orchestrator-agent/src/intent-classifier.ts)]
async classify(query: string): Promise<string> {
  try {
    // Check cache
    const cached = this.cache.get(query.toLowerCase());
    if (cached) return cached;

    // Use Gemini AI for classification
    const prompt = INTENT_CLASSIFICATION_PROMPT
      .replace('{QUERY}', query);
    const response = await geminiClient
      .generateResponse(prompt, 0.3);
    
    // Extract and validate intent
    const intent = response.trim().toLowerCase();
    const validIntents = ['portfolio', 'market_analysis', 
      'news', 'risk_assessment', 'general_query'];
    const finalIntent = validIntents.includes(intent) 
      ? intent : 'general_query';
    
    // Cache result
    this.cache.set(query.toLowerCase(), finalIntent);
    
    return finalIntent;
  } catch (error) {
    // Fallback: keyword-based classification
    return this.fallbackClassify(query);
  }
}
\end{lstlisting}

\section{Мэдлэгийн агент: RAG хайлт}

Semantic search ашиглан холбогдолтой баримтуудыг олох RAG системийн хэрэгжүүлэлт:

\begin{lstlisting}[language=JavaScript, caption=RAG Search (knowledge-agent/src/index.ts)]
function search(query: string, topK = 5, filters?: any) {
  const queryLower = query.toLowerCase();
  const keywords = queryLower.split(/\s+/)
    .filter(word => word.length > 2);

  // Score each document
  const scored = knowledgeBase.map(doc => {
    let score = 0;
    const contentLower = doc.content.toLowerCase();
    const titleLower = doc.title.toLowerCase();
    
    // Keyword matching
    keywords.forEach(keyword => {
      if (titleLower.includes(keyword)) score += 3;
      if (contentLower.includes(keyword)) score += 1;
    });
    
    // Filter matching (symbol, content type)
    if (filters?.symbol && 
        doc.metadata?.symbol === filters.symbol) {
      score += 3;
    }
    
    return { ...doc, score };
  });

  // Sort by score and return top K
  return scored
    .filter(doc => doc.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, topK);
}
\end{lstlisting}

\section{Хөрөнгө оруулалтын агент: Event-Driven хариулт}

Kafka ашиглан агентуудын асинхрон харилцаа:

\begin{lstlisting}[language=JavaScript, caption=Event-Driven Response (investment-agent/src/index.ts)]
async function handleAgentTask(message: any) {
  const { taskId, agentType, action, payload } = message;
  const startTime = Date.now();
  
  // Check if task is for this agent
  if (agentType !== 'investment') return;
  
  // Generate AI response
  const result = await generateAIResponse(action, payload);
  
  // Send response via Kafka
  await producer.send({
    topic: 'agent.responses',
    messages: [{
      key: taskId,
      value: JSON.stringify({
        responseId: uuidv4(),
        requestId: taskId,
        agentType: 'investment',
        status: 'success',
        result: { text: result, action },
        metadata: {
          processingTimeMs: Date.now() - startTime,
          model: 'gemini-2.0-flash'
        },
        timestamp: new Date().toISOString()
      })
    }]
  });
  
  // Cache response in database
  await db.query(
    `INSERT INTO agent_responses_cache 
     (request_id, user_id, agent_type, query, 
      response, processing_time_ms)
     VALUES ($1, $2, $3, $4, $5, $6)`,
    [taskId, payload?.userId, 'investment', 
     action, result, Date.now() - startTime]
  );
}
\end{lstlisting}

\section{API Gateway: Server-Sent Events}

Бодит цагийн агентын хариултыг хэрэглэгч рүү дамжуулах SSE streaming:

\begin{lstlisting}[language=JavaScript, caption=SSE Streaming (api-gateway/src/routes/agent.routes.ts)]
router.get('/stream/:requestId', async (req, res) => {
  const { requestId } = req.params;

  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  // Send initial connection
  res.write(`data: ${JSON.stringify({
    type: 'connected', requestId
  })}\n\n`);

  // Create unique consumer for this connection
  const consumer = kafkaService
    .getConsumer(`sse-${requestId}`);
  
  await consumer.connect();
  await consumer.subscribe({ 
    topic: 'agent.responses', 
    fromBeginning: false 
  });

  // Stream messages to client
  await consumer.run({
    eachMessage: async ({ message }) => {
      const response = JSON.parse(
        message.value.toString()
      );
      
      // Only send responses for this requestId
      if (response.requestId === requestId) {
        res.write(`data: ${JSON.stringify({
          type: 'response',
          data: response
        })}\n\n`);
        
        // Close after sending response
        await consumer.disconnect();
        res.end();
      }
    }
  });
});
\end{lstlisting}



\end{document}
