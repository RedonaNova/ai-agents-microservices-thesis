%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[12pt,a4paper]{report}

\usepackage{fontspec,xltxtra,xunicode}
\setmainfont[Ligatures=TeX]{Times New Roman}
\setsansfont{Arial}

% \usepackage[utf8x]{inputenc}
% \usepackage[mongolian]{babel}
%\usepackage{natbib}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\setlength{\headheight}{29.03363pt}
%\usepackage{fancyheadings} fancyheadings is obsolete: replaced by fancyhdr. JL
\usepackage{fancyhdr}
% Set up page numbering style
\pagestyle{fancy}
\fancyhf{} % Clear all headers and footers
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{float}
\usepackage{afterpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsbsy}
\usepackage{dcolumn,array}
\usepackage{tocloft}
\usepackage{styles/dics}
% Ensure proper page numbering after dics.sty is loaded
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{nomencl}
\usepackage{upgreek}
\newcommand{\argmin}{\arg\!\min}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}

% Packages for better text wrapping and line breaking
\usepackage{microtype} % Improves text appearance and reduces overfull boxes
\usepackage{ragged2e} % Better text justification
\usepackage{hyphenat} % Better hyphenation control
\usepackage{url} % Better URL line breaking

% Emergency stretch to prevent overfull hboxes
\emergencystretch=1em

% Additional settings for better text handling
\tolerance=1000
\hyphenpenalty=50
\exhyphenpenalty=50

% Set line breaking parameters
\linespread{1.05} % Slightly increase line spacing
\clubpenalty=10000 % Prevent single lines at bottom of page
\widowpenalty=10000 % Prevent single lines at top of page

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{listings}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\makeatletter
\usepackage{caption}
\captionsetup[table]{belowskip=0.5pt}
\renewcommand{\tablename}{Хүснэгт}
\usepackage{longtable}
\usepackage{subfiles}

\usepackage{listings}
\renewcommand{\lstlistingname}{Код}
\renewcommand{\lstlistlistingname}{\lstlistingname ын жагсаалт}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.99,0.99,0.99}
\definecolor{lightgray}{rgb}{0.83,0.83,0.83}
\definecolor{darkgray}{rgb}{0.3,0.3,0.3}

% Define JavaScript language for listings
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, const, let, async, await, export, import, class, extends},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={boolean, number, string, any, void},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
 
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=false,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=true,
    showtabs=false,                  
    tabsize=2,
    % Additional settings for better line breaking
    breakindent=1.5em,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    frame=single,
    rulecolor=\color{lightgray},
    columns=flexible,
    % Ensure lines don't exceed margins
    xleftmargin=2em,
    xrightmargin=2em
}
 
\lstset{style=mystyle, label=DescriptiveLabel} 

\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\makenomenclature
\begin{document}


%----------------------------------------------------------------------------------------
%   Өөрийн мэдээллээ оруулах хэсэг
%----------------------------------------------------------------------------------------

% Дипломийн ажлын сэдэв
\title{Микросервис архитектурт суурилсан хиймэл оюун агентууд}
% Дипломын ажлын англи нэр
\titleEng{AI agents for microservices}
% Өөрийн овог нэрийг бүтнээр нь бичнэ
\author{Булганы Раднаабазар}
% Өөрийн овгийн эхний үсэг нэрээ бичнэ
\authorShort{Б.Раднаабазар}
% Удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\supervisor{Дэд профессор Б.Сувдаа}
% Хамтарсан удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\cosupervisor{}

% СиСи дугаар 
\sisiId{22B1NUM0286}
% Их сургуулийн нэр
\university{МОНГОЛ УЛСЫН ИХ СУРГУУЛЬ}
% Бүрэлдэхүүн сургуулийн нэр
\faculty{МЭДЭЭЛЛИЙН ТЕХНОЛОГИ, ЭЛЕКТРОНИКИЙН СУРГУУЛЬ}
% Тэнхимийн нэр
\department{МЭДЭЭЛЭЛ, КОМПЬЮТЕРЫН УХААНЫ ТЭНХИМ}
% Зэргийн нэр
\degreeName{Дипломын ажлын тайлан}
% Суралцаж буй хөтөлбөрийн нэр
\programeName{Мэдээллийн технологи (D061304)}
% Хэвлэгдсэн газар
\cityName{Улаанбаатар}
% Хэвлэгдсэн огноо
\gradyear{2025 оны 10 сар}


%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
\include{src/main-pre}

% Удиртгалыг оруулж ирэх ба abstract.tex файлд удиртгалаа бичнэ
\include{src/abstract}

% Нэр томьёоны тайлбар
\include{src/terminology}

%----------------------------------------------------------------------------------------
%   Дипломын үндсэн хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------



\textbf{Зорилго:}

Энэхүү судалгааны ажлын гол зорилго нь хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг онол, практикийн хувьд судалж, үйл явдлаар удирдагдах архитектур ашиглан уян хатан, өргөжих боломжтой систем бүтээх зохиомж санал болгох юм. Санал болгож буй зохиомжийн үр ашигтай байдлыг баталгаажуулахын тулд монгол, гадаад хөрөнгийн зах зээлийн өгөгдөлд суурилсан практик демо систем хөгжүүлж, туршиж үзнэ. Энэ нь хиймэл оюуны технологи болон орчин үеийн програм хангамжийн архитектурын уялдааг судалж, практикт хэрэглэх боломжийг харуулна.

\textbf{Зорилт:}

\begin{enumerate}
    \item Хиймэл оюуны инженерчлэлийн үндсэн онол, суурь моделийн хөгжил, зааврын инженерчлэл, RAG системийн онолыг тайлбарлах. Цаашлаад яагаад олон агент систем нь бизнесд зохимжтой вэ гэдгийг тайлбарлана.
    \item Хиймэл оюун агентуудын архитектур, бүрэлдэхүүн хэсгүүд, төлөвлөлтийн механизм, хэрэглүүрүүдийн ашиглалтыг судлах
    \item Микросервис архитектурын давуу болон сул талуудыг тодорхойлж, үйл явдлаар удирдагдах архитектурын давуу тал болон шаардлагыг тайлбарлах
    \item Хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэхэд тулгарах асуудлуудыг тодорхойлж, ижил төстэй системүүдтэй (Inngest, Temporal, Camunda) харьцуулан судлах
    \item Apache Kafka болон Apache Flink ашиглан үйл явдлаар удирдагдах агентын микросервис архитектурыг санал болгох
    \item Санал болгосон зохиомжийг туршилтаар хэрэгжүүлэх: Зохион байгуулагч агент, Мэдлэгийн агент, Хөрөнгө оруулалтын агент, мэдээний агент, PyFlink төлөвлөгч зэрэг системийн бүрэлдэхүүн хэсгүүдийг хөгжүүлэх
    \item МХБ-ийн бодит өгөгдөл (компанийн мэдээлэл, арилжааны түүх) ашиглан демо систем бүтээж, Next.js 14 фронтенд, API Gateway болон агентүүдийг холбох
    \item Системийг Docker орчинд deploy хийж, PostgreSQL, Kafka, Redis зэрэг программ хангамжуудыг тохируулах
    \item Бүрэн хэрэгжүүлсэн системийг тест хийж, өргөжих чадвар, найдвартай байдал, агентуудын хамтын ажиллагааг үнэлэх
\end{enumerate}

\chapter{Онолын хэсэг}

\section{Хиймэл оюуны инженерчлэл гэж юу вэ}

Хиймэл оюуны инженерчлэл гэдэг нь бэлэн бэлтгэгдсэн суурь модел дээр аппликейшн хөгжүүлэх үйл явцийг хэлнэ. Энэ нь уламжлалт машин сургалтын инженерчлэл ялгаатай байдаг. Хэрэв уламжлалт машин сургалтын инженерчлэл нь модел хөгжүүлэхэд чиглэсэн бол, хиймэл оюуны инженерчлэл нь бэлтгэгдсэн моделийг программ хангамжид интеграц хийхэд чиглэсэн байдаг. ~\cite{huyen2024}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/aiAndML.png}
    \caption{Хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэл}
    \label{fig:home}
\end{figure}

OpenAI, Anthropic зэрэг компаниудын гаргасан хүчирхэг суурь моделийн хүртээмж нь гурван гол хүчин зүйлээс шалтгаалан хиймэл оюуны инженерчлэлийг хурдан өсч буй салбар болгожээ. ~\cite{goldman2023} Эхнийх нь өндөр эрэлт юм. Компаниуд хиймэл оюуныг бусад бизнесээс ялгарах өрсөлдөөнт давуу тал болгон үзэж байна. FactSet-ийн судалгаагаар 2023 оны хоёрдугаар улиралд S\&P 500 компаниудын гуравны нэг нь өөрсдийн санхүүгийн тайланд хиймэл оюуныг дурдсан тоо нь өмнөх оноос гурав дахин их байна. Хоёр дахь нь технологийн хөгжилтэй холбоотой. Өмнө нь хиймэл оюун систем бүтээхэд өндөр мэргэжлийн ур чадвар, их хэмжээний өгөгдөл, тооцооллын нөөц шаардлагатай байсан бол одоо суурь модел ашиглан хэрэглээнд нэвтрүүлэх нь илүү боломжтой болов. Улмаас хиймэл оюуны инженерүүд программ хангамжийг хүртээмжтэй моделүүд ашигласнаар өндөр түвшний математикийн мэдлэг өндөр түвшинд байх шаардлагагүй болов. Гурав дахь нь том боломж юм. Хиймэл оюун технологи нь ажил хэргийг автоматжуулах, шинэ бүтээгдэхүүнүүдийг бий болгох зэрэг асар том боломжуудыг санал болгож байна. Энэхүү хандлагын нотолгоо болох хиймэл оюунт аппликейшний нээлттэй эхийн кодууд (AutoGPT, Stable Diffusion WebUI, LangChain, Ollama) нь GitHub дээр Bitcoin-оос ч илүү од цуглуулсан нь энэхүү салбарын хурдацтай өсөлтийг тод илэрхийлж байна. ~\cite{huyen2024}.

\section{Суурь моделийн хөгжил}

Хэл моделүүдээс том хэлний модел болон суурь модел руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Энэхүү хэсэгт гол түлхүүр үйл явдлыг тайлбарлах болно. ~\cite{huyen2024}

\subsection{Хэл моделийн үндэс}

Хэл модел гэдэг нь нэг буюу олон хэлүүдийг статистик өгөгдөл рүү кодлодог загвар юм. Энэхүү мэдээлэл нь өгөгдсөн контекстэд уг үг гарах магадлалыг илэрхийлдэг. Жишээлбэл, "Миний дуртай өнгө бол \_\_" гэсэн контекст өгөхөд монгол хэлээр кодолсон хэл модел нь "машин" биш, харин "цэнхэр" гэсэн үгийг таамаглах ёстой. ~\cite{huyen2024}

Анхны текстийг токен болгон хуваах үйл явцыг токенжуулалт гэнэ. GPT-4 суурь моделийн хувьд дунджаар нэг токен нь үгийн ойролцоогоор 75\%-ийн уртад тохирно. Тиймээс 100 токен нь ойролцоогоор 75 үг юм.

Хэл моделд хоёр үндсэн төрөл байдаг. Эхний төрөл нь далдлагдсан хэлний моделууд бөгөөд эдгээр нь өгүүлбэр доторх далдлагдсан үгсийг таамаглах замаар сурдаг. BERT нь энэ төрлийн алдартай жишээ юм. Хоёр дахь төрөл нь автoрегрессив хэл моделууд бөгөөд өмнөх токенуудад үндэслэн дараагийн токенийг таамаглах замаар сурдаг. Одоогийн ChatGPT, Claude зэрэг өргөн ашиглагдаж буй системүүд нь энэ ангилалд хамаарагддаг.

\subsection{Өөрийгөө удирдсан сургалт}

Хэл моделийн хамгийн чухал давуу тал нь өөрийгөө удирдсан сургалтыг ашиглах чадвар юм. Өөрийгөө удирдсан сургалт нь удирдлагатай сургалтаас ялгаатай байдаг. Удирдлагатай сургалт нь тэмдэглэгдсэн өгөгдөл шаарддаг бөгөөд энэ үйл явц нь цаг хугацаа их зарцуулдаг. ~\cite{huyen2024}

Энэ нь хэл моделийг номнуудаас, блог нийтлэлээс, өгүүллүүд, Reddit-ийн сэтгэгдэл зэргээс ашиглан сургаж болно. Энэ нь асар их сургалтын өгөгдөл бүрдүүлэх боломжийг олгож, хэл моделийг том хэлний модел буюу LLM болтол өргөжүүлэх боломжтой болгосон.

\subsection{Том хэлний моделоос суурь модел руу}

2017 онд Transformer архитектур гарч ирснээр хэл моделийн чадамж харьцангуй өндөр нэмэгдсэн. Attention механизм нь моделуудад өгөгдлийн хамаарлыг илүү сайн ойлгох боломжийг олгосон. ~\cite{huyen2024}

Том хэлний моделууд нь хэл моделийн томорсон хувилбар бөгөөд тэрбум тооны параметр агуулдаг. Параметр гэдэг нь сургалтын явцад моделийн сурч авдаг утга юм. Жишээлбэл, GPT-3 нь 175 тэрбум параметртэй, харин GPT-4 нь 1.2 их наяд параметртэй байдаг. 

Суурь моделууд нь LLM-ээс цааш өргөжсөн ойлголт юм. Эдгээр нь зөвхөн текст биш, зураг, аудио, видео зэрэг олон төрлийн өгөгдөл боловсруулж чаддаг том мульти модал моделууд юм. Суурь моделийн гол онцлог нь тодорхой үүрэгтэй моделээс цаашлаад ерөнхий зориулалтын модел руу шилжсэн юм.

\section{Хиймэл оюуны агент ба бизнесийн үйл ажиллагаа}

Энтерпрайзийн хувьд хиймэл оюун нь дахин давтагддаг нэхэмжлэл үүсгэх, харилцагчийн асуултад хариулах, өгөгдөл бүртгэх зэрэг үйл ажиллагааг автоматжуулах боломж гаргаж байдаг. Нэгэн сонирхолтой хиймэл оюуны нэвтрүүлэлтийн хэлбэр нь өгөгдлийг дахин сайжруулах арга зам юм. Энэ нь өөрийнхөө өгөгдөлд тэмдэглэгээ хийгээд, дараа нь энэ тэмдэглэгээний үр дүнгээс хамаарч жинхэнэ хүний тусламжтайгаар алдааг багасгахын тулд олон дахин уг тэмдэглэгээнүүдийг сайжруулах юм. Энтерпрайзуудад хамгийн алдартай хиймэл оюуны хэрэглээ нь харилцагчийн туслах бот юм. Бот нь хүнээс хурдан хариулснаар харилцагчийн туршлагыг сайжруулж, бас бизнесийн хувьд зардал хэмнэх боломжийг бүрдүүлдэг. ~\cite{huyen2024} ~\cite{goldman2023}

Хиймэл оюунд гадна орчинтой хандах хэрэглүүр өгөх нь маш олон боломжийг нээж өгдөг. Ресторанд цаг захиалахад сул цаг харах, захиалга өгөх зэрэг үйлдлийг хэрэглүүрүүд хийх боломжтой ба хиймэл оюунд уг хэрэглүүр өгснөөр харилцагчийн өмнөөс уг үйлдлийг автоматаар хийж болох юм. Уг үйлдлүүдийг зохион байгуулж, хэрэглүүр ашигладаг программ хангамжийг хиймэл оюун агентууд гэнэ.     

\section{Суурь моделийн сургалт}

Суурь моделийг бэлтгэх нь хоёр үндсэн үе шаттай:

\subsection{Урьдчилан сургалт}

Урьдчилан сургалт нь өөрийгөө удирдсан сургалт ашиглан их хэмжээний өгөгдөл дээр моделийг сургах үйл явц юм. Энэ үе шатанд модел нь хэл, ерөнхий мэдлэг, дүрэм, баримт бичгүүдээс суралцдаг. 2022 онд сургалтын дата олохын тулд нэгэн ашгийн бус байгууллага 2-3 тэрбум веб хуудсуудыг автоматаар авч сургасан байна. Гэвч худал хуурмаг мэдээлэл, хүнд сурталтай мэдээлэл их байдаг тул хьюристик филтер хийдэг. Жишээ нь реддит платформд 5-аас олон эерэг хариу үйлдэлтэй бол уг өгөгдлийг авах юм.  ~\cite{huyen2024}

Суурь модел нь олон төрөлтэй байна. Нэгт, тодорхой зорилготой агентууд нь домейнд л хамаарагдах өгөгдлийг ашиглаж тооцоолол хийдэг. Үүнд эм эмчилгээний жорыг гаргах, ДНХ, хавдрын, уурагны симуляц явах зэрэг үйлдлүүдтэй байна. Хоёрт, ерөнхий зориулалттай хиймэл оюуны модел байна. Сургагдсан өгөгдлийн талаас дээш хувийг технологи, бизнес, үйлдвэр, мэдээ, урлаг уран сайхны өгөгдлүүд эзлэх ба үлдсэн хувийг бусад бага бага хувьтай гэр, аялал зэрэг секторууд эзлэж байна.

Олон улсын хэлүүд суурь модел дээр өөр өөр ажиллах зарчимтай байна. Сургалтан дээр суурь моделийн ойролцоогоор тал хувийг англи хэл эзлэдэг бол орос, герман хэл 10 хувийг эзлэж байна. GPT-4 суурь моделийн хувьд ашиглах токений хэмжээ ба төөрөгдөл хамгийн бага байх ба, Бирм хэл англи хэлээс 70 дахин их токен ашиглаж, төөрөгдөл хамгийн өндөр байна. Шалтгаан нь уг хэлний соёлийн бүтэц юм. Жишээлбэл зарим хэлд эзэн бие ашигладаггүй учир хэл хөрвөхөд оновчтой байх магадлал бага юм. 

Иймээс суурь моделийн хэлний хязгаарлалтыг давахын тулд өөрсдийн хэл дээр суурь модел хөгжүүлж байна. Жишээлбэл, хятадын "Llama-Chinese", францийн "Croissant-LLM", Виетнамын "PhoGPT" гэх зэрэг. Монгол улсын хувьд "Чимэгэ систем" нь монгол хэл дээр суурь модел хөгжүүлж байгаа. 

Урьдчилан сургагдсан үе шатд хэрэглэгчдийн хүсэлтэд нийцсэн хариулт өгөхөд сайн биш байдаг. Учир нь харилцан яриа өрнүүлэх гэхээс илүүтэйгээр зөвхөн өгүүлбэрийн гүйцээлт рүү тулгуурлан сургагдсан байдаг. Иймээс дараах сургалт, sampling техникүүд, нарийвчилсан сургалтууд шаардалагатай байдаг.

\subsection{Дараах сургалт}

Урьдчилан сургасан моделийг хэрэглэгчдийн хүсэлтэд тохируулахын тулд дараах сургалт хийдэг. Энэ нь хоёр үе шаттай. Эхний үе шат нь удирдлагатай нарийвчилсан сургалт юм. Энэ үе шатанд өндөр чанартай зааварчилгааны өгөгдөл дээр моделийг нарийвчлан сургаж, зөвхөн өгүүлбэрийн гүйцээлт биш харин харилцан ярианы горимд оновчтой болгоно. Хоёр дахь үе шат нь сонголтын нарийвчилсан сургалт юм. Энэ үе шатанд моделийг хүний сонголттой нийцсэн хариулт өгөхийн тулд цаашид нарийвчлан сургана. Үүнд хүний санал хүсэлтээр бэхжүүлсэн сургалт, хиймэл оюуны санал хүсэлтээр бэхжүүлсэн сургалт зэрэг аргууд ордог. ~\cite{huyen2024}

\subsection{Sampling стратегиуд}

Модел нь гаралтаа sampling процессоор бүтээдэг. Sampling нь хиймэл оюуны гаралтын магадлалыг шууд нөлөөлдөг. ~\cite{huyen2024} Температур нь моделийн бүтээлч чанарыг удирдах гол параметр юм. Температур өндөр байх тусам модел илүү бүтээлч, гэнэтийн хариулт өгдөг бол температур бага байх тусам илүү таамагладаг, баттай хариулт өгдөг. Top-k нь хамгийн их магадлалтай k ширхэг токеноос сонгодог арга юм. Үүнийг өөрчилснөөр хариултын олон янзтай байх байдлыг удирдаж болно. Энэхүү арга нь уран зохиолд ялангуяа чухал. Түүнчлэн nucleus sampling буюу Top-p арга байдаг. Энэ нь нийлбэр магадлал нь p-д хүрэх хамгийн бага токенуудын багцаас сонгодог. Энэ нь тийм, үгүй, урт хариулт, богино хариултын моделыг тодорхойлж болдог. Иймээс хэрэглээнээс хамаарч samping стратеги сонгох нь чухал. Жишээлбэл тийм, үгүй сонголттой асуулт хариулт гаргах, урт тэмдэгт мөртэй хариулт гаргах гэх мэт байж болно. 

\subsection{Моделийн үр дүнг хэмжих}

Суурь моделийг үнэлэх нь эрсдэлийг бууруулах, цаашлаад боломжуудыг илрүүлэх тал дээр чухал ач холбогдолтой. Үнэлгээ нь модел сонгох, үр дүнг хэмжих, аппликейшн ашиглалтад бэлэн эсэхийг тодорхойлох, асуудал болон боломжуудыг илрүүлэх зэрэгт шаардлагатай. ~\cite{huyen2024}

Сүүлийн жилүүдэд бага параметртэй модел нь өмнөх үеийн их параметртэй моделээс илүү чадалтай байна. Жишээлбэл, 2024 оны Llama 3-8B модел нь 2023 оны Llama 2-70B моделээс ч илүү сайн үр дүнг MMLU benchmark дээр харуулжээ. Энэ нь зөвхөн моделийн хэмжээ биш, сургалтын аргууд болон өгөгдлийн чанар хамгийн чухал болохыг харуулж байна.

Үнэлгээний хувьд гурван гол асуудал тулгардаг. Нэг дүгээрт, суурь моделуудыг зөвхөн гаралтуудын өгөгдлөөс дүгнэж үнэлэхэд хэцүү байдаг. Үүнийг хар хайрцаг гэх ба дотоод ажиллаж байгаа үйл явц биш зөвхөн эцсийн гаралт нь л мэдэгдэж байдаг. Хоёр дугаарт, модел нь ижил эсвэл бага зэрэг өөр асуулт асуухад маш өөр хариулт өгч болох тогтворгүй байдал байдаг. Үүнээс хиймэл оюуны суурь моделын хариулт нь магадлалаас үүсдгийг ажиглаж болно. Гуравдугаарт, модел нь баримт дээр үндэслээгүй буруу хариулт буюу төөрөгдөл үүсгэж болдог.

\section{Зааврын инженерчлэл}

Зааврын инженерчлэл гэдэг нь моделоос хүссэн үр дүнг гаргуулахын тулд зааврыг бичих үйл явц юм. Энэ нь моделийн жинг өөрчлөхгүйгээр зан үйлийг удирдах хамгийн хялбар бөгөөд түгээмэл моделийн дасан зохицох арга юм.

\subsection{Зааврын бичих шилдэг арга барил}

Заавруудыг хэрэглээнд тохирсон стратегиудын дагуу бичих нь илүү сайн үр дүн өгдөг. ~\cite{openai2023} OpenAI-ийн санал болгож буй заавар бичих шилдэг арга барил нь эхлээд юу хийлгэхээ хоёрдмол утгагүй байдлаар тодорхой тайлбарлах хэрэгтэй. Дараа нь моделоор тодорхой дүрд тоглуулж болно. Жишээ нь "Та том компанид 20 жил ажилласан туршлагатай программист. Кодыг шалгаад сайжруулж өг" гэх мэт. Anthropic-ийн зөвлөмжөөр зааварт 500 хуудас бүхий номын урттай тэмдэгт мөр багтаж чадах тул зааварт урт жишээ өгснөөр хариултын формат болон хариултын хоёрдмол утгыг багасгадаг. Цар хүрээ, агуулгыг мэдээлүүлснээр төөрөгдлийг багасгадаг. Хэрэв модел шаардлагатай мэдээллээр хангагдаагүй бол өөрийн дотоод мэдлэгтээ найдах бөгөөд энэ нь найдваргүй байж болдог. Түүнчлэн нарийн төвөгтэй даалгавруудыг хялбар дэд даалгавруудад хувааж өгөх нь үр дүнтэйгээр бага токен ашиглах боломжийг олгоно.



\subsection{Зааврын инженерчлэлийн хамгаалалт}

Аппликейшн олон нийтэд ашиглагдах үе шатанд ормогц довтолгооноос хамгаалах шаардлагатай болдог. Тэдгээрийн нэг нь моделийн зөвшөөрөөгүй үйлдэл хийлгэх оролдлого юм. Нөгөө нь моделийн сургалтын өгөгдөл эсвэл контекстын мэдээллийг задруулах оролдлого юм. ~\cite{huyen2024}

Иймээс хиймэл оюуны агент эсвэл модел угсарч буй тохиолдолд оролт болон гаралтыг үнэлэж хамгаалах функц нэвтрүүлэх нь мэдээллийн аюулгүй байдлыг хангадаг. 

\section{Хайлтаар нэмэгдүүлсэн үүсгэлт (RAG)}

RAG буюу хайлтаар нэмэгдүүлсэн үүсгэлт нь моделийн мэдлэгийг гадаад эх сурвалжаар өргөтгөх арга юм. Энэ нь моделийн дотоод мэдлэг нь хангалтгүй, хуучирсан эсвэл алдаатай байх асуудлыг шийддэг. ~\cite{huyen2024}

Хэдийгээр моделийн контекстийн урт тогтмол нэмэгдэж байгаа ч RAG-ийн ач холбогдол алдагдахгүй байна. Зарим аппликейшнд өгөгдлийн хэмжээ байнга өсч байдаг. Иймээс RAG удааширж магадгүй тул үүнийг сайтар үнэлж, тасралтгүй хөгжүүлэлт хийснээр бодит хэрэглээнд үр нөлөө алдахгүй байх боломжийг бүрдүүлнэ. Урт контекстыг боловсруулж чаддаг гэдэг нь тэр контекстыг сайн ашигладаг гэсэн үг биш. Контекст урт байх тусам модел буруу хэсэгт анхаарал хандуулах магадлал өсдөг. Түүнчлэн контекстын токен бүр нэмэлт өртөг, нэмэлт хоцрогдол авчирдаг. RAG нь асуулт бүрт зөвхөн хамгийн холбогдолтой мэдээллийг ашиглах боломжийг олгоно.

Anthropic-ийн зөвлөмжөөр хэрэв мэдээлэл нь 200,000 токеноос бага (ойролцоогоор 500 хуудас бүхий өгөгдөл) бол RAG ашиглалгүй бүх мэдлэгийг промпт зааварт оруулж болно гэжээ.

\subsection{RAG системийн бүтэц}

RAG систем нь хоёр гол бүрэлдэхүүнтэй. Хайгч нь асуултад хамгийн холбогдолтой баримтуудыг олж авдаг. Үүсгэгч нь олж авсан баримтуудыг асуултад ашиглан хариулт үүсгэдэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/RAG.png}
    \caption{RAG-ийн бүтэц}
    \label{fig:rag}
\end{figure}


\subsection{Хайлтын алгоритмууд}

Хайлтаар олдсон өгөгдөл нь хэр оновчтой байх нь RAG-ийн хамгийн чухал хэсгүүдийн нэг. ~\cite{huyen2024} Өгөгдлийг вектор эсвэл өгөгдлийн бааз руу оруулах хялбар ч үүнээс хайлт хийх нь харьцангуй хүнд байдаг. Хамгийн түгээмэл алдаа нь векторд хэсэгчилж хуваагдахад өгүүлбэрүүд утга зүй бусаар хуваагдаж, хайлт хийх боломжгүй болдог. Иймээс хайлтын алгоритмээ зөв сонгох нь маш чухал.   

\subsubsection{Нэр томьёо суурилсан хайлт}


Энэ арга нь түлхүүр үгээр баримт хайдаг. Энэ арга Google, Bing зэрэг хөтчийн хайлтын алгоритмд ашиглагдсаар ирсэн. Нэр томьёоны давтамж нь баримт доор нэр томьёо хэдэн удаа гарч байгааг хэмждэг бол баримтын урвуу давтамж нь нэр томьёо хэдэн баримтад гарч байгааг үндэслэн түүний чухлыг хэмждэг. Түгээмэл шийдлүүд нь Elasticsearch, BM25 зэрэг байдаг. Эдгээр нь урвуу индекс ашигладаг.

\subsubsection{Утга зүй дээр суурилсан хайлт}

Утга зүйн хайлт гэж нэрлэгддэг энэ арга нь утга зүйн түвшинд холбоотой байдлаар тооцож ажилладаг. Баримт бүр хуваагдаж векторчилсон хэсгийн төлөөлөл болгон хувиргагдаж, векторын өгөгдлийн санд хадгалагдана. Асуулт ирэх үед түүний векторчилсон төлөөлөлтэй хамгийн ойр векторуудыг хайдаг.

Векторын хайлтын алгоритмууд нь олон янз байдаг. Хамгийн ойр хөршүүд нь энгийн арга боловч өгөгдөл их бол удаан байдаг. Ойролцоо хамгийн ойр хөршүүд нь хурдан боловч ойролцоогоор хайдаг. Иймээс өгөгдлийн ангилал, форматаас шалтгаалж өөр өөр хайлтын алгоритм ашигладаг. Locality-Sensitive Hashing нь ижил төстэй векторуудыг нэг bucket-д hash хийдэг. Hierarchical Navigable Small World нь олон давхаргат граф ашигладаг. Inverted File Index нь K-means clustering ашиглан векторуудыг бүлэглэдэг. Алдартай векторын өгөгдлийн сангууд нь FAISS, Milvus, Pinecone, Weaviate, Qdrant зэрэг байна.

\subsection{RAG-ын үнэлгээ}

RAG системийг үнэлэхэд олон метрикүүд ашигладаг. ~\cite{huyen2024}. Context Precision нь олж авсан баримтуудын хэдэн хувь нь асуулттай холбоотой эсэхийг хэмжинэ. Context Recall нь асуулттай холбоотой бүх баримтуудын хэдэн хувийг олж авсан эсэхийг илэрхийлнэ. Эцсийн хариултын чанар нь хариултын ерөнхий чанарыг үнэлдэг.

\subsection{RAG-ыг сайжруулах аргууд}

RAG системийг сайжруулах олон арга байдаг. Баримтуудыг хэрхэн хэсэглэх нь чухал. Тогтмол урттай хэсэглэх, өгүүлбэр догол мөрөөр хэсэглэх, утга зүйгээр хэсэглэх зэрэг аргууд байдаг. Анхны хайлтын үр дүнг дахин эрэмбэлэн илүү нарийвчлалтай болгох арга байдаг. Асуултыг дахин найруулж илүү сайн хайлт хийх нь бас үр дүнтэй. Нэр томьёо болон векторчилсон хэсгийн төлөөлөл суурилсан хайлтыг хослуулсан арга ашиглаж болно. Хэсэг бүрийг metadata, түлхүүр үг, холбогдох асуултуудаар баяжуулах нь хайлтын чанарыг сайжруулдаг.


\section{Хиймэл оюуны агентууд}

\subsection{Агент}

Агент гэдэг нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. ~\cite{huyen2024}. Хиймэл оюунаар дэмжигдсэн агентууд нь суурь моделийн хүч чадлаар дамжуулан бидний туслах, хамтран ажиллагч, багш байж чадна. Агент нь вебсайт бүтээх, өгөгдөл цуглуулах, аялал төлөвлөх, зах зээлийн судалгаа хийх, харилцагчийн данс удирдах, өгөгдөл оруулалтыг автоматжуулах зэрэг олон ажил хэрэгт тусалж чадна.

\subsection{Агентын бүрэлдэхүүн хэсгүүд}

Хиймэл оюун агентыг тодорхойлдог гурван гол зүйл байдаг. ~\cite{huyen2024}. Орчин нь агент ажиллах орчин бөгөөд түүний хэрэглээний тохиолдлоор тодорхойлогдоно. Жишээ нь интернэт, гал тогоо, хөдөлгүүрт хэрэгсэл зэрэг байж болно. Агентын хийж чадах үйлдлүүд нь түүний хандах боломжтой хэрэглүүрүүдээр өргөжинө. Даалгавар нь хэрэглэгчээс өгөгдсөн ажил юм.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/agentPre.png}
    \caption{Агентын бүрэлдэхүүн хэсгүүд}
    \label{fig:agentComponents}
\end{figure}

\subsection{Хэрэглүүрүүд}

Гадаад хэрэглүүр байхгүй бол агентын чадавхи маш хязгаарлагдмал байх болно. Хэрэглүүр нь агентыг илүү чадварлаг болгодог. Цаашлаад уян хатан шийдвэр гаргалт, найдвартай гүйцэтгэлийн хоорондох хоосон зайг нөхдөг. Хэрэглүүрийг гурван ангилалд хуваах боломжтой.

Мэдлэг нэмэгдүүлэх хэрэглүүрүүд нь хайлтаар нэмэгдүүлсэн үүсгэлт систем буюу RAG-ын бүрэлдэхүүн хэсгүүд юм. Үүнд текст хайгч, зураг хайгч, SQL гүйцэтгэгч, интернэт хайлтын програмчлалын интерфэйс, дотоод хайлтын системүүд зэрэг багтана.

Чадавх өргөтгөх хэрэглүүрүүд нь агентын үндсэн чадварыг өргөжүүлдэг. Хиймэл оюун моделууд математикт сул байдаг тул агентд бэлэн тооны машины програмчлалын интерфэйс өгснөөр тооцоог оновчтой, хурдан, токены бага зарцуулалтаар гүйцэтгэдэг. Хэрэглэгчийн код уншигч нь код бичиж, ажиллуулах, үр дүн гаргах чадвартай. Энэ нь кодчилолын туслах, өгөгдөл шинжлэгч, судалгааны туслах боломжийг олгоно.

Бичих үйлдлийн хэрэглүүрүүд нь зөвхөн унших биш, өөрчлөлт оруулах хэрэглүүрүүд юм. Үүнд өгөгдлийн санд өгөгдөл нэмэх, засварлах, устгах, мэйл илгээх, банкны шилжүүлэг хийх, календарт тэмдэглэл нэмэх зэрэг үйлдлүүд багтана. Бичих үйлдэл нь өндөр эрсдэлтэй байдаг. Иймээс хортой зааврын довтолгооноос болгоомжлох хэрэгтэй.

\subsection{Төлөвлөлт}

Төлөвлөлт нь агентын гол үүрэг бөгөөд олон үе шаттай. Эхний үе шат нь төлөвлөгөө үүсгэх явдал юм. Даалгаврыг гүйцэтгэх дараалсан үйлдлүүдийн төлөвлөгөө гаргах энэ үйл явцыг даалгаврыг дэд процесс гэж нэрлэнэ. Хоёр дахь үе шат нь эргэцүүлэн бодох ба алдаа засах юм. Үүсгэсэн төлөвлөгөөг үнэлэх бөгөөд муу байвал шинэ төлөвлөгөө гаргана. Гурав дахь үе шат нь гүйцэтгэл юм. Төлөвлөгөөнд заасан үйлдлүүдийг хийх бөгөөд энэ нь ихэвчлэн функц дуудах үйлдэл хийнэ. Эцсийн үе шат нь үр дүнг үнэлэх явдал юм. Үйлдлийн үр дүнг хүлээн авсны дараа зорилго биелсэн эсэхийг тодорхойлж, алдааг тодорхойлж засна.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/agentPost.png}
    \caption{Агентын төлөвлөлт}
    \label{fig:agentPlanning}
\end{figure}

\subsection{Суурь моделууд төлөвлөгч болж чадах уу}

Зарим судлаачид том хэлний модел нь төлөвлөгч болж чадахгүй гэж үздэг. ~\cite{falconer2025agents}. Учир нь төлөвлөлт нь үндсэндээ хайлтын асуудал бөгөөд авторегрессив буюу магадлалт суурилсан модел нь зөвхөн нэг чиглэлийн үйлдэл үүсгэж чаддаг гэж үздэг. Гэвч бодит байдал дээр модел дахин эхлэж өөр зам сонгож чаддаг тул сургалт сайн хийснээр сайн төлөвлөгөө гарч болно.

Төлөвлөлтийг сайжруулах олон арга байдаг. Илүү сайн системийн заавар бичиж, жишээ олноор өгөх нь чухал. Хэрэглүүрүүдын тайлбарыг илүү сайн бичих хэрэгтэй. Функцүүдийг хялбарчлах, задлах нь төлөвлөлтийг хөнгөвчилдөг. Илүү хүчтэй модел ашиглах нь илүү сайн төлөвлөгөө гаргах боломжийг олгоно. Төлөвлөлтөд зориулж моделийг нарийвчлан сургах нь бас үр дүнтэй. Зарим үнэлгээний шинжилгээгээр оновчтой хэрэглүүр өгөх нь нарийвчилсан сургалт хийснээс илүү үр дүнтэй бас хямд гэж үзжээ.

\subsection{Эргэцүүлэн бодох ба алдаа засах}

Хамгийн сайн төлөвлөгөө байнга үнэлэгдэж, тохируулагдах шаардлагатай. Эргэцүүлэн бодох нь агентын амжилтад чухал үүрэг гүйцэтгэнэ. Үүнийг хоёр аргаар хийж болно. Эхний арга нь өөрийгөө шүүмжлэх арга юм. Ижил модел өөртэйгөө ярилцаж алдааг илрүүлдэг. Хоёр дахь арга нь тусдаа үнэлэгч ашиглах явдал юм. Тусдаа модел эсвэл функц үр дүнд оноо өгдөг.

\subsection{Агентын санах ой}

Хиймэл оюун модел нь гурван санах ойн механизмтай. ~\cite{huyen2024}. Дотоод мэдлэг нь модел өөрөө дотоод мэдээлэлтэй байдаг. Энэ нь сургалтын өгөгдлөөс олж авсан мэдлэг бөгөөд моделийг шинэчлэхгүй бол өөрчлөгдөхгүй. Богино хугацааны санах ой нь моделийн контекст юм. Өмнөх мессежүүд контекстэд нэмэгдэж болно. Даалгавар дууссаны дараа устдаг. Хурдан боловч устдаг шинжээр хязгаарлагдмал. Урт хугацааны санах ой нь гадаад өгөгдлийн эх сурвалж буюу хайлтаар нэмэгдүүлсэн үүсгэлт (RAG) юм.

\subsubsection{Эргэцүүлэн бодох}

Эргэцүүлэн бодох нь агентуудад өөрсдийн шийдвэрийг үнэлж, үйлдэл хийх эсвэл эцсийн хариулт өгөхөөсөө өмнө гаралтаа сайжруулах боломжийг олгодог. Энэ чадвар нь агентуудад алдаагаа олж засах, дүгнэлтээ боловсронгуй болгох, илүү өндөр чанартай үр дүн гаргах боломжийг олгоно.

Жишээлбэл, код бичиж байгаа агент нь эхлээд код үүсгээд, дараа нь өөрөө тухайн кодыг шалгаж, алдаа олж, сайжруулалт хийснийхээ дараа хэрэглэгчид хүргэнэ. Энэ нь эцсийн үр дүнгийн чанарыг мэдэгдэхүйц сайжруулдаг.


\subsubsection{Төлөвлөлт}

Төлөвлөлтийн чадвартай агентууд нь өндөр түвшний зорилгуудыг үйлдэл хийх боломжтой алхмуудад задалж, даалгавруудыг логик дарааллаар зохион байгуулж чаддаг. Энэ зохиомж нь олон алхам бүхий асуудлыг шийдэх эсвэл хамааралтай ажлын урсгалыг удирдахад чухал юм.

Жишээлбэл, аялал төлөвлөх агент нь эхлээд нислэг хайж, дараа нь зочид буудал захиалж, үзвэр сервисийн цэгүүдийг судалж, эцэст нь өдөр бүрийн маршрут үүсгэх төлөвлөгөө гаргаж болно.

\subsection{Яагаад олон агентын зохиомжийн хэрэгтэй вэ?}

Агент нь тодорхой даалгаврын хүрээнд ажил гүйцэтгэх чадвартай байдаг. Жинхэнэ бизнесд үйл ажиллагаа нь олон дэд процессд хуваагдаж болдог шиг агентийн хэрэглээ мөн адил нарийн ажиллагаатай байж болдог. Тиймээс олон агентийн зохиомж нь агентуудад нарийн төвөгтэй асуудлыг шийдэх, хувьсах орчинд дасан зохицох, үр дүнтэй хамтран ажиллах боломжийг олгодог.
Жишээлбэл өөрсдийн сургасан моделийг тооцоолоход үнэтэй дэд процессд үлдээгээд, хямдхан GPT-2 зэрэг моделээр өөр үүрэгтэй үйлдлүүдэд үлдээж болно. Иймээс мульти-агент байх нь практикт тохиромжтой түгээмэл арга зам юм.


\subsubsection{Олон агентын хамтын ажиллагаа}

Олон агентын системүүд нь асуудлыг шийдэхэд модуляр арга барил ашигладаг. Иймээс тодорхой даалгавруудыг мэргэшсэн агентуудад хуваарилдаг. Энэ арга нь уян хатан байдлыг санал болгохоос гадна зардлыг хэмнэнэ. Мөн үр ашигтай байдлыг сайжруулахын тулд даалгаварт агентуудад жижиг хэлний моделууд ашиглаж болно. Жишээлбэл хэрэглэгчийн хүсэлтийг танихад.

Модульчлагдсан зохиомж нь агентуудын цар хүрээ дотор тусгай даалгаврууддаа чиглүүлэх замаар агент тус бүрийн нарийн төвөгтэй байдлыг багасгадаг. Хамтран ажиллахын тулд мэргэшсэн агентууд мэдээлэл солилцож, хариуцлагыг хуваарилж, нарийн төвөгтэй сорилтуудыг илүү үр дүнтэй шийдэхийн тулд үйлдлүүдээ зохицуулдаг.

Уламжлалт системийн зохиомжтай адилаар, асуудлыг модульчлагдсан бүрэлдэхүүн хэсгүүдэд задлах нь тэднийг засварлах, өргөжүүлэх, дасан зохицуулахад илүү хялбар болгодог.

\section{Жишээ хиймэл оюунт программ хангамжийн зохиомж}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/charAIAgent.png}
    \caption{Хиймэл оюунт аппликейшн}
    \label{fig:charAIAgent}
\end{figure}

Суурь моделууд ашиглан аппликейшн хөгжүүлэх нь уламжлалт машин сургалтын инженерчлэлээс гурван талаараа ялгаатай байдаг. Эхнийх нь моделийн дасан зохицуулалт юм. Өөрөө модел сургахын оронд бусдын сургасан моделийг ашиглаж болдог. Иймээс уг моделийг дасан зохицуулах нь чухал болсон. Хоёр дахь нь оновчлол юм. Суурь модел нь илүү их тооцоолол шаарддаг, хоцрогдол өндөр байдаг учраас үр ашигтай дасан зохицуулалт хийснээр бага хүчтэй компьютерээр, бага хоцрогдлоор гүйцэтгүүлж болно. Иймээс бэлэн суурь моделийн програмчлалын интерфэйс ашиглах уу, эсвэл өөрөө агентээ серверт байршуулах уу гэдгийг шийдэж болно. Гурав дахь нь нээлттэй гаралт юм. Моделууд нээлттэй төгсгөлтэй гаралт үүсгэдэг тул үнэлгээ хийхэд илүү бэрхшээлтэй байдаг. Дундах процессийг мэдэж болдоггүй.

Моделийг дасан зохицуулах хоёр гол арга байдаг. Заавар суурилсан техникүүд нь моделийн жин өөрчлөхгүйгээр зааварчилгаа, контекст өгч дасан зохицуулдаг. Хялбар, цөөн өгөгдөл шаарддаг. Зааврын инженерчлэл энд хамаарна. Нарийвчилсан сургалт нь моделийн жинг өөрчилж дасан зохицуулдаг. Илүү нарийн төвөгтэй, илүү их өгөгдөл шаарддаг. Гэвч чанар, хоцрогдол, өртгийг мэдэгдэхүйц сайжруулж чадна. Хэрэглүүр өгөх нь уг даалгаврыг маш оновчтой, хоцрогдол багатайгаар, зардлын өртгийг мэдэгдэхүйц сайжруулж чадна.




\section{Бүлгийн дүгнэлт}

Хиймэл оюуны инженерчлэл нь уламжлалт машин сургалтын инженерчлэлээс өөр чиглэл бөгөөд бэлтгэгдсэн суурь модел дээр програм хангамж хөгжүүлэхэд чиглэсэн шинэ салбар юм. ~\cite{huyen2024}. OpenAI, Anthropic зэрэг компаниудын хүчирхэг суурь моделийн нэвтрүүлэлт нь хиймэл оюуныг програм хангамжид интеграц хийхийг илүү боломжтой болгож, салбарын хурдацтай өсөлтийг бий болгосон.

Суурь моделийн хөгжлийн замнал нь энгийн хэл моделөөс том хэлний модел, улмаар суурь модел руу шилжих үйл явц байсан. ~\cite{huyen2024}. Өөрийгөө удирдсан сургалт нь асар их хэмжээний өгөгдлөөр модел сургах боломжийг нээсэн. 2017 оны Transformer архитектур нь хэл моделийн чадамжийг шинэ түвшинд ахиулсан. Урьдчилан сургалт болон дараах сургалтын хослол нь моделд ерөнхий мэдлэгийг өгөөд, хэрэглэгчийн хүсэлтэд тохируулах боломжийг бүрдүүлсэн. Мөн Sampling стратеги, температур, top-k, top-p зэрэг параметрүүд нь моделийн гаралтын чанар, олон янз байдлыг магадлал дээр удирддаг.

Зааврын инженерчлэл нь модел дасан зохицуулах хамгийн хялбар арга. Зааврыг тодорхой, нарийвчлалтай бичих, модельд дүр олгох, урт жишээ өгөх, контекст хангах зэрэг техникүүд нь моделийн ажиллагааг мэдэгдэхүйц сайжруулдаг. Иймээс машин сургалт хийхгүйгээр программ хангамжид хиймэл оюун интеграц хийж болно. Гэвч хортой зааврын довтолгоо, мэдээллийг задруулах оролдлогоос хамгаалах нь чухал асуудал бөгөөд оролт болон гаралтыг үнэлэх функц нэвтрүүлэх шаардлагатай.

Хайлтаар нэмэгдүүлсэн үүсгэлт буюу RAG нь моделийн дотоод мэдлэгийн хязгаарлалтыг даван, гадаад эх сурвалжаас мэдээлэл авч хариултын найдвартай байдлыг нэмэгдүүлдэг. Хэдийгээр моделийн контекстын урт нь хайлтад урвуугаар нөлөөлдөг ч RAG-ийн ач холбогдол алдагдахгүй байна. Урт контекст нь үргэлж үр ашигтай ашиглагдахгүй бөгөөд нэмэлт өртөг, хоцрогдол авчирдаг. RAG систем нь хайгч болон үүсгэгч гэсэн хоёр гол бүрэлдэхүүнтэй. Хайлтын чанар нь системийн амжилтын түлхүүр болох тул нэр томьёо суурилсан хайлт, embedding суурилсан хайлт, эсвэл хоёулаа нэгтгэсэн аргыг ашиглан оновчтой байх хэрэгтэй.

Хиймэл оюун агент нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. Агентын гурван гол бүрэлдэхүүн нь орчин, үйлдэл, даалгавар болох нь тодорхой болсон. Хэрэглүүрүүд нь агентын чадавхийг өргөтгөх чухал элемент бөгөөд мэдлэг нэмэгдүүлэх, чадавх өргөтгөх, бичих үйлдлийн гэсэн гурван төрөлд хуваагдана. Төлөвлөлт нь агентын гол үүрэг болох нь илэрхий. Төлөвлөгөө үүсгэх, эргэцүүлэн бодох, гүйцэтгэх, үр дүнг үнэлэх дөрвөн үе шат нь агентыг уян хатан, найдвартай болгодог.

Олон агентын зохиомж нь нарийн төвөгтэй бизнес процессуудыг шийдэхэд илүү тохиромжтой байдаг. Агент бүр цар хүрээндээ мэргэшсэн даалгавартай байх нь системийг модульчлагдсан, өргөжүүлэх боломжтой болгодог. Агентуудын хамтын ажиллагаа, мэдээлэл солилцох чадвар нь ганц агентаас илүү хүчирхэг шийдлийг бий болгоно.

Эцэст нь хиймэл оюуны инженерчлэл нь зөвхөн машин сургалтын технологийн асуудал биш, харин цогц системийн архитектур, систем зохион байгуулалт, хэрэглэгчийн туршлагыг хослуулсан цогц салбар юм. Суурь модел, зааврын инженерчлэл, RAG систем, агентын архитектур зэрэг онолууд нь дараагийн бүлгүүдэд гарах болно.

\chapter{Микросервис архитектур}

\section{Монолитоос микросервис рүү}

\subsection{Монолитын эрин үе}

Вэб аппликейшн хөгжүүлэлтийн эхэн үед бүх зүйлийг монолит хэлбэрээр бүтээдэг байсан. Бүх бизнес логик, өгөгдлийн логикууд нэг том, нэгдсэн кодын санд амьдардаг байв. Программ хангамжийн өөгжүүлэгчид монолитуудыг хөгжүүлэхэд, нэвтрүүлэлт хийхэд энгийн, хялбар байв. ~\cite{wolff2016}

\subsection{Монолитыг өргөжүүлэх сорилт}

Гэвч аппликейшнууд томрох тусам асуудлууд нэмэгдсээр ирсэн. Монолитыг өргөжүүлэх нь бүх зүйлийг нэгтгэсэн байдлаар өргөжүүлдэг. Нэг модульд хийсэн жижиг өөрчлөлт энэхүү кодын санд орсноор энэ нь шинэчлэлтийг удаашруулж, унахад эрсдэлтэй болгодог. Өөр өөр функц дээр ажиллаж байгаа багууд байнга бие биенийхээ кодод хамаарал бүхий харилцаагаар холбогдож, алдаа нэмж, хөгжлийг удаашруулж, алдаа гарах эрсдэлийг нэмэгдүүлсээр ирсэн.

Монолит архитектураас эхэлсэн компаниуд эцэст нь эдгээр асуудлууд тулгарсан. Хурдан үйл ажиллагаагаа явуулахад багууд  системийг шинэчлэх, турших хүртэл хүлээх шаардлагатай байв. Энэ нь компаний бизнесийн үйл ажиллагаанд үндсэн саад бэрхшээл болов.

\subsection{Микросервис рүү шилжих}

Эдгээр хязгаарлалтаас ангижрахын тулд компаниуд микросервис архитектур руу шилжүүлсэн. ~\cite{wolff2016}. Энэ өөрчлөлт нь багуудад салангид байдлаар өөрчлөлтийг хурдан байршуулалт хийх, аппликейшнийг дахин байршуулалт хийхгүйгээр шинэчлэл гаргах боломжийг олгосон. Микросервис рүү шилжих нь зөвхөн өргөжүүлэх чадварыг сайжруулаад зогсохгүй, багуудад бие даасан байдал өгч, зохицуулалтын ачааллыг бууруулж, инновацийг хурдасгасан.

\subsection{Микросервисийн тодорхойлолт}

Микросервис архитектур нь програм хангамжийг хөгжүүлэх арга бөгөөд аппликейшныг жижиг, бие даасан сервисүүдэд хувааж хөгжүүлдэг. Энэхүү архитектурын гол онцлог нь дөрвөн чухал шинж чанарт илэрхийлэгддэг. ~\cite{wolff2016}.

Эхний шинж чанар нь бие даасан байдал юм. Микросервис бүр өөрийн тодорхой үүрэгтэй бөгөөд шаардлагатай бол өөрийн өгөгдлийн сантай байдаг. Энэ нь сервис бүр бусад сервисээс хараат бус ажиллах боломжийг олгодог. Хоёр дахь шинж чанар нь уян хатан хөгжүүлэлт юм. Өөр өөр багууд өөр өөр технологи, програмчлалын хэл ашиглан өөрсдийн сервисийг хөгжүүлж болдог. Энэ нь багууд өөрсдийн мэргэжлийн чиглэлд тохирсон технологи сонгох чөлөөг өгдөг. Гурав дахь шинж чанар нь өргөжих чадвар юм. Бүх системийг өргөжүүлэх шаардлагагүй бөгөөд зөвхөн ачаалал их эсвэл илүү их нөөц шаарддаг сервисийг л өргөжүүлэх боломжтой. Дөрөв дэхь шинж чанар нь найдвартай байдал юм. Хэрэв нэг сервис алдаа гарч унавал бусад сервисүүд хэвийн ажиллаж үргэлжлэх бөгөөд энэ нь системийн ерөнхий тогтвортой байдлыг хангадаг.

\section{Микросервисийн давуу тал}

Микросервис архитектур нь монолит системээс олон талаараа давуу талтай байдаг. Технологийн олон янз байдлын талаас авч үзвэл, сервис бүр өөрийн хэрэгцээнд хамгийн тохирсон технологи сонгох боломжтой. Жишээлбэл, нэг сервис Python програмчлалын хэл ашиглаж өгөгдөл боловсруулалт хийж болох бол нөгөө сервис Go ашиглан өндөр гүйцэтгэлтэй серверийн хэсэг хариуцаж, өөр нэг сервис Node.js ашиглан бодит цагийн холболт зэргийг удирдаж болно. ~\cite{nadareishvili2016}.

Багуудын бие даасан ажиллагааны хувьд баг бүр өөрийн сервисийг хараат бусаар хөгжүүлж, шууд хэрэглээнд нэвтрүүлэх чадвартай. Энэ нь багуудын хурд, уян хатан байдлыг нэмэгдүүлдэг. Хурдан нэвтрүүлэлтийн талаас авч үзвэл том системийг бүхэлд нь дахин нэвтрүүлэх шаардлагагүй бөгөөд зөвхөн өөрчлөлт орсон сервисийг л нэвтрүүлэхэд цаг хугацааг ихээхэн хэмнэдэг. Илүү сайн өргөжих чадварт ачаалал их байгаа тодорхой сервисийг л өргөжүүлэх нь бүх системийг бүхэлд нь өргөжүүлэхээс илүү үр ашигтай бөгөөд зардал хэмнэлттэй. Эцэст нь алдааны тусгаарлалтын талаас авч үзвэл нэг сервисийн алдаа нь бусад сервист шууд дамжихгүй тул системийн бусад хэсэг хэвийн үргэлжлэн ажилладаг.

\section{Микросервисийн сорилтууд}

Микросервис архитектур олон давуу талтай боловч практикт тулгарах сорилтууд ч багагүй байдаг. Нарийн төвөгтэй байдлын хувьд олон сервисүүдийг зэрэг удирдах, тэдгээрийн харилцааг хянах, байршуулалтыг хийх нь монолит системээс илүү төвөгтэй бөгөөд тусгай хяналтын хэрэгслүүд шаарддаг. ~\cite{nadareishvili2016}.

Өгөгдлийн тогтмол байдлын асуудал нь сервис бүр өөрийн өгөгдлийн сантай байдгаас үүсдэг. Олон сервисийн өгөгдлийн нийцтэй, уялдаатай байдлыг хангах нь уламжлалт транзакцийн удирдлагаар шийдэгдэхгүй асуудал болдог. Сүлжээний хоцрогдлын талаас авч үзвэл сервисүүд хоорондоо сүлжээгээр харилцдаг учир нэмэлт хоцрогдол гардаг бөгөөд энэ нь системийн ерөнхий гүйцэтгэлд нөлөөлдөг. Алдаа илрүүлэх хэцүү байдал нь олон сервисүүдээр дамжин явах хүсэлтийн алдааг олж тодорхойлох, засах ажил үйл ажиллагаа төвөгтэй болдог. Сервис хоорондын харилцааны асуудал нь сервисүүд хэрхэн үр дүнтэй харилцах, ямар протокол ашиглах, өгөгдлийн формат хэрхэн нийцүүлэх зэрэг олон нарийн асуудлыг шийдэхийг шаарддаг. Эцэст нь транзакцийн удирдлагын асуудал нь олон сервисүүдээр транзакци явуулах нь өгөгдлийн сангууд түгжигдэх, тогтворгүй байдал үүсэх эрсдлийг нэмэгдүүлдэг. 

\section{Микросервис хоорондын харилцаа}

Микросервисүүд хоорондоо хоёр гол аргаар харилцдаг: ~\cite{nadareishvili2016}.

\subsection{Синхрон харилцаа}

Синхрон харилцаа нь HTTP REST програмчлалын интерфэйс эсвэл gRPC ашиглан шууд хүсэлт илгээж хариу хүлээдэг арга юм. Энэ арга нь хэрэгжүүлэхэд харьцангуй энгийн боловч сул талтай. Эхний сул тал нь нягт хамаарал буюу tight coupling үүсгэдэг. Сервисүүд бие биенээсээ шууд хамаарч байдаг учир нэг сервис өөрчлөгдөх үед бусад сервист нөлөөлдөг. Хоёр дахь сул тал нь нэг сервис унавал түүнээс хамааралтай бусад сервисүүд ч гэсэн алдаа гаргаж зогсдог. Энэ нь системийн найдвартай байдлыг бууруулдаг. Гурав дахь сул тал нь хоцрогдол нэмэгддэг. Сервисүүд бие биенээсээ хариу хүлээж байдаг учир хариултын цаг удаан байх тусам ерөнхий системийн хоцрогдол нэмэгддэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/microservice.png}
    \caption{Синхрон микросервис}
    \label{fig:microservicesync}
\end{figure}

Сервисийн тоогоор NxM холболтын харьцаагаар холболт нэмэгдэх учир үүнийг найдвартай удирдахад маш хүндрэлтэй болно.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/conMonolith.png}
    \caption{Синхрон микросервисийн NxM холбоо}
    \label{fig:conmicroservicesync}
\end{figure}

\subsection{Асинхрон харилцаа}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/microserviceEda.png}
    \caption{Асинхрон микросервис}
    \label{fig:microserviceasync}
\end{figure}

Асинхрон харилцаа нь мессежийн дараалал ашигладаг арга бөгөөд RabbitMQ, Apache Kafka зэрэг технологиудыг ашиглан мессеж солилцдог. Энэхүү аргууд дараах онцлогтой. Эхний онцлог нь салангид байдлыг үүсгэдэг. Сервисүүд шууд бус мессежийн брокероор дамжин харилцдаг учир бие биенээсээ хараат бус байдаг. Хоёр дахь онцлог нь илүү найдвартай байдаг. Нэг сервис түр зуур унасан ч мессеж хадгалагдсан байх тул дараа нь боловсруулагдах боломжтой. Гурав дахь онцлог нь синхрон харилцаанаас илүү төвөгтэй хэрэгжилттэй байдаг. Мессежийн формат тодорхойлох, алдааны менежмент хийх, мессежийн дараалал хангах зэрэг нэмэлт асуудлыг шийдэх шаардлагатай.

\section{Үйл явдлаар удирдагдах архитектур буюу EDA}

\subsection{EDA гэж юу вэ}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/conMicroservice.png}
    \caption{Үйл явдлаар удирдагдах архитекурт микросервис}
    \label{fig:microserviceaconsync}
\end{figure}

Микросервисүүд гарч ирснээр шинэ сорилт бий болсон ~\cite{nadareishvili2016}.: эдгээр сервисүүд хэрхэн үр дүнтэй харилцах вэ? Хэрэв бид сервисүүдийг шууд gRPC эсвэл API-ээр холбовол бид асар том хамаарлын сүлжээ үүсгэнэ. Хэрэв нэг сервис унавал энэ нь холбогдсон замын дагуух бүх node-д нөлөөлнө. Мөн гацалт маш ихээр үүснэ.

EDA нь энэхүү асуудлыг шийдэж болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Сервисүүд бие биенийгээ хүлээхгүй. Бодит цагт юу болж байгааг мэдээд хариу үйлдэл үзүүлдэг.



\subsection{EDA-ын давуу тал}

EDA нь дөрвөн гол давуу талтай. Салангид байдлын хувьд сервисүүд үйл явдлаар харилцдаг учир тэд бие биенээсээ бүрэн хараат бус байдаг. Нэг сервис өөрчлөгдөх эсвэл түр зуур унах нь бусад сервист шууд нөлөөлөхгүй бөгөөд энэ нь системийн уян хатан чанар байдлыг дээшлүүлдэг.

Өргөжүүлэх чадварын талаас авч үзвэл сервис бүр үйл явдлыг бие даан боловсруулдаг учир шаардлагатай сервисийг л өргөжүүлэх боломжтой. Энэ нь бүх системийг өргөжүүлэхээс хамаагүй хялбар бөгөөд зардал хэмнэлттэй. Уян хатан байдлын хувьд шинэ сервис нэмэх эсвэл одоо байгаа сервисийг өөрчлөх нь бусад сервист өөрчлөлт шаардахгүй. Үйл явдлын формат өөрчлөгдөөгүй бол өөр бусад сервисүүд хэвээр ажилладаг. Эцэст нь бодит цагийн боловсруулалтын талаас авч үзвэл үйл явдлууд тэр даруйдаа боловсруулагдах тул систем нь өөрчлөлт, шинэ мэдээлэлд маш хурдан хариу үйлдэл үзүүлэх чадвартай.

\subsection{Apache Kafka}

Apache Kafka нь салангид, өндөр дамжуулалттай, бага хоцрогдолтой EDA-ийн төв мэдээллийн систем болж чаддаг. ~\cite{kreps2014}.

\subsubsection{Kafka-ийн үндсэн ойлголтууд}

Apache Kafka-ийн архитектур нь таван үндсэн ойлголт дээр суурилдаг. ~\cite{kreps2014}. Сэдэв буюу topic нь үйл явдлуудыг ангилах логик сувагийн үүрэг гүйцэтгэдэг. Жишээлбэл "user-events", "order-events" гэх мэт нэршлээр үйл явдлуудыг ангилж хадгалдаг. Үйлдвэрлэгч буюу producer нь үйл явдлыг topic руу бичдэг аппликейшн юм. Хэрэглэгч буюу consumer нь эсрэгээр сэдвээс үйл явдлыг уншиж боловсруулдаг аппликейшн болно. Хэсэглэл буюу partition нь topic-ийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог механизм юм. Нэг topic олон partition-д хуваагдаж, параллель уншигдаж боловсруулагдах боломжтой. Эцэст нь хэрэглэгчийн груп буюу consumer group нь олон consumer нэг баг болон зохион байгуулагдаж ачааллыг хуваарилан боловсруулах боломжийг олгодог.

\subsubsection{Kafka-ийн давуу тал}

Apache Kafka дараах давуу талуудтай. ~\cite{kreps2014} Хэвтээ өргөжих чадварын хувьд Kafka-ийн салангид зохиомж нь саадгүйгээр шинэ агент эсвэл хэрэглэгч нэмэх боломжийг олгодог. Системийн ачаалал нэмэгдэх тусам partition нэмж, хэрэглэгч нэмж өргөжүүлэх нь маш энгийн.

Бодит цагийн үйл явдал боловсруулалт нь агентуудад өөрчлөлтөд шууд хариу үйлдэл үзүүлэх боломжийг олгодог. Мессеж миллисекундын дотор дамжих учир бодит цагийн систем бүтээхэд тохиромжтой. Салангид хамааралын талаас авч үзвэл сэдвүүдээр харилцах нь агентууд хараат бус, өргөжүүлэх боломжтой байхыг баталгаажуулдаг. Агент нэмэх, хасах, өөрчлөх нь бусад агентад нөлөөлөхгүй. Үйл явдлын хадгалалтын талаас авч үзвэл тогтвортой мессежийн хадгалалт нь өгөгдөл дамжилтын явцад алга болохгүй гэдгийг баталгаажуулдаг. Мессеж диск дээр хадгалагддаг учир хэрэглэгч алдаатай байсан ч мессеж хадгалагдсан байна. Эцэст нь дахин ачааллуулж гүйцэтгэх боломжийн хувьд Kafka нь салангид лог ашигладаг учраас үйл явдал бүр хадгалагдаж, алдаа засах, үнэлгээ хийх, модел дахин сургахад дахин тоглуулж ашиглах боломжтой.

\subsection{Apache Flink}

Apache Flink нь сүүлийн төлвөөр тооцоолол, үйл явдал цагийн боловсруулалт хийх чадвартай салангид урсгал тооцооллын фреймворк юм. ~\cite{flink} Flink нь Kafka-тай хамт ашиглах замаар хүчирхэг бодит цагийн өгөгдөл боловсруулалтын систем бүтээх боломжийг олгоно.

\subsubsection{Flink-ийн давуу тал}

Apache Flink нь дараах давуу талуудтай. Flink нь төлөв байдлыг найдвартай удирдаж, нарийн төвөгтэй тооцоолол хийх боломжийг олгодог. Үйл явдлуудын хоорондох хамаарлыг хадгалж, өөр бусад цар хүрээтэй өгөгдлийг ашиглан нарийн шинжилгээ хийж чаддаг. Үйл явдлын цаг дээр үндэслэн бодит цагийн шинжилгээ хийх чадвартай. Энэ нь хоцрогдсон мессежүүдийг зөв цагийн дагуу боловсруулах боломжийг олгодог. Flink нь секундэд сая сая үйл явдлыг боловсруулах чадвартай бөгөөд параллель боловсруулалт ашиглан асар их хэмжээний өгөгдлийг боловсруулж чаддаг. Эцэст нь "яг ганц" семантикийн талаас авч үзвэл мэдээлэл яг нэг удаа л боловсруулагдахаар баталгааждаг. Энэ нь өгөгдөл алдагдах эсвэл давхардах асуудлыг шийддэг.

\subsubsection{Flink ба хиймэл оюун}

Flink нь том хэлний моделтэй ажиллах чадвартай. ~\cite{falconer2025future} Flink нь өгөгдлийг авч, том хэлний модел руу илгээж, хариу авах боломжийг олгодог. Энэ нь төлөвлөгч агентыг Flink аппликейшн болгон хөгжүүлэх боломжийг олгодог.

Ажиллах зарчмыг жишээгээр авч үзье. Эхлээд Kafka сэдвээс үйл явдлыг уншина. Дараа нь том хэлний модел ашиглан цар хүрээг ойлгох, даалгаврыг задлах, төлөвлөгөө гаргах үйл явцыг гүйцэтгэнэ. Үр дүнг өөр Kafka topic руу бичинэ. Эцэст нь бусад агентууд энэ үр дүнг уншиж тодорхой үүргүүдээ гүйцэтгэнэ. Иймээс рекурисв байдлаар ажиллаж чаддаг. Энэхүү зохион байгуулалт нь урсгал боловсруулалтын давуу талыг хиймэл оюун агенттай нэгтгэж чаддаг.

\subsubsection{Flink болон RAG}

Төөрөгдлийг багасгахын тулд том хэлний моделийг бодит өгөгдөлд суурилуулах хэрэгтэй. Flink нь хайлтаар нэмэгдүүлсэн үүсгэлтийн зохион байгуулалтыг бүтээхэд чухал үүрэг гүйцэтгэдэг.  ~\cite{polak2025}

Энэ үйл явц нь таван үндсэн алхамтай. Эхлээд Flink нь өгөгдлийг боловсруулж, цэвэрлэж, хувиргана. Дараа нь моделийн гаралтыг ашиглан өгөгдлийг embedding болгон хөрвүүлнэ. Гурав дахь алхамд векторчилсан хэсгийн төлөөлөл буюу embedding-г Kafka topic руу бичиж хадгална. Дөрөв дэхь алхамд Kafka Connect ашиглан векторчилсан хэсгийн төлөөллийг векторын өгөгдлийн сан руу синхрончилдог. Эцсийн алхамд агентууд хайлтаар нэмэгдүүлсэн үүсгэлт ашиглан бодит өгөгдөл дээр суурилсан найдвартай хариулт өгөх боломжтой болно. Энэ урсгал нь бодит цагт өгөгдлийг боловсруулж, том хэлний моделийн мэдлэгийг тасралтгүй шинэчилж байх боломжийг олгодог.

\subsection{Агентууд ба EDA}

Хиймэл оюун агентуудыг өргөжүүлэх нь үндсэндээ салангид систем байж болох талаарх асуудал юм. Агентууд нь шийдвэр гаргаж, үйлдэл хийхийн тулд олон эх сурвалж, бусад агентууд, хэрэглүүрүүд, гадаад системүүдээс мэдээлэл цуглуулах шаардлагатай.  ~\cite{huyen2024} 

Агентууд яагаад үйл явдлаар удирдагдах архитектур шаарддаг вэ гэдэг нь гурван гол шалтгаанаас үүдэлтэй. Асинхрон шинж чанарын хувьд агентууд хүн шиг ажилладаг. Агент нь олон эх сурвалжаас мэдээлэл цуглуулж, өгөгдлийг шинжилж, бүх талын мэдээлэлд үндэслэн шийдвэр гаргах хэрэгтэй. Эдгээр үйл явцууд нь асинхрон шинжтэй бөгөөд тодорхой дарааллаар биш параллель явагддаг.  ~\cite{falconer2025future}

Агентууд нь өмнөх үйлдлүүдийн үр дүн, бусад агентуудын гаралт, хэрэглэгчийн түүх зэрэг олон мэдээллийг нэгтгэж ашигладаг. Энэ нь хамаарлыг оновчтой удирдах, бодит цагийн өгөгдлийн урсгалыг гаргах онцгой шаардлагыг бий болгоно. Агентын гаралт нь зөвхөн хиймэл оюунт аппликейшн рүү биш, харин өгөгдлийн сан, CRM, харилцагчийн төлбөр тооцоо зэрэг бусад чухал системүүд рүү урсаж болно. Мөн алдаа засах, шинжилгээ хийх зорилгоор лог хадгалах шаардлагатай.

Агентуудыг синхрон холболттой gRPC болон API-аар холбож болно, гэвч энэ нь нягт холбогдсон системүүдийг бий болгодог. Энэхүү нягт холбоос нь өргөжүүлэх, дасан зохицох, эсвэл ижил өгөгдлийн олон хэрэглэгчдийг дэмжихэд хэцүү болгодог. Агентууд нь уян хатан байдлыг шаарддаг. Тэдний гаралт нь бусад агентууд, сервисүүд, платформуудад тодорхой дүрмийн дагуу үр дүн дамжих ёстой.

\section{Бүлгийн дүгнэлт}

Энэхүү бүлэгт микросервис архитектурын онол, практик, түүнчлэн үйл явдлаар удирдагдах архитектурын давуу талыг дэлгэрүүлэн судалсан. Монолит системээс микросервис рүү шилжих нь программ хангамжийн хөгжлийн чухал дэвшил болов. ~\cite{falconer2025future}

Микросервис хоорондын харилцаа нь хоёр гол аргаар хэрэгждэг. Синхрон харилцаа нь HTTP REST эсвэл gRPC ашигладаг боловч нягт хамаарал үүсгэж, нэг сервис унавал бусад сервисүүдэд алдаа гаргадаг. Сервисийн тоогоор NxM холболтын нарийн төвөгтэй байдал нь системийг удирдахад хүндрэлтэй болгодог. Асинхрон харилцаа нь мессежийн брокер ашигладаг бөгөөд салангид байдлыг бий болгож, найдвартай боловч илүү төвөгтэй хэрэгжилттэй.

EDA нь микросервисийн энэхүү харилцааны хамгийн үр дүнтэй шийдэл болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Салангид байдал, өргөжүүлэх чадвар, уян хатан байдал, бодит цагийн боловсруулалт зэрэг давуу талууд нь EDA-г орчин үеийн микросервис архитектурын суурь болгосон.

Apache Kafka нь EDA-ын хүчирхэг хэрэглүүр ба "Topic, producer, consumer, partition, consumer group" зэрэг үндсэн ойлголтууд нь системийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог. ~\cite{polak2025} Kafka-ийн хэвтээ өргөжих чадвар, бага хоцрогдол, салангид байдал, үйл явдлын хадгалалт, дахин тоглуулах боломж зэрэг онцлогууд нь өргөн ашиглагддаг шалтгаан болов.

Apache Flink нь Kafka-тай хамт ашиглахад илүү хүчирхэг болдог. Өгөгдөл холбож дамжуулах боловсруулалт, өндөр дамжуулалт, "яг л нэг" зарчим зэрэг давуу талууд нь нарийн төвөгтэй урсгал боловсруулалтад тохиромжтой. Flink нь хиймэл оюуны моделтэй холбогдож, төлөвлөгч агентыг Flink app болгон хөгжүүлэх боломжийг олгодог. Flink болон RAG-ийг хослуулах нь төөрөгдлийг багасгаж, бодит өгөгдөлд суурилсан хиймэл оюун систем бүтээхэд тусалдаг.

Хиймэл оюун агентууд бүр өөр өөрийн гэсэн даалгаврын цар хүрээ хариуцах учраас микросервис шиг салангид байдлаар ашиглагдвал цаашдын хиймэл оюунт программ хөгжүүлэхэд үр дүнтэй. Агентуудын олон цар хүрээт мэдээллийн хамаарлаар, олон хэрэглэгчдэд үйлчлэхэд EDA зайлшгүй шаардлагатай болгодог. Агентуудыг gRPC эсвэл API-аар холбох нь боломжтой боловч нягт холбоос үүсгэж, өргөжүүлэх, дасан зохицоход хүндрэлтэй болгодог. EDA нь агентуудыг салангид микросервис болгон хөгжүүлэх, өргөжүүлэх, найдвартай байлгах хамгийн тохиромжтой арга замуудын нэг болох юм.

Энэхүү бүлгээс харахад микросервис архитектур нь монолитын асуудлуудыг шийдэж чадсан боловч шинэ сорилтууд авчирсан. Үйл явдлаар удирдагдах архитектур, Kafka, Flink зэрэг технологиуд нь эдгээр сорилтуудыг шийдэж, илүү уян хатан, өргөжих боломжтой, найдвартай систем бүтээх суурийг бүрдүүлсэн. Дараагийн бүлэгт эдгээр онолуудыг ашиглан тодорхой асуудлуудыг хэрхэн шийдэх талаар авч үзнэ.

% Асуудлын тодорхойлолт ба шийдэл - Нэгдсэн бүлэг
\include{src/problem-solution}

% Хэрэгжүүлэлт бүлэг
\include{src/implementation}

%----------------------------------------------------------------------------------------
%   Дүгнэлт эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\conclusion{Дүгнэлт}

Энэхүү судалгааны ажил нь хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг судалж, практик загвар санал болгосон. Судалгааны явцад дараах гол үр дүнд хүрсэн:

\textbf{Онолын хувьд:}

Хиймэл оюуны инженерчлэл нь програм хангамж хөгжүүлэлтийн шинэ салбар болж хөгжиж байгаа нь тодорхой. Суурь моделийн гарч ирэх нь аппликейшн хөгжүүлэлтийн саад бэрхшээлийг эрс багасгасан. Хэл загваруудаас том хэлний загвар, цаашлаад суурь загвар руу хөгжих үйл явц нь арван жилийн технологийн дэвшлийн үр дүн юм. Өөрийгөө удирдсан сургалт, Transformer архитектур, post-training аргууд зэрэг гол түлхүүрүүд нь өнөөгийн хүчирхэг хиймэл оюун системүүдийн суурь болгосон.

Хиймэл оюун агентуудын онол нь орчин, үйлдэл, даалгавар гэсэн гурван гол бүрэлдэхүүн дээр суурилдаг. Агентууд нь төлөвлөлт, хэрэглүүрийн хэрэглээ, эргэцүүлэн бодох чадвартайгаар уламжлалт програмуудаас давуу талтай. RAG систем нь агентуудын мэдлэгийг өргөтгөж, илүү найдвартай, бодит мэдээлэл дээр суурилсан хариулт өгөх боломжийг олгодог.

\textbf{Практикийн хувьд:}

Микросервис архитектур дахь сервис хоорондын нарийн төвөгтэй логик, өгөгдлийн нэгтгэл, динамик routing зэрэг асуудлуудыг хиймэл оюун агентууд ашиглан шийдэж болох нь тодорхой болсон. Санал болгосон Orchestrator Agent, Service Agent, Knowledge Agent, Monitoring Agent зэрэг бүрэлдэхүүн хэсгүүд нь уян хатан, өргөжүүлэх боломжтой системийг бий болгодог.

Гэхдээ агентуудыг үйлдвэрлэлийн түвшинд өргөжүүлэхийн тулд зөвхөн агентын ур чадвар биш, тэдгээрийг холбодог архитектур чухал гэдгийг ойлгосон. Монолит болон RPC/API суурилсан холболт нь монолит архитектурт тулгарсан асуудалтай адил саад болдог. Үүнийг шийдэхийн тулд үйл явдлаар Event-Driven архитектур ашиглан агентуудыг салангид микросервис болгон хөгжүүлэх шаардлагатай.

\textbf{Event-Driven архитектур}

Apache Kafka болон Apache Flink ашиглан event-driven агентын систем бүтээх нь:

\begin{itemize}
    \item \textbf{Салангид байдал}: Kafka topics-оор харилцах нь агентууд хоорондоо шууд хамааралгүй байхыг баталгаажуулна
    \item \textbf{Параллель боловсруулалт}: Kafka partitions ашиглан олон агент зэрэг ажиллаж, системийн дамжуулалтыг нэмэгдүүлнэ
    \item \textbf{Найдвартай байдал}: Үйл явдлын хадгалалт нь мэдээлэл алдагдахгүй, дахин тоглуулж болохыг баталгаажуулна
    \item \textbf{Bодит цагийн боловсруулалт}: Streaming архитектур нь тэр даруй хариу үйлдэл үзүүлэх боломжийг олгоно
    \item \textbf{Олон хэрэглэгч}: Агентын гаралт нь CRM, CDP, analytics зэрэг олон системд автоматаар урсах боломжтой
\end{itemize}

Flink AI Inference ашиглах нь orchestrator агентыг stream processing app болгон хөгжүүлэх боломжийг олгож, Flink-ийн stateful боловсруулалт, exactly-once семантик зэрэг давуу талыг ашиглах боломжтой болгоно.

Apache Kafka болон Apache Flink зэрэг технологиудыг ашиглан event-driven агентын систем нь:
\begin{itemize}
    \item Бие даан өргөжиж чадна
    \item Бодит цагт өгөгдөл боловсруулна
    \item Системийн хэмжээнд мэдээллээ хуваалцана
    \item Алдаанаас сэргэж чадна
    \item Дахин тоглуулах замаар сайжирна
\end{itemize}

Микросервис архитектурт хиймэл оюун агентууд нэвтрүүлэх нь системийг илүү ухаалаг, уян хатан, хэрэглэгчид ээлтэй болгох боломжийг олгоно. Хэдийгээр одоогоор хязгаарлалтууд(Жич:хоцрогдол, өртөг, найдвартай байдал) байгаа ч технологи хурдацтай хөгжиж байгаа тул ойрын ирээдүйд эдгээр асуудлууд шийдэгдэх болно гэж найдаж байна.

Энэхүү дипломын ажил нь хиймэл оюуны инженерчлэлийн үндсийг тавьж, микросервис архитектурт агент суурилсан шийдлийг практикт хэрхэн хэрэглэж болохыг харуулсан. 

% Техникийн хөгжүүлэлтийн хувьд Next.js React фронтенд, Node.js Express бэкенд, TypeScript, MySQL ашиглан SOLID зарчмыг дагасан архитектур бүтээсэн. Merchant Super App OAuth механизм, ҮЦТХТ SOAP API интеграци, 300,000+ мөртэй өгөгдлөөс binary search алгоритмаар хурдан хайлт хийх(5-40ms), үнэт цаасны real-time дата WebSocket ашиглан дамжуулах систем зэрэг олон чухал арга техникийг амжилттай хэрэгжүүлсэн.

% Фүллстек веб хөгжүүлэлт, API интеграци, real-time дата боловсруулалт, Docker containerization, DevOps практик зэрэг олон чиглэлийн техникийн чадваруудыг эзэмшсэн. Мөн багийн ажиллагаа, төслийн удирдлага, Git workflow, CI/CD pipeline зэрэг мэргэжлийн ур чадваруудыг хөгжүүлсэн.

% Энэхүү дадлагын үр дүнд санхүүгийн технологийн салбарт бодит ажлын туршлага олж авч, ирээдүйд илүү том, нарийн төвөгтэй системүүд хөгжүүлэх, санхүүгийн технологийн салбарт хувь нэмрээ оруулах чадварыг эзэмшсэн.

%----------------------------------------------------------------------------------------
%   Дипломын номзүй, хавсралтын хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------

\singlespace
\addcontentsline{toc}{part}{НОМ ЗҮЙ}
\begin{thebibliography}{99}
	% Үндсэн ном зохиол
	\bibitem{huyen2024}
	Huyen, Chip. \textit{AI Engineering}. O'Reilly Media, 2024.
	
	\bibitem{goldman2023}
	Goldman Sachs Research. "Generative AI Could Raise Global GDP by 7\%", 2023. 
	\url{https://www.goldmansachs.com/intelligence/pages/generative-ai-could-raise-global-gdp-by-7-percent.html}
	
	% Foundation Models
	\bibitem{vaswani2017}
	Vaswani, A., et al. "Attention Is All You Need". \textit{Advances in Neural Information Processing Systems}, 2017.
	
	
	% RAG
	\bibitem{gao2023}
	Gao, Y., et al. "Retrieval-Augmented Generation for Large Language Models: A Survey". \textit{arXiv preprint arXiv:2312.10997}, 2023.
	
	% AI Agents
	\bibitem{yao2023}
	Yao, S., et al. "ReAct: Synergizing Reasoning and Acting in Language Models". \textit{ICLR}, 2023.
	
	\bibitem{schick2023}
	Schick, T., et al. "Toolformer: Language Models Can Teach Themselves to Use Tools". \textit{arXiv preprint arXiv:2302.04761}, 2023.
	
	% Prompt Engineering
	\bibitem{openai2023}
	OpenAI. "Prompt Engineering Guide", 2023. \url{https://platform.openai.com/docs/guides/prompt-engineering}
	
	% Microservices
	\bibitem{newman2015}
	Newman, Sam. \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media, 2015.
	
	
	\bibitem{fowler2014}
	Fowler, Martin and Lewis, James. "Microservices: A Definition of This New Architectural Term", 2014. \url{https://martinfowler.com/articles/microservices.html}
	
	
	% API & Integration
	\bibitem{fielding2000}
	Fielding, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.
	
	% Python & Tools
	\bibitem{python}
	Python Software Foundation. "Python 3 Documentation". \url{https://docs.python.org/3/}
	
	\bibitem{fastapi}
	Ramírez, Sebastián. "FastAPI Documentation". \url{https://fastapi.tiangolo.com/}
	
	\bibitem{openai-api}
	OpenAI. "OpenAI API Reference". \url{https://platform.openai.com/docs/api-reference}
	
	\bibitem{anthropic2024}
	Anthropic. "Claude Model Card", 2024. \url{https://www.anthropic.com/claude}
	
	
	\bibitem{faiss}
	Facebook AI Research. "FAISS: A Library for Efficient Similarity Search". \url{https://github.com/facebookresearch/faiss}
	
	% Event-Driven Architecture & Streaming
	\bibitem{falconer2025agents}
	Falconer, Sean. "AI Agents are Microservices with Brains". Medium, March 2025. \url{https://medium.com/@seanfalconer}
	
	\bibitem{falconer2025future}
	Falconer, Sean. "The Future of AI Agents is Event-Driven". BigDataWire, March 2025.
	
	\bibitem{polak2025}
	Polak, Adi. "Building AI Agents with Event-Driven Microservices". Confluent Developer Advocate, 2025.
	
	\bibitem{kafka}
	Apache Kafka Documentation. "Apache Kafka: A Distributed Streaming Platform". \url{https://kafka.apache.org/documentation/}
	
	\bibitem{kreps2014}
	Kreps, Jay, Narkhede, Neha, and Rao, Jun. "Kafka: A Distributed Messaging System for Log Processing". \textit{Proceedings of the NetDB}, 2011.
	
	\bibitem{flink}
	Apache Flink Documentation. "Stateful Computations over Data Streams". \url{https://flink.apache.org/}
	
	\bibitem{carbone2017}
	Carbone, Paris, et al. "State Management in Apache Flink: Consistent Stateful Distributed Processing". \textit{Proceedings of the VLDB Endowment}, 2017.
	
	% Microservices Evolution
	\bibitem{wolff2016}
	Wolff, Eberhard. \textit{Microservices: Flexible Software Architecture}. Addison-Wesley Professional, 2016.
	
	\bibitem{nadareishvili2016}
	Nadareishvili, Irakli, et al. \textit{Microservice Architecture: Aligning Principles, Practices, and Culture}. O'Reilly Media, 2016.
	
	% Anthropic MCP
	\bibitem{anthropic2024mcp}
	Anthropic. "Model Context Protocol: A Universal Standard for AI Integration", 2024. \url{https://www.anthropic.com/news/model-context-protocol}
	
\end{thebibliography}


%----------------------------------------------------------------------------------------
%   Хавсралтууд эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\appendix
\addcontentsline{toc}{part}{ХАВСРАЛТ}

% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
% \chapter{Нүүр хуудас}


% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
% \chapter{Кодын хэрэгжүүлэлт}

% \section{Merchant Super App OAuth нэвтрэлт}

% \begin{lstlisting}[language=Java, caption=Merchant App Authorization Redirect Handler]
% router.get("/merchantA", async (req, res) => {
%
%   res.redirect(process.env.PROD_FRONTURL);
% });
% \end{lstlisting}

% \section{Cron job болон тогтмол синхронизаци}



\end{document}
