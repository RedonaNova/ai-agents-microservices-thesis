%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[12pt,a4paper]{report}

\usepackage{fontspec,xltxtra,xunicode}
\setmainfont[Ligatures=TeX]{Times New Roman}
\setsansfont{Arial}

% \usepackage[utf8x]{inputenc}
% \usepackage[mongolian]{babel}
%\usepackage{natbib}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\setlength{\headheight}{29.03363pt}
%\usepackage{fancyheadings} fancyheadings is obsolete: replaced by fancyhdr. JL
\usepackage{fancyhdr}
% Set up page numbering style
\pagestyle{fancy}
\fancyhf{} % Clear all headers and footers
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{float}
\usepackage{afterpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsbsy}
\usepackage{dcolumn,array}
\usepackage{tocloft}
\usepackage{styles/dics}
% Ensure proper page numbering after dics.sty is loaded
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{nomencl}
\usepackage{upgreek}
\newcommand{\argmin}{\arg\!\min}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}

% Packages for better text wrapping and line breaking
\usepackage{microtype} % Improves text appearance and reduces overfull boxes
\usepackage{ragged2e} % Better text justification
\usepackage{hyphenat} % Better hyphenation control
\usepackage{url} % Better URL line breaking

% Emergency stretch to prevent overfull hboxes
\emergencystretch=1em

% Additional settings for better text handling
\tolerance=1000
\hyphenpenalty=50
\exhyphenpenalty=50

% Set line breaking parameters
\linespread{1.05} % Slightly increase line spacing
\clubpenalty=10000 % Prevent single lines at bottom of page
\widowpenalty=10000 % Prevent single lines at top of page

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{listings}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\makeatletter
\usepackage{caption}
\captionsetup[table]{belowskip=0.5pt}
\usepackage{subfiles}

\usepackage{listings}
\renewcommand{\lstlistingname}{Код}
\renewcommand{\lstlistlistingname}{\lstlistingname ын жагсаалт}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.99,0.99,0.99}
\definecolor{lightgray}{rgb}{0.83,0.83,0.83}
 
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=false,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=true,
    showtabs=false,                  
    tabsize=2,
    % Additional settings for better line breaking
    breakindent=1.5em,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    frame=single,
    rulecolor=\color{lightgray},
    columns=flexible,
    % Ensure lines don't exceed margins
    xleftmargin=2em,
    xrightmargin=2em
}
 
\lstset{style=mystyle, label=DescriptiveLabel} 

\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\makenomenclature
\begin{document}


%----------------------------------------------------------------------------------------
%   Өөрийн мэдээллээ оруулах хэсэг
%----------------------------------------------------------------------------------------

% Дипломийн ажлын сэдэв
\title{Микросервис архитектурт суурилсан хиймэл оюун агентууд}
% Дипломын ажлын англи нэр
\titleEng{AI agents for microservices}
% Өөрийн овог нэрийг бүтнээр нь бичнэ
\author{Булганы Раднаабазар}
% Өөрийн овгийн эхний үсэг нэрээ бичнэ
\authorShort{Б.Раднаабазар}
% Удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\supervisor{Дэд профессор Б.Сувдаа}
% Хамтарсан удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\cosupervisor{}

% СиСи дугаар 
\sisiId{22B1NUM0286}
% Их сургуулийн нэр
\university{МОНГОЛ УЛСЫН ИХ СУРГУУЛЬ}
% Бүрэлдэхүүн сургуулийн нэр
\faculty{МЭДЭЭЛЛИЙН ТЕХНОЛОГИ, ЭЛЕКТРОНИКИЙН СУРГУУЛЬ}
% Тэнхимийн нэр
\department{МЭДЭЭЛЭЛ, КОМПЬЮТЕРЫН УХААНЫ ТЭНХИМ}
% Зэргийн нэр
\degreeName{Дипломын ажлын тайлан}
% Суралцаж буй хөтөлбөрийн нэр
\programeName{Мэдээллийн технологи (D061304)}
% Хэвлэгдсэн газар
\cityName{Улаанбаатар}
% Хэвлэгдсэн огноо
\gradyear{2025 оны 10 сар}


%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
\include{src/main-pre}

% Удиртгалыг оруулж ирэх ба abstract.tex файлд удиртгалаа бичнэ
\include{src/abstract}

%----------------------------------------------------------------------------------------
%   Дипломын үндсэн хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------



\section{Судалгааны зорилго}

Энэхүү судалгааны ажлын гол зорилго нь дараах асуултуудад хариулна:

\begin{enumerate}
    \item Хиймэл оюуны инженерчлэлийн үндсэн онолыг тайлбарлах
    \item Хиймэл оюун агентуудын архитектур, төлөвлөлтийн механизм, хэрэглүүрүүдын ашиглалтыг судлах
    \item Микросервис архитектурын давуу болон сул талуудыг тодорхойлох
    \item Хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэхэд тулгарах асуудлуудыг тодорхойлох
    \item Хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх загвар санал болгох
\end{enumerate}

\chapter{Онолын хэсэг}

\subsection{Хиймэл оюуны инженерчлэл гэж юу вэ}

Хиймэл оюуны инженерчлэл гэдэг нь өмнө нь бэлтгэгдсэн суурь модел дээр аппликейшн хөгжүүлэх үйл явцийг хэлнэ. Энэ нь уламжлалт машин сургалтын инженерчлэл (ML engineering) эсвэл MLOps-оос ялгаатай байдаг. Хэрэв уламжлалт МS инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн бол, хиймэл оюун инженерчлэл нь одоо байгаа моделийг ашиглахад илүү анхаарал хандуулдаг~\cite{huyen2024}.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/aiAndML.png}
    \caption{Хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэл}
    \label{fig:home}
\end{figure}
Хүчирхэг суурь моделийн олдоц болон хүртээмж нь дараах гурван хүчин зүйлийг бүрдүүлж, Хиймэл оюун инженерчлэл хурдан өсч буй салбар болоход хүргэсэн:

\begin{enumerate}
    \item \textbf{Өндөр эрэлт}: Компаниуд хиймэл оюуныг бусад бизнесээс ялгарах өрсөлдөөнт давуу тал болгон үзэж байна. FactSet-ийн судалгаагаар 2023 оны хоёрдугаар улиралд S\&P 500 компаниудын гуравны нэг нь өөрсдийн орлогын тайланд хиймэл оюуныг дурдсан тоо нь өмнөх оноос гурав дахин их байна.
    \item \textbf{Хөгжүүлэлт}: Өмнө нь хиймэл оюун систем бүтээхэд өндөр мэргэжлийн ур чадвар, их хэмжээний өгөгдөл, тооцооллын нөөц шаардлагатай байсан бол одоо суурь модел ашиглан хэрэглээнд нэвтрүүлэх нь илүү боломжтой болов.
    \item \textbf{Том боломж}: Хиймэл оюун технологи нь ажил хэргийг автоматжуулалах, шинэ бүтээгдэхүүнүүдийг бий болгох зэрэг асар том боломжуудыг санал болгож байна.
\end{enumerate}

Хиймэл оюунт аппликейшний нээлттэй эхийн кодууд (AutoGPT, Stable Diffusion WebUI, LangChain, Ollama) нь GitHub дээр Bitcoin-оос ч илүү од цуглуулжээ.

\subsection{Суурь моделийн хөгжил}

Хэл загваруудаас том хэлний загвар, суурь загвар руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Энэхүү хэсэгт гол түлхүүр цэгүүдийг авч үзэх болно.

\subsubsection{Хэл моделийн үндэс}

Хэл загвар (language model) гэдэг нь нэг буюу хэд хэдэн хэлүүдийг статистик өгөгдөл рүү кодлодог загвар юм. Энэхүү мэдээлэл нь өгөгдсөн контекстэд уг үг гарах магадлалыг илэрхийлдэг. Жишээлбэл, "Миний дуртай өнгө бол \_\_" гэсэн контекст өгөхөд монгол хэлээр кодолсон хэл загвар нь "машин" биш, харин "цэнхэр" гэсэн үгийг таамаглах ёстой.

Анхны текстийг токен болгон хуваах үйл явцыг токенжуулалт (tokenization) гэнэ. GPT-4-ийн хувьд дунджаар нэг токен нь үгийн ойролцоогоор 75\%-ийн уртад тохирно. Тиймээс 100 токен нь ойролцоогоор 75 үг юм.

Хэл моделийн хоёр үндсэн төрөл байдаг:

\begin{itemize}
    \item \textbf{Далдлагдсан хэл загварууд}: Өгүүлбэр доторх далдлагдсан үгсийг таамаглах замаар сурдаг. BERT нь энэ төрлийн алдартай жишээ юм.
    \item \textbf{Автoрегрессив хэл загварууд}: Өмнөх токенуудад үндэслэн дараагийн токенийг таамаглах замаар сурдаг. Одоогийн ChatGPT, Cluade нь үүний жишээ юм.
\end{itemize}

\subsubsection{Өөрийгөө удирдсан сургалт}

Хэл моделийн хамгийн чухал давуу тал нь өөрийгөө удирдсан сургалт (self-supervision) ашиглах чадвар юм. Өөрийгөө удирдсан сургалт нь удирдлагатай сургалт (supervised learning)-аас ялгаатай байдаг. Удирдлагатай сургалт нь тэмдэглэгдсэн өгөгдөл (labeled data) шаарддаг бөгөөд энэ нь үнэтэй, цаг хугацаа их зарцуулдаг.

Энэ нь хэл моделийг номнуудаас, блог нийтлэлээс, өгүүллүүд, Reddit-ийн сэтгэгдэл зэргээс ашиглан сургаж болно. Энэ нь асар их сургалтын өгөгдөл бүрдүүлэх боломжийг олгож, хэл моделийг Том Хэлний Загвар (LLM) болтол өргөжүүлэх боломжтой болгосон.

\subsubsection{Том хэлний загвараас суурь загвар руу}

2017 онд Transformer архитектур гарч ирснээр хэл моделийн чадамж харьцангуй өндөр нэмэгдсэн. Attention механизм нь загваруудад урт хугацааны хамаарлыг илүү сайн ойлгох боломжийг олгосон.

Том хэлний загварууд (Large Language Models, LLMs) нь хэл моделийн томорсон хувилбар бөгөөд тэрбум тооны параметр агуулдаг. Параметр гэдэг нь сургалтын явцад моделийн сурч авдаг утга юм. Жишээлбэл, GPT-3 нь 175 тэрбум параметртэй, харин GPT-4 нь 1.2 их наяд параметртэй байдаг. 

Суурь загваруд (foundation models) нь LLM-ээс цааш өргөжсөн ойлголт юм. Эдгээр нь зөвхөн текст биш, зураг, аудио, видео зэрэг олон төрлийн өгөгдөл боловсруулж чаддаг том мульти модаль загварууд юм. Суурь моделийн гол онцлог нь тодорхой үүрэгтэй моделээс цаашлаад ерөнхий зориулалтын загвар руу шилжсэн нь юм.

\subsection{Суурь моделийн сургалт}

Суурь моделийг бэлтгэх нь хоёр үндсэн үе шаттай:

\subsubsection{Урьдчилан сургалт}

Урьдчилан сургалт нь өөрийгөө удирдсан сургалт ашиглан их хэмжээний өгөгдөл дээр моделийг сургах үйл явц юм. Энэ үе шатанд загвар нь хэл, ерөнхий мэдлэг, дүрэм, баримт бичгүүдээс суралцдаг. Гэвч энэхүү үе шатд хэрэглэгчдийн хүсэлтэд нийцсэн хариулт өгөхөд сайн биш байдаг. Учир нь харилцан яриа өрнүүлэх гэхээс илүүтэйгээр зөвхөн өгүүлбэрийн гүйцээлт рүү тулгуурлан сургагдсан байдаг.

\subsubsection{Дараах сургалт}

Урьдчилан сургасан моделийг хэрэглэгчдийн хүсэлтэд тохируулахын тулд дараах сургалт хийдэг. Энэ нь хоёр үе шаттай:

\begin{enumerate}
    \item \textbf{Supervised Finetuning, SFT}: Өндөр чанартай зааварчилгааны өгөгдөл (instruction data) дээр моделийг нарийвчлан сургаж, гүйцээлт биш харин ярианы горимд оновчтой болгоно.
    \item \textbf{Preference Finetuning}: Моделийг хүний сонголттой нийцсэн хариулт өгөхийн тулд цаашид нарийвчлан сургана. Үүнд RLHF (Reinforcement Learning from Human Feedback), DPO (Direct Preference Optimization), RLAIF (Reinforcement Learning from AI Feedback) зэрэг аргууд ордог.
\end{enumerate}

\subsection{Sampling стратегиуд}

Модел нь гаралтаа sampling процессоор бүтээдэг. Sampling нь хиймэл оюуны гаралтын магадлалыг шууд нөлөөлдөг. Дараах параметрууд нь sampling-д нөлөөлдөг:

\begin{itemize}
    \item \textbf{Temperature}: Температур өндөр байх тусам загвар илүү бүтээлч, гэнэтийн хариулт өгдөг. Температур бага байх тусам илүү таамагладаг, баттай хариулт өгнө.
    \item \textbf{Top-k}: Хамгийн их магадлалтай k ширхэг токеноос сонгодог. Үүнийг өөрчилснөөр хариулт содон байж болно. 
    \item \textbf{Top-p (nucleus sampling)}: Нийлбэр магадлал нь p-д хүрэх хамгийн бага токенуудын багцаас сонгодог. Энэ нь тийм, үгүй, урт хариулт, богино хариултын загварыг тодорхойлж болдог. Гэхдээ токений хэрэглээ багасна гэсэн үг биш. 
\end{itemize}

\subsection{Моделийн үр дүнг хэмжих}

Суурь моделийг үнэлэх нь эрсдэлийг бууруулах, цаашлаад боломжуудыг илрүүлэх тал дээр чухал ач холбогдолтой. Үнэлгээ нь загвар сонгох, дэвшлийг хэмжих, аппликейшн ашиглалтад бэлэн эсэхийг тодорхойлох, асуудал болон боломжуудыг илрүүлэх зэрэгт шаардлагатай.

Сүүлийн жилүүдэд бага параметртэй модел нь өмнөх үеийн их параметртэй моделээс илүү чадалтай байна. Жишээлбэл, 2024 оны Llama 3-8B загвар нь 2023 оны Llama 2-70B загвараас ч илүү сайн үр дүнг MMLU benchmark дээр харуулжээ. Энэ нь зөвхөн моделийн хэмжээ биш, сургалтын аргууд болон өгөгдлийн чанар хамгийн чухал болохыг харуулж байна.

Үнэлгээний гол асуудлууд:

\begin{itemize}
    \item \textbf{Нээлттэй төгсгөлтэй гаралт}: Суурь загваруудыг зөвхөн гаралтуудын өгөгдлөөс дүгнэх нь тул үнэлэхэд хэцүү.
    \item \textbf{Тогтворгүй байдал}: Загвар нь ижил эсвэл бага зэрэг өөр асуулт асуухад маш өөр хариулт өгч болно. Үүнээс хиймэл оюуны суурь моделын хариулт нь магадлалаас үүсдгийг ажиглаж болно.
    \item \textbf{Төөрөгдөл}: Загвар нь баримт дээр үндэслээгүй буруу хариулт өгч болно.
\end{itemize}

\section{Prompt инженерчлэл}

Prompt инженерчлэл гэдэг нь загвараас хүссэн үр дүнг гаргуулахын тулд зааврыг бичих үйл явц юм. Энэ нь моделийн жинг өөрчлөхгүйгээр зан үйлийг удирдах хамгийн хялбар бөгөөд түгээмэл загвар дасан зохицох арга юм.

\subsection{Prompt бичих шилдэг арга барил}

OpenAI-ийн санал болгосон дараах стратегиудыг дагах нь илүү сайн үр дүн өгдөг:

\begin{enumerate}
    \item \textbf{Тодорхой зааварчилгаа өгөх}: Юу хийлгэхээ хоёрдмол утгагүй байдлаар тайлбарлах хэрэгтэй.
    \item \textbf{Persona өгөх}: Загвараас тодорхой дүрд тоглуулж болно. Жишээ нь: "Та туршлагатай программист. Кодыг шалгаад алдаа зааж өг."
    \item \textbf{Жишээ өгөх}: Жишээ өгснөөр хариултын формат болон стилийн хоёрдмол утгыг багасгадаг. Энэ нь few-shot learning гэгддэг.
    \item \textbf{Хангалттай контекст өгөх}: Контекст нь hallucination-ийг багасгадаг. Хэрэв модел шаардлагатай мэдээллээр хангагдаагүй бол өөрийн дотоод мэдлэгтээ найдах бөгөөд энэ нь найдваргүй байж болно.
    \item \textbf{Нарийн төвөгтэй даалгавруудыг хялбар дэд даалгавруудад хувааж өгөх}: Үр дүнтэйгээр бага токен ашиглана.  chain-of-thought prompting гэх техник байдаг.
\end{enumerate}



\subsection{Хамгаалалтын prompt инженерчлэл}

Аппликейшн олон нийтэд ашиглагдах болмогц гурван төрлийн довтолгооноос хамгаалах шаардлагатай:

\begin{itemize}
    \item \textbf{Jailbreaking болон prompt injection}: Моделийн зөвшөөрөөгүй үйлдэл хийлгэх оролдлого.
    \item \textbf{Мэдээлэл задруулах}: Моделийн сургалтын өгөгдөл эсвэл контекстын мэдээллийг задруулах оролдлого.
\end{itemize}

\section{Retrieval-Augmented Generation (RAG)}

RAG буюу Retrieval-Augmented Generation нь моделийн мэдлэгийг гадаад эх сурвалжаар өргөтгөх арга юм. Энэ нь моделийн дотоод мэдлэг нь хангалтгүй, хуучирсан эсвэл алдаатай байх асуудлыг шийддэг.

Хэдийгээр моделийн контекстийн урт тогтмол нэмэгдэж байгаа ч RAG-ийн ач холбогдол алдагдахгүй байна:

\begin{enumerate}
    \item Зарим аппликейшнд өгөгдлийн хэмжээ байнга өсч байдаг. Иймээс RAG-ийг сайтар үнэлж, тасралтгүй хөгжүүлэлт хийснээр бодит хэрэглээнд үр нөлөө алдахгүй байна.
    \item Урт контекстыг боловсруулж чаддаг гэдэг нь тэр контекстыг сайн ашигладаг гэсэн үг биш. Контекст урт байх тусам загвар буруу хэсэгт анхаарал хандуулах магадлал өсдөг.
    \item Контекстын токен бүр нэмэлт өртөг, нэмэлт latency авчирдаг. RAG нь асуулт бүрт зөвхөн хамгийн холбогдолтой мэдээллийг ашиглах боломжийг олгоно.
\end{enumerate}

Anthropic-ийн зөвлөмжөөр хэрэв мэдлэгийн сан 200,000 токеноос бага (ойролцоогоор 500 хуудас бүхий өгөгдөл) бол RAG ашиглалгүй бүх мэдлэгийг prompt-д оруулж болно гэжээ.

\subsection{RAG системийн бүтэц}

RAG систем нь хоёр гол бүрэлдэхүүнтэй:

\begin{enumerate}
    \item \textbf{Retriever (Хайгч)}: Асуултад хамгийн холбогдолтой баримтуудыг олж авдаг.
    \item \textbf{Generator (Үүсгэгч)}: Олж авсан баримтуудыг асуултад ашиглан хариулт үүсгэдэг.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/RAG.png}
    \caption{RAG-ийн бүтэц}
    \label{fig:rag}
\end{figure}

\subsection{Retrieval алгоритмууд}

Хайлтаар олдсон өгөгдөл нь хэр оновчтой байх нь RAG-ийн хамгийн чухал хэсгүүдийн нэг. Өгөгдлийг вектор эсвэл өгөгдлийн бааз руу оруулах хялбар ч үүнээс хайлт хийх нь харьцангуй хүнд байдаг. Хамгийн түгээмэл алдаа нь векторд хэсэгчилж хуваагдахад өгүүлбэрүүд утга зүй бусаар хуваагдаж, хайлт хийх боломжгүй болдог. Иймээс хайлтын алгоритмээ зөв сонгох нь маш чухал.   

\subsubsection{Нэр томьёо суурилсан хайлт (Term-based retrieval)}

Энэ арга нь түлхүүр үгээр баримт хайдаг. Энэ арга Google зэрэг хөтчийн хайлтын алгоритмд ашиглагдсаар ирсэн. Аргууд:

\begin{itemize}
    \item \textbf{TF (Term Frequency)}: Нэр томьёо баримт доор хэдэн удаа гарч байгааг хэмждэг.
    \item \textbf{IDF (Inverse Document Frequency)}: Нэр томьёо хэдэн баримтад гарч байгааг үндэслэн түүний чухлыг хэмждэг.
\end{itemize}

Түгээмэл шийдлүүд: Elasticsearch, BM25. Эдгээр нь inverted index ашигладаг.

\subsubsection{Embedding суурилсан хайлт (Embedding-based retrieval)}

Semantic хайлт гэж нэрлэгддэг энэ арга нь утгын түвшинд холбоотой байдлаар тооцдог. Баримт бүр хуваагдаж vector embedding болгон хувиргагдаж, vector database-д хадгалагдана. Асуулт ирэх үед түүний embedding-тэй хамгийн ойр векторуудыг хайдаг.

\textbf{Vector search алгоритмууд:}

\begin{itemize}
    \item \textbf{k-NN (k-Nearest Neighbors)}: Энгийн арга боловч өгөгдөл их бол удаан.
    \item \textbf{ANN (Approximate Nearest Neighbors)}: Хурдан боловч ойролцоогоор хайна.
    \item \textbf{LSH (Locality-Sensitive Hashing)}: Ижил төстэй векторуудыг нэг bucket-д hash хийнэ.
    \item \textbf{HNSW (Hierarchical Navigable Small World)}: Олон давхаргат граф ашиглана.
    \item \textbf{IVF (Inverted File Index)}: K-means clustering ашиглан векторуудыг бүлэглэнэ.
\end{itemize}

Алдартай vector database-үүд: FAISS, Milvus, Pinecone, Weaviate, Qdrant.

\subsection{RAG-ын үнэлгээ}

RAG системийг үнэлэхэд дараах метрикүүд ашигладаг:

\begin{itemize}
    \item \textbf{Context Precision}: Олж авсан баримтуудын хэдэн хувь нь асуулттай холбоотой вэ?
    \item \textbf{Context Recall}: Асуулттай холбоотой бүх баримтуудын хэдэн хувийг олж авсан бэ?
    \item \textbf{Answer Quality}: Эцсийн хариултын чанар хэр сайн вэ?
\end{itemize}

\subsection{RAG-ыг сайжруулах аргууд}

\begin{enumerate}
    \item \textbf{Chunking стратеги}: Баримтуудыг хэрхэн хэсэглэх нь чухал. Тогтмол урттай хэсэглэх, өгүүлбэр/догол мөрөөр хэсэглэх, semantic хэсэглэх зэрэг аргууд байдаг.
    \item \textbf{Reranking}: Анхны хайлтын үр дүнг дахин эрэмбэлэн илүү нарийвчлалтай болгох.
    \item \textbf{Query rewriting}: Асуултыг дахин найруулж илүү сайн хайлт хийх.
    \item \textbf{Hybrid хайлт}: Нэр томьёо болон embedding суурилсан хайлтыг хослуулах.
    \item \textbf{Contextual retrieval}: Хэсэг бүрийг metadata, түлхүүр үг, холбогдох асуултуудаар баяжуулах.
\end{enumerate}

\subsection{Агентын RAG (Agentic RAG)}

Уламжлалт RAG нь тогтмол workflow ашигладаг. Асуулт ирэх бүрд ижил үйл явц дагана: хайлт хийх, контекст үүсгэх, хариулт үүсгэх. Гэвч энэ арга нь нарийн төвөгтэй даалгавруудад хязгаарлагдмал байдаг.

Агентын RAG нь RAG-ыг илүү динамик, контекст дээр суурилсан болгож хөгжүүлдэг. Тогтмол workflow-д найдахын оронд, агентууд нь бодит цагт ямар өгөгдөл хэрэгтэйгээ, хаанаас олохоо, өгөгдсөн даалгаврын үндсэн дээр асуултаа хэрхэн боловсруулах вэ гэдгийг шийддэг.

\textbf{Агентын RAG vs Уламжлалт RAG:}

\begin{itemize}
    \item \textbf{Динамик хайлт}: Агент нь шаардлагатай бол олон эх сурвалжаас мэдээлэл цуглуулж, асуултаа боловсронгуй болгож, шинэ мэдээлэл гарч ирэхэд дасан зохицож чаддаг.
    \item \textbf{Олон алхам бүхий дүгнэлт}: Агент нь анхны хайлтын үр дүнд үндэслэн дараагийн асуултуудыг үүсгэж, илүү гүнзгий мэдлэг олж авч чаддаг.
    \item \textbf{Хэрэглүүрийн ашиглалт}: Агент нь зөвхөн баримтын хайлт биш, API дуудах, өгөгдлийн сангаас асуулт хийх, тооцоолол хийх зэрэг олон багаж ашиглаж болно.
    \item \textbf{Контекст санах}: Санах ойгоороо агент нь өмнөх асуултууд болон хариултуудыг хадгалж, дараагийн асуултдаа илүү нарийвчлалтай хандаж чаддаг.
\end{itemize}

Жишээлбэл, маркетингийн стратеги боловсруулж байгаа агент нь:
\begin{enumerate}
    \item CRM-ээс харилцагчийн өгөгдөл татаж авна
    \item API ашиглан зах зээлийн чиг хандлагыг цуглуулна
    \item Шинэ мэдээлэл гарч ирэхэд өөрийн аргачлалаа боловсронгуй болгоно
    \item Санах ой болон итераци ашиглан илүү нарийвчлалтай, холбогдолтой үр дүн гаргана
\end{enumerate}

Агентын RAG нь хайлт, дүгнэлт, үйлдлийг нэгтгэдэг.

\section{Хиймэл оюуны агентууд}

\subsection{Агент гэж юу вэ}

Агент гэдэг нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. Хиймэл оюунаар дэмжигдсэн агентууд нь суурь моделийн хүч чадлаар дамжуулан бидний туслах, хамтран ажиллагч, сургагч байж чадна. Агент нь вебсайт бүтээх, өгөгдөл цуглуулах, аялал төлөвлөх, зах зээлийн судалгаа хийх, харилцагчийн данс удирдах, өгөгдөл оруулалтыг автоматжуулах зэрэг олон ажил хэрэгт тусалж чадна.

\subsection{Агентын бүрэлдэхүүн хэсгүүд}

Хиймэл оюун агентыг тодорхойлдог гурван гол зүйл:

\begin{enumerate}
    \item \textbf{Орчин (Environment)}: Агент ажиллах орчин нь түүний хэрэглээний тохиолдлоор тодорхойлогдоно. Жишээ нь: интернэт, гал тогоо, машин(IOT).
    \item \textbf{Үйлдлүүд (Actions)}: Агентын хийж чадах үйлдлүүд нь түүний хандах боломжтой хэрэглүүрүүдээр өргөжинө.
    \item \textbf{Даалгавар (Task)}: Хэрэглэгчээс өгөгдсөн даалгавах.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/agentPre.png}
    \caption{Агентын бүрэлдэхүүн хэсгүүд}
    \label{fig:agentComponents}
\end{figure}

\subsection{Хэрэглүүрүүд (Tools)}

Гадаад хэрэглүүр байхгүй бол агентын чадавхи маш хязгаарлагдмал байх болно. Хэрэглүүр нь агентыг илүү чадварлаг болгодог. Хэрэглүүрийн гурван ангилал:

\subsubsection{Мэдлэг нэмэгдүүлэх хэрэглүүрүүд}

RAG системийн бүрэлдэхүүн хэсгүүд:
\begin{itemize}
    \item Текст retriever
    \item Зураг retriever
    \item SQL executor
    \item Интернэт хайлт API
    \item Дотоод хайлтын системүүд
\end{itemize}

\subsubsection{Чадавх өргөтгөх хэрэглүүрүүд}

\begin{itemize}
    \item \textbf{Тооны машин}: Хиймэл оюун загварууд математикт сул байдаг. Агентд бэлэн тооны машины API өгснөөр тооцоог оновчтой, хурдан, токены бага зарцуулалтаар гүйцэтгэнэ.
    \item \textbf{Хэрэглэгчийн код уншигч}: Код бичиж, ажиллуулах, үр дүн гаргана. Энэ нь кодчилолын туслах, өгөгдөл шинжлэгч, судалгааны туслах боломжийг олгоно.
\end{itemize}

\subsubsection{Бичих үйлдлийн хэрэглүүрүүд}

Зөвхөн унших биш, өөрчлөлт оруулах хэрэглүүрүүд:
\begin{itemize}
    \item Өгөгдлийн санд өгөгдөл нэмэх, засварлах, устгах
    \item Мэйл илгээх
    \item Банкны шилжүүлэг хийх
    \item Календарт тэмдэглэл нэмэх
\end{itemize}

\textbf{Анхааруулга}: Бичих үйлдэл нь өндөр эрсдэлтэй. Code injection довтолгооноос болгоомжлох хэрэгтэй.

\subsection{Төлөвлөлт (Planning)}

Төлөвлөлт нь агентын гол үүрэг бөгөөд дараах үе шаттай:

\begin{enumerate}
    \item \textbf{Төлөвлөгөө үүсгэх (Plan Generation)}: Даалгаврыг гүйцэтгэх дараалсан үйлдлүүдийн төлөвлөгөө гаргах. Үүнийг task decomposition буюу даалгаврыг задлах процесс гэж нэрлэнэ.
    \item \textbf{Эргэцүүлэн бодох ба алдаа засах (Reflection)}: Үүсгэсэн төлөвлөгөөг үнэлэх. Муу байвал шинэ төлөвлөгөө гаргах.
    \item \textbf{Гүйцэтгэл (Execution)}: Төлөвлөгөөнд заасан үйлдлүүдийг хийх. Энэ нь ихэвчлэн функц дуудах үйлдэл хийнэ.
    \item \textbf{Үр дүнг үнэлэх}: Үйлдлийн үр дүнг хүлээн авсны дараа зорилго биелсэн эсэхийг тодорхойлох. Алдааг тодорхойлж засах.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/agentPost.png}
    \caption{Агентын төлөвлөлт}
    \label{fig:agentPlanning}
\end{figure}

\subsection{Суурь загварууд төлөвлөгч болж чадах уу}

Зарим судлаачид LLM нь төлөвлөгч байж чадахгүй гэж үздэг. Учир нь төлөвлөлт нь үндсэндээ хайлтын асуудал бөгөөд autoregressive загвар нь зөвхөн урагш үйлдэл үүсгэж чаддаг гэж үздэг. Гэвч бодит байдал дээр загвар дахин эхлэж өөр зам сонгож чаддаг тул сургалт сайн хийснээр сайн төлөвлөгөө гарч болно.

Төлөвлөлтийг сайжруулах аргууд:

\begin{itemize}
    \item Илүү сайн system prompt бичих, жишээ олноор өгөх
    \item Хэрэглүүрүүдын тайлбарыг илүү сайн бичих
    \item Функцүүдийг хялбарчлах, задлах
    \item Илүү хүчтэй загвар ашиглах
    \item Төлөвлөлтөд зориулж загвар нарийвчлан сургах
\end{itemize}

Мөн хэрэглүүрийг нэмэх нь fine-tuning хийснээс илүү үр дүнтэй гэж үзжээ.

\subsection{Эргэцүүлэн бодох ба алдаа засах}

Хамгийн сайн төлөвлөгөө байнга үнэлэгдэж, тохируулагдах шаардлагатай. Reflection нь агентын амжилтад чухал үүрэг гүйцэтгэнэ. Үүнийг хоёр аргаар хийж болно:

\begin{itemize}
    \item \textbf{Self-critique}: Ижил загвар өөртэйгөө ярилцаж алдааг илрүүлнэ.
    \item \textbf{Тусдаа үнэлэгч}: Тусдаа загвар эсвэл функц үр дүнд оноо өгнө.
\end{itemize}

\subsection{Агентын санах ой}

Хиймэл оюун загвар нь гурван санах ойн механизмтай:

\begin{enumerate}
    \item \textbf{Дотоод мэдлэг (Internal Knowledge)}: Загвар өөрөө нь дотоод мэдээлэлтэй. Сургалтын өгөгдлөөс олж авсан мэдлэг. Моделийг шинэчлэхгүй бол өөрчлөгдөхгүй.
    \item \textbf{Богино хугацааны санах ой (Short-term Memory)}: Моделийн контекст. Өмнөх мессежүүд контекстэд нэмэгдэж болно. Даалгавар дууссаны дараа устдаг. Хурдан боловч багтаамж хязгаарлагдмал.
    \item \textbf{Урт хугацааны санах ой (Long-term Memory)}: Гадаад өгөгдлийн эх сурвалж (RAG). Даалгавруудын хооронд үргэлжилдэг. Өгөгдлийг устгаж болно.
\end{enumerate}

\subsection{Агентын дизайны загварууд}

Агентууд нь зөвхөн үндсэн чадваруудаасаа биш, тэдгээрийн workflow болон харилцааг бүтэцлэх зохиомжийн загваруудаас ч ажил авдаг. Эдгээр загварууд нь агентуудад нарийн төвөгтэй асуудлыг шийдэх, хувьсах орчинд дасан зохицох, үр дүнтэй хамтран ажиллах боломжийг олгодог.
Жишээлбэл үнэтэй моделийг үнэтэй процессд үлдээгээд, хямдхан GPT-2 мэтийн моделээр асуултын чиглүүлэг хийж болно. Иймээс мульти-агент байх нь практикт тохиромжтой элбэг арга зам юм.

\subsubsection{Эргэцүүлэн бодох (Reflection)}

Reflection нь агентуудад өөрсдийн шийдвэрийг үнэлж, үйлдэл хийх эсвэл эцсийн хариулт өгөхөөсөө өмнө гаралтаа сайжруулах боломжийг олгодог. Энэ чадвар нь агентуудад алдаагаа олж засах, дүгнэлтээ боловсронгуй болгох, илүү өндөр чанартай үр дүн гаргах боломжийг олгоно.

Жишээлбэл, код бичиж байгаа агент нь эхлээд код үүсгээд, дараа нь өөрөө тухайн кодыг шалгаж, алдаа олж, сайжруулалт хийснийхээ дараа хэрэглэгчид хүргэнэ. Энэ нь эцсийн үр дүнгийн чанарыг мэдэгдэхүйц сайжруулдаг.

\subsubsection{Хэрэглүүрийн хэрэглээ (Tool Use)}

Гадаад хэрэглүүрүүдтэй холбогдох нь агентын функционалыг өргөжүүлж, өгөгдөл авах, үйл явцыг автоматжуулах, эсвэл тодорхой workflow-г гүйцэтгэх зэрэг даалгаврыг гүйцэтгэх боломжийг олгоно. Энэ нь математик тооцоолол эсвэл өгөгдлийн сангийн асуулга гэх мэт нарийвчлал шаардлагатай үйлдлүүдэд онцгой ач холбогдолтой.

Хэрэглүүрийн хэрэглээ нь уян хатан шийдвэр гаргалт болон таамагладаг, найдвартай гүйцэтгэлийн хоорондох хоосон зайг нөхдөг.

\subsubsection{Төлөвлөлт (Planning)}

Төлөвлөлтийн чадвартай агентууд нь өндөр түвшний зорилгуудыг үйлдэл хийх боломжтой алхмуудад задалж, даалгавруудыг логик дарааллаар зохион байгуулж чаддаг. Энэ дизайны загвар нь олон алхам бүхий асуудлыг шийдэх эсвэл хамааралтай workflow-г удирдахад чухал юм.

Жишээлбэл, аялал төлөвлөх агент нь дараах төлөвлөгөө гаргаж болно:
\begin{enumerate}
    \item Нислэг хайх
    \item Зочид буудал захиалах
    \item Үзвэр сервисийн цэгүүдийг судлах
    \item Өдөр бүрийн маршрут үүсгэх
\end{enumerate}

\subsubsection{Олон агентын хамтын ажиллагаа (Multi-Agent Collaboration)}

Олон агентын системүүд нь асуудлыг шийдэхэд модуляр арга барил ашигладаг. Иймээс тодорхой даалгавруудыг мэргэшсэн агентуудад хуваарилдаг. Энэ арга нь уян хатан байдлыг санал болгодог. Мөн үр ашигтай байдлыг сайжруулахын тулд даалгаварт агентуудад илүү жижиг хэлний моделууд (SLMs) ашиглаж болно.

Модульчлагдсан зохиомж нь тэдгээрийн контекстыг тусгай даалгаврууддаа чиглүүлэх замаар агент тус бүрийн нарийн төвөгтэй байдлыг багасгадаг. Хамтран ажиллахаар эдгээр мэргэшсэн агентууд мэдээлэл солилцож, хариуцлагыг хуваарилж, нарийн төвөгтэй сорилтуудыг илүү үр дүнтэй шийдэхийн тулд үйлдлүүдээ зохицуулдаг.

Уламжлалт системийн зохиомжтай адилаар, асуудлыг модульчлагдсан бүрэлдэхүүн хэсгүүдэд задлах нь тэднийг засварлах, өргөжүүлэх, дасан зохицуулахад илүү хялбар болгодог.

\section{Хиймэл оюун инженерчлэлийн хэрэгжүүлэлт}

Суурь загварууд ашиглан аппликейшн хөгжүүлэх нь уламжлалт ML инженерчлэлээс гурван чухал талаараа ялгаатай:

\begin{enumerate}
    \item \textbf{Моделийн дасан зохицуулалт}: Өөрөө модел сургахын оронд бусдын сургасан моделийг ашиглана. Иймээс уг моделийг дасан зохицуулах нь чухал болсон.
    \item \textbf{Optimization}: Суурь модел нь илүү их тооцоолол шаарддаг, хоцрогдол өндөр. Үр ашигтай сургалтын төлөө inference optimization хийснээр бага хүчтэй компьютерээр, бага хугацаанд гүйцэтгүүлж болно. Иймээс бэлэн суурь моделийн API ашиглах уу, эсвэл өөрөө агентээ серверт байршуулах уу гэдгийг шийдэж болно.
    \item \textbf{Нээлттэй гаралт}: Загварууд нээлттэй төгсгөлтэй гаралт үүсгэдэг тул үнэлгээ хийхэд илүү бэрхшээлтэй. Дундах процессийг мэдэж болдоггүй.
\end{enumerate}

\textbf{Загвар дасан зохицуулалтын хоёр гол арга:}

\begin{itemize}
    \item \textbf{Prompt-based techniques}: Моделийн жин өөрчлөхгүйгээр зааварчилгаа, контекст өгч дасан зохицуулна. Хялбар, цөөн өгөгдөл шаардана. Prompt engineering энд хамаарна.
    \item \textbf{Finetuning}: Моделийн жинг өөрчилж дасан зохицуулна. Илүү нарийн төвөгтэй, илүү их өгөгдөл шаардана. Гэвч чанар, хоцрогдол, өртгийг мэдэгдэхүйц сайжруулж чадна.
    \item \textbf{Хэрэглүүр өгөх}: Хэрэглүүр өгснөөр уг даалгаврыг маш онончтой, хоцрогдол багатайгаар, зардлын өртгийг мэдэгдэхүйц сайжруулж чадна.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/charAIAgent.png}
    \caption{Хиймэл оюуны аппликейшн}
    \label{fig:charAIAgent}
\end{figure}


\chapter{Микросервис архитектур}

\section{Монолитоос микросервис рүү}

\subsection{Монолитын эрин үе}

Вэб аппликейшн хөгжүүлэлтийн эхэн үед бүх зүйлийг монолит хэлбэрээр бүтээдэг байсан. Бүх бизнес логик, өгөгдлийн үйлдлүүд нэг том, нягт нэгдсэн кодын санд амьдардаг байв. Монолитууд нь хөгжүүлэх, нэвтрүүлэлт хийхэд энгийн байсан.

\subsection{Монолитыг өргөжүүлэх сорилт}

Гэвч аппликейшнууд томрох тусам асуудлууд нэмэгдсэн. Монолитыг өргөжүүлэх нь бүх зүйлийг нэгтгэсэн байдлаар өргөжүүлдэг. Нэг модульд хийсэн жижиг өөрчлөлт кодын санд орсноор энэ нь шинэчлэлтийг удаашруулж, унахад эрсдэлтэй болгодог. Өөр өөр функц дээр ажиллаж байгаа багууд байнга бие биенийхээ кодод холбогдож, алдаа нэмж, хөгжлийг удаашруулж, алдаа гарах эрсдэлийг нэмэгдүүлсээр ирсэн.

Монолит архитектураас эхэлсэн компаниуд эцэст нь эдгээр асуудлууд тулгарсан. Хурдан үйл ажиллагаагаа явуулахад багууд  системийг шинэчлэх, турших хүртэл хүлээх шаардлагатай байв. Энэ нь компаний бизнесийн үйл ажиллагаанд үндсэн саад болов.

\subsection{Микросервис рүү шилжих}

Эдгээр хязгаарлалтаас ангижрахын тулд компаниуд микросервис архитектур руу шилжүүлсэн. Энэ өөрчлөлт нь багуудад салангид байдлаар өөрчлөлтийг хурдан deploy хийх, аппликейшнийг дахин deploy хийхгүйгээр шинэчлэл гаргах боломжийг олгосон. Микросервис рүү шилжих нь зөвхөн өргөжүүлэх чадварыг сайжруулаад зогсохгүй, багуудад бие даасан байдал өгч, зохицуулалтын ачааллыг бууруулж, инновацийг хурдасгасан.

\subsection{Микросервисийн тодорхойлолт}

Микросервис архитектур нь програм хангамжийг хөгжүүлэх арга бөгөөд аппликейшныг жижиг, бие даасан сервисүүдэд хувааж хөгжүүлдэг.

Микросервисийн гол онцлогууд:

\begin{itemize}
    \item \textbf{Бие даасан байдал}: Микросервис бүр бие даасан үүрэгтэй, өөрийн өгөгдлийн сантай.
    \item \textbf{Уян хатан хөгжүүлэлт}: Өөр өөр багууд өөр өөр технологи, хэл ашиглаж хөгжүүлж болно.
    \item \textbf{Өргөжих чадвар}: Зөвхөн шаардлагатай сервисийг л өргөжүүлж болно.
    \item \textbf{Найдвартай байдал}: Нэг сервис унавал бусад сервисүүд ажиллаж үргэлжлэнэ.
\end{itemize}

\section{Микросервисийн давуу тал}

\begin{enumerate}
    \item \textbf{Технологийн олон янз байдал}: Сервис бүр өөрийн хэрэгцээнд тохирсон технологи сонгож болно. Жишээ нь: нэг сервис Python, нөгөө нь Go, өөр нь Node.js ашиглаж болно.
    \item \textbf{Багуудын бие даасан ажиллагаа}: Баг бүр өөрийн сервисийг бие даан хөгжүүлж, deploy хийж чадна.
    \item \textbf{Хурдан deployment}: Том системийг бүхэлд нь дахин deploy хийх шаардлагагүй. Зөвхөн өөрчлөгдсөн сервисийг л deploy хийнэ.
    \item \textbf{Илүү сайн өргөжих чадвар}: Ачаалал их сервисийг л өргөжүүлэх нь бүх системийг өргөжүүлэхээс үр ашигтай.
    \item \textbf{Алдааны тусгаарлалт}: Нэг сервисийн алдаа бусад сервисд дамжихгүй.
\end{enumerate}

\section{Микросервисийн сорилтууд}

Микросервис архитектур олон давуу талтай ч дараах сорилтуудтай:

\begin{enumerate}
    \item \textbf{Нарийн төвөгтэй байдал}: Олон сервисүүдийг удирдах, тэдгээрийн харилцааг хянах нь монолит системээс илүү төвөгтэй.
    \item \textbf{Өгөгдлийн тогтмол байдал}: Сервис бүр өөрийн өгөгдлийн сантай байх нь өгөгдлийн нийцтэй, уялдаатай байдлыг хангахад хэцүү болгодог.
    \item \textbf{Сүлжээний хоцрогдол}: Сервисүүд хоорондоо сүлжээгээр харилцах нь нэмэлт хоцрогдол авчирна.
    \item \textbf{Алдаа илрүүлэх хэцүү байдал}: Олон сервисийгээр дамжин явах хүсэлтийн алдааг олох, засах хэцүү.
    \item \textbf{Сервис хоорондын харилцаа}: Сервисүүд хэрхэн харилцах, мэдээлэл солилцох нь нарийн асуудал.
    \item \textbf{Transaction удирдлага}: Олон сервисийгээр transaction явуулах нь өгөгдлийн сан түгжигдэж асуудал гарах эрсдэлтэй.
\end{enumerate}

\section{Микросервис хоорондын харилцаа}

Микросервисүүд хоорондоо хоёр гол аргаар харилцдаг:

\subsection{Синхрон харилцаа (Synchronous Communication)}

HTTP/REST API эсвэл gRPC ашиглан шууд хүсэлт илгээж хариу хүлээнэ. Энэ нь хялбар боловч:
\begin{itemize}
    \item Tight coupling үүсгэдэг
    \item Нэг сервис унавал бусад сервисүүд алдаа гаргана
    \item Latency нэмэгддэг
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/microservice.png}
    \caption{Синхрон микросервис}
    \label{fig:microservicesync}
\end{figure}

NxM-ээр сервисийн холболт нэмэгдэх учир үүнийг удирдахад маш хүндрэлтэй болно.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/conMonolith.png}
    \caption{Синхрон микросервисийн NxM холбоо}
    \label{fig:conmicroservicesync}
\end{figure}

\subsection{Асинхрон харилцаа (Asynchronous Communication)}

Message queue (RabbitMQ, Kafka) ашиглан мессеж солилцоно. Энэ нь:
\begin{itemize}
    \item Loose coupling үүсгэнэ
    \item Илүү найдвартай
    \item Илүү төвөгтэй
\end{itemize}

\section{Event-Driven архитектур}

\subsection{Event-Driven архитектур гэж юу вэ}

Микросервисүүд гарч ирснээр шинэ сорилт бий болсон: эдгээр сервисүүд хэрхэн үр дүнтэй харилцах вэ? Хэрэв бид сервисүүдийг шууд RPC эсвэл API-ээр холбовол бид асар том хамаарлын сүлжээ үүсгэнэ. Хэрэв нэг сервис унавал энэ нь холбогдсон замын дагуух бүх node-д нөлөөлнө. Мөн bottleneck маш ихээр үүснэ.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/microserviceEda.png}
    \caption{Асинхрон микросервис}
    \label{fig:microserviceasync}
\end{figure}

Үйл явдлаар удирдагдах архитектур (Event-Driven Architecture, EDA) нь энэ асуудлыг шийдсэн. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Сервисүүд бие биенийхээ хүлээхгүй. Бодит цагт юу болж байгааг мэдээд хариу үйлдэл үзүүлдэг.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/conMicroservice.png}
    \caption{Асинхрон микросервис}
    \label{fig:microserviceaconsync}
\end{figure}

\subsection{EDA-ын давуу тал}

\begin{enumerate}
    \item \textbf{Салангид байдал (Decoupling)}: Сервисүүд үйл явдлаар харилцдаг тул тэд бие биенээсээ хараат бус байна. Нэг сервис өөрчлөгдөх эсвэл унах нь бусад сервисд шууд нөлөөлөхгүй.
    \item \textbf{Өргөжүүлэх чадвар}: Сервис бүр үйл явдлыг бие даан боловсруулах тул системийг өргөжүүлэх илүү хялбар.
    \item \textbf{Уян хатан байдал}: Шинэ сервис нэмэх эсвэл одоо байгаа сервисийг өөрчлөх нь бусад сервисд өөрчлөлт шаардахгүй.
    \item \textbf{Бодит цагийн боловсруулалт}: Үйл явдлууд тэр даруйдаа боловсруулагдах тул систем нь өөрчлөлтөд хурдан хариу үйлдэл үзүүлнэ.
\end{enumerate}

\subsection{Apache Kafka: Event-Driven архитектурын хүчирхэг суурь}

Apache Kafka нь салангид, өндөр дамжуулалттай, бага хоцрогдолтой Event-Driven архитектурын төв мэдрэлийн систем болж чаддаг.

\subsubsection{Kafka-ийн үндсэн ойлголтууд}

\begin{itemize}
    \item \textbf{Topic}: Үйл явдлуудыг ангилах логик channel. Жишээ нь: "user-events", "order-events"
    \item \textbf{Producer}: Үйл явдлыг topic руу бичдэг аппликейшн
    \item \textbf{Consumer}: Topic-оос үйл явдлыг уншдаг аппликейшн
    \item \textbf{Partition}: Topic-ийг өргөжүүлэх, параллель боловсруулалт хийх боломжтой болгодог
    \item \textbf{Consumer Group}: Олон consumer нэг багаар ажиллаж ачааллыг хуваарилдаг
\end{itemize}

\subsubsection{Kafka-ийн давуу тал}

\begin{enumerate}
    \item \textbf{Хэвтээ өргөжих чадвар}: Kafka-ийн салангид зохиомж нь саадгүйгээр шинэ агент эсвэл consumer нэмэх боломжийг олгоно.
    \item \textbf{Бага хоцрогдол}: Бодит цагийн үйл явдал боловсруулалт нь агентуудад өөрчлөлтөд шууд хариу үйлдэл үзүүлэх боломжийг олгоно.
    \item \textbf{Loose Coupling}: Topic-уудаар харилцах нь агентууд хараат бус, өргөжүүлэх боломжтой байхыг баталгаажуулна.
    \item \textbf{Үйл явдлын хадгалалт}: Тогтвортой мессежийн хадгалалт нь өгөгдөл дамжилтын явцад алга болохгүй гэдгийг баталгаажуулна.
    \item \textbf{Дахин тоглуулах боломж (Replayability)}: Kafka нь үл хөдлөх салангид log учраас үйл явдал бүр хадгалагдаж, debug, үнэлгээ, дахин сургалтад дахин тоглуулж болно.
\end{enumerate}

\subsection{Apache Flink: Streaming боловсруулалтын хөдөлгүүр}

Apache Flink нь stateful тооцоолол, үйл явдал цагийн боловсруулалт хийх чадвартай салангид stream processing framework юм. Flink нь Kafka-тай хамт ашиглах замаар хүчирхэг бодит цагийн өгөгдөл боловсруулалтын конвейер бүтээх боломжийг олгоно.

\subsubsection{Flink-ийн давуу тал}

\begin{itemize}
    \item \textbf{Stateful боловсруулалт}: Flink нь state-г найдвартай удирдаж, нарийн төвөгтэй тооцоолол хийх боломжийг олгоно.
    \item \textbf{Бодит цагийн боловмруулалт}: Үйл явдлын цаг дээр үндэслэн бодит цагийн шинжилгээ хийх.
    \item \textbf{Өндөр дамжуулалт}: Секундэд сая сая үйл явдлыг боловсруулж чаддаг.
    \item \textbf{Exactly-once семантик}: Мэдээлэл нэг удаа л боловсруулагдахыг баталгаажуулна.
\end{itemize}

\subsubsection{Flink AI Inference}

Flink нь LLM-тэй ажиллах чадвартай. Flink AI inference нь өгөгдлийг авч, LLM рүү илгээж, хариу авах боломжийг олгоно. Энэ нь төлөвлөгч агентыг Flink app болгон хөгжүүлэх боломжийг олгодог.

Жишээлбэл:
\begin{itemize}
    \item Kafka topic-оос үйл явдал уншина
    \item LLM ашиглан контекст ойлгох, төлөвлөгөө гаргах
    \item Үр дүнг өөр Kafka topic руу бичих
    \item Бусад агентууд энэ үр дүнг уншиж гүйцэтгэнэ
\end{itemize}

\subsubsection{Flink болон RAG}

Hallucination-ийг багасгахын тулд LLM-ийг бодит өгөгдөлд суурилуулах хэрэгтэй. Flink нь RAG pattern-ийг бүтээхэд тусална.

\begin{enumerate}
    \item Flink нь өгөгдлийг боловсруулна
    \item LLM inference ашиглан өгөгдлийг embedding болгон хөрвүүлнэ
    \item Embedding-ыг Kafka topic руу бичнэ
    \item Kafka Connect ашиглан vector database руу синхрончлоно
    \item Агентууд RAG ашиглан бодит өгөгдөл дээр суурилсан хариулт өгнө
\end{enumerate}

\subsection{Агентууд ба EDA}

Хиймэл оюун агентуудыг өргөжүүлэх нь үндсэндээ салангид системийн асуудал юм. Агентууд нь шийдвэр гаргаж, үйлдэл хийхийн тулд олон эх сурвалж, бусад агентууд, хэрэглүүрүүд, гадаад системүүдээс мэдээлэл цуглуулах шаардлагатай.

\textbf{Агентууд яагаад EDA шаарддаг:}

\begin{itemize}
    \item \textbf{Асинхрон шинж чанар}: Агентууд нь хүн шиг ажилладаг. Агент нь олон эх сурвалжаас мэдээлэл цуглуулж, өгөгдлийг шинжилж, үйлдэл хийхээсээ өмнө шийдвэр гаргах хэрэгтэй. Эдгээр үйл явцууд нь асинхрон шинжтэй.
        \item \textbf{Мэдээллийн хамаарал}: Микросервисүүд ихэвчлэн салангид үйлдлүүдийг боловсруулдаг бол агентууд нь контекст баялаг, хуваалцсан мэдээлэлд найддаг. Энэ нь хамаарлыг удирдах, бодит цагийн өгөгдлийн урсгалыг баталгаажуулах онцгой шаардлагыг бий болгоно.
        \item \textbf{Олон хэрэглэгчдэд үйлчлэх}: Агентын гаралт нь зөвхөн AI app рүү биш, тэд өгөгдлийн сан, CRM, CDP, customer success платформ зэрэг бусад чухал системүүд рүү хандаж, лог хадгалж болно.
\end{itemize}

Агентуудыг RPC болон API-аар холбож болно, гэхдээ энэ нь нягт холбогдсон системүүд бий болгодог. Энэхүү нягт холбоос нь өргөжүүлэх, дасан зохицох, эсвэл ижил өгөгдлийн олон хэрэглэгчдийг дэмжихэд хэцүү болгодог. Агентууд нь уян хатан байдал шаарддаг. Тэдний гаралт нь бусад агентууд, сервисүүд, платформуудад хатуу хамааралгүйгээр үр дүнгүй дамжих ёстой.

\chapter{Асуудлын тодорхойлолт}

\section{Микросервис архитектур дахь сорилтууд}

Микросервис архитектурт дараах гол асуудлууд байдаг.

\subsection{Сервис хоорондын нарийн төвөгтэй логик}

Хэрэглэгчийн нэг хүсэлт нь олон сервисийгээр дамжин явах ёстой. Жишээ нь онлайн худалдааны систем дээр:

\begin{enumerate}
    \item Хэрэглэгч бараа захиална
    \item Захиалгын сервис захиалга үүсгэнэ
    \item Агуулахын сервисээс бараа байгаа эсэхийг шалгана
    \item Төлбөрийн сервисийгээр төлбөр хийнэ
    \item Хүргэлтийн сервисд мэдэгдэнэ
    \item Notification сервисийгээр хэрэглэгчид мэдэгдэнэ
\end{enumerate}

Эдгээр алхам бүрт алдаа гарч болох бөгөөд алдаа гарах үед юу хийх нь тодорхойгүй байдаг. Уламжлалт аргаар энэ workflow-г хатуу кодлох нь:

\begin{itemize}
    \item Уян хатан бус
    \item Шинэ сервис нэмэхэд хэцүү
    \item Алдаа засалт хэцүү
    \item Бизнес дүрмийн өөрчлөлт хийхэд том код өөрчлөлт шаардлагатай
\end{itemize}

\subsection{Өгөгдлийн нэгтгэл ба шинжилгээ}

Микросервис бүр өөрийн өгөгдлийн сантай байх нь:

\begin{itemize}
    \item Олон өгөгдлийн сангийн өгөгдлийг нэгтгэх хэцүү
    \item Cross-service шинжилгээ хийх төвөгтэй
    \item Тайлангийн системд өгөгдөл цуглуулах асуудалтай
    \item Хэрэглэгчийн бүрэн дүр төрхийг харах хэцүү
\end{itemize}

\subsection{Динамик routing ба шийдвэр гаргалт}

Хэрэглэгчийн хүсэлтийг аль сервис рүү чиглүүлэх, хэдэн сервисийг дуудах шаардлагатайг тодорхойлох нь:

\begin{itemize}
    \item Бизнес логик өөрчлөгдөх бүрд код өөрчлөх шаардлагатай
    \item A/B testing хийхэд төвөгтэй
    \item Орчны өөрчлөлтөд дасан зохицох чадваргүй
\end{itemize}

\subsection{Мониторинг ба алдаа илрүүлэлт}

\begin{itemize}
    \item Олон сервисийн логийг нэгтгэх хэцүү
    \item Хэрэглэгчийн хүсэлт аль сеовисд алдаа гаргасныг тодорхойлох хэцүү
    \item Алдааны язгуур шалтгааныг олох төвөгтэй
\end{itemize}

\subsection{Монолит Агент}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/agentMonolith.png}
    \caption{Монолит Агент}
    \label{fig:agentmonolith}
\end{figure}

Агент суурилсан систем хөгжүүлэхдээ анхны хувилбар нь ихэвчлэн монолит хэлбэртэй байдаг. Controller, Planner, SQL Handler, Streaming Handler зэрэг агентууд нэг аппликейшн дотор ажилладаг. Энэ арга нь эхэндээ ажилладаг ч дараах асуудлуудтай:

\begin{itemize}
    \item \textbf{Deployment хамаарал}: Planner-ийн v2 гаргахын тулд бүх системийг дахин deploy хийх шаардлагатай.
    \item \textbf{Hardware хязгаарлалт}: Planner агент нь LLM ашиглаж GPU шаарддаг бол SQL Handler нь жижиг SLM ашиглан CPU дээр ажиллаж болно. Монолит систем энэ хоёрыг салгаж чадахгүй.
    \item \textbf{Өргөжүүлэх боломжгүй}: Нэг агентад их ачаалал ирсэн ч бүх системийг өргөжүүлэх шаардлагатай болно.
    \item \textbf{Нягт холбоос}: Агентууд хоорондоо шууд дуудлагаар холбогдсон байх нь алдааны дамжлага, хоцрогдлын асуудал бий болгоно.
\end{itemize}



\section{Хиймэл оюун агентууд хэрхэн туслах вэ}

Хиймэл оюун агентууд нь дээрх асуудлуудыг дараах аргаар шийдэж чадна:

\begin{enumerate}
    \item \textbf{УIntelligent Orchestrator}: Агент нь хүсэлтийг ойлгож, аль сервисүүдийг дуудах хэрэгтэй, ямар дарааллаар дуудах, алдаа гарвал яах талаар төлөвлөгөө гарган гүйцэтгэнэ.
    \item \textbf{Контекст бүтээгч (Context Builder)}: RAG ашиглан олон өгөгдлийн сангийн мэдээллийг нэгтгэж, ойлгомжтой контекст бүтээнэ.
    \item \textbf{Динамик routing}: Хэрэглэгчийн хүсэлтийг ойлгож, хамгийн тохиромжтой сервис рүү чиглүүлнэ.
    \item \textbf{Data Analyst}: Олон сервисийн өгөгдлийг цуглуулж, шинжилж, ойлгомжтой тайлан гаргана.
    \item \textbf{Алдаа засагч (Error Handler)}: Алдаа гарсан тохиолдолд шалтгааныг олж, засах төлөвлөгөө санал болгоно.
\end{enumerate}

\section{Event-Driven архитектурын шаардлага}

Агентуудыг үр дүнтэй өргөжүүлэхийн тулд тэдгээрийг микросервис болгон салгах шаардлагатай. Гэхдээ микросервисүүд нь RPC эсвэл API дуудлагаар харилцах нь дахин монолиттой адилхан асуудал үүсгэнэ.

Event-Driven архитектур (EDA) нь дараах асуудлуудыг шийднэ:

\begin{itemize}
    \item \textbf{Салангид байдал}: Агентууд хоорондоо Kafka topics-оор харилцах тул шууд хамаарал байхгүй.
    \item \textbf{Асинхрон}: Агентууд бие биенийхээ хүлээхгүй, бодит цагт хариу үйлдэл үзүүлдэг.
    \item \textbf{Олон хэрэглэгч}: Нэг агентын гаралтыг олон агент, систем ашиглаж болно.
    \item \textbf{Өргөжих чадвар}: Агент бүр бие даан өргөжиж болно.
    \item \textbf{Найдвартай байдал}: Kafka-ийн үйл явдлын хадгалалт нь мэдээлэл алдагдахгүйг баталгаажуулна.
\end{itemize}

\chapter{Шийдэл ба санал болгож буй загвар}

\section{Хиймэл оюун агент суурилсан микросервис архитектур}

Энэхүү судалгаанд микросервис архитектурт хиймэл оюун агентуудыг нэвтрүүлэх моделийг санал болгож байна. Уг загвар нь дараах гол бүрэлдэхүүнтэй:

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/agentMicroservice.png}
    \caption{Хиймэл оюун агент суурилсан микросервис}
    \label{fig:agentmicroservice}
\end{figure}

\subsection{Агентын архитектур}

\subsubsection{Orchestrator Agent}

Энэ агент нь хэрэглэгчийн хүсэлтийг хүлээн авч, ямар сервисүүдийг дуудах, ямар дарааллаар дуудах талаар төлөвлөгөө гаргадаг. Үүний бүтэц:

\begin{itemize}
    \item \textbf{Intent Understanding}: LLM ашиглан хэрэглэгчийн хүсэлтийг ойлгох
    \item \textbf{Service Discovery}: Боломжтой сервисүүдийн жагсаалтыг мэдэх
    \item \textbf{Execution Planning}: Дуудах сервисүүдийн дараалал, параметрүүдийг тодорхойлох
    \item \textbf{Error Handling}: Алдаа гарвал алдааг засах төлөвлөгөө гаргах
\end{itemize}

\subsubsection{Service Agents}

Сервис бүр өөрийн агенттай байж болно. Энэ агент нь:

\begin{itemize}
    \item Сервисийн API-г тайлбарлаж өгнө
    \item Хүсэлтийг тухайн сервисд тохирсон форматруу хөрвүүлнэ
    \item Үр дүнг ойлгомжтой хэлбэрт хөрвүүлнө
    \item Сервисийн статус, чадавхийг мэдээлнэ
\end{itemize}

\subsubsection{Knowledge Agent}

RAG систем ашиглан:

\begin{itemize}
    \item Сервисүүдийн баримт бичгийг хадгална
    \item Өмнөх хүсэлт, хариултуудыг санана
    \item Бизнес дүрэм, журмуудыг мэднэ
    \item API спецификацийг хадгална
\end{itemize}

\subsubsection{Monitoring Agent}

\begin{itemize}
    \item Логуудыг цуглуулж, шинжилнэ
    \item Алдаануудыг илрүүлнэ
    \item Системийн эрүүл байдлыг хянана
    \item Сайжруулах санал өгнө
\end{itemize}

\subsection{Системийн архитектур}

Санал болгож буй Event-Driven архитектур нь:

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/charMicroservice.png}
    \caption{Хиймэл оюун агент суурилсан микросервис Event-Driven архитектур}
    \label{fig:charmicroservice}
\end{figure}


\subsection{Kafka Topics ба хамаарал}

Системд дараах Kafka topics ашиглагдана:

\begin{itemize}
    \item \textbf{user-requests}: Хэрэглэгчийн хүсэлтүүд
    \item \textbf{planning-tasks}: Төлөвлөгөө гаргах даалгаврууд
    \item \textbf{execution-plans}: Гүйцэтгэх төлөвлөгөөнүүд
    \item \textbf{knowledge-queries}: RAG хайлтын асуултууд
    \item \textbf{knowledge-results}: RAG-ийн үр дүнгүүд
    \item \textbf{service-calls}: Микросервис дуудлагууд
    \item \textbf{service-results}: Микросервисийн үр дүнгүүд
    \item \textbf{user-responses}: Хэрэглэгчид буцах хариултууд
    \item \textbf{monitoring-events}: Системийн логууд ба мониторинг
\end{itemize}

\subsection{Event-Driven Workflow}

\begin{enumerate}
    \item \textbf{Хүсэлт publish}: API Gateway хүсэлтийг \texttt{user-requests} topic руу бичнэ
    \item \textbf{Orchestrator consume}: Orchestrator Agent үйл явдлыг уншиж, intent-ийг ойлгоно
    \item \textbf{Төлөвлөлт үйл явдал}: Хэрэв төлөвлөлт хэрэгтэй бол \texttt{planning-tasks} topic руу үйл явдал илгээнэ
    \item \textbf{Flink Planning}: Planner Agent (Flink app) үйл явдлыг уншиж, LLM ашиглан төлөвлөгөө гаргаж, \texttt{execution-plans} topic руу бичнэ
    \item \textbf{Knowledge хайлт}: Orchestrator нь \texttt{knowledge-queries} topic руу хайлтын үйл явдал илгээнэ
    \item \textbf{RAG боловсруулалт}: Knowledge Agent үйл явдлыг уншиж, vector хайлт хийж, үр дүнг \texttt{knowledge-results} topic руу бичнэ
    \item \textbf{Service дуудлага}: Төлөвлөгөөний дагуу \texttt{service-calls} topic руу үйл явдлууд илгээгдэнэ
    \item \textbf{Параллель гүйцэтгэл}: Service Agent-ууд параллель байдлаар үйл явдлуудыг уншиж, микросервисүүдийг дуудаж, үр дүнг \texttt{service-results} topic руу бичнэ
    \item \textbf{Aggregation}: Response Aggregator бүх үр дүнг цуглуулж нэгтгэнэ
    \item \textbf{Хариулт publish}: Эцсийн хариултыг \texttt{user-responses} topic руу бичнэ
    \item \textbf{Хэрэглэгчид хүргэх}: API Gateway хариултыг уншиж хэрэглэгчид буцаана
    \item \textbf{Мониторинг}: Бүх агент \texttt{monitoring-events} topic руу лог мэдээлэл бичнэ
\end{enumerate}

\textbf{Асинхрон онцлог:} Агентууд бие биенийхээ хүлээхгүй. Тэд үйл явдлыг publish хийж, өөрийн ажилдаа үргэлжлүүлнэ. Энэ нь системийг өргөжүүлэх боломжтой, найдвартай болгодог.

\section{Prompt engineering}

\subsection{Prompt загвар}

Orchestrator Agent-ийн system prompt:

\begin{verbatim}
Та микросервис орчуулагч агент. Таны үүрэг:
1. Хэрэглэгчийн хүсэлтийг ойлгох
2. Дуудах сервисүүдийг төлөвлөх
3. Үр дүнг нэгтгэж хэрэглэгчид ойлгомжтой байдлаар хариулах

Боломжтой сервисүүд:
{service_list}

Бизнес дүрмүүд:
{business_rules}
\end{verbatim}

\subsection{Service Registry}

Сервис бүрийг JSON форматаар тодорхойлно:

\begin{lstlisting}[language=Python, caption=Service Registry Example]
{
  "name": "user-service",
  "description": "Хэрэглэгчийн мэдээлэл удирдах сервис",
  "endpoints": [
    {
      "path": "/users/{id}",
      "method": "GET",
      "description": "Хэрэглэгчийн мэдээлэл авах",
      "parameters": {
        "id": "Хэрэглэгчийн ID"
      }
    }
  ]
}
\end{lstlisting}

\subsection{RAG Систем}

Knowledge Agent нь vector database ашиглана:

\begin{itemize}
    \item \textbf{Index}: API баримт бичиг, өмнөх хүсэлтүүд, бизнес дүрэм
    \item \textbf{Embedding Model}: Sentence-Transformers эсвэл OpenAI embeddings
    \item \textbf{Vector DB}: FAISS, Pinecone, эсвэл Qdrant
    \item \textbf{Retrieval}: Асуулт бүрт top-k хамгийн холбогдолтой баримтуудыг олох
\end{itemize}

\subsection{Алдаа}

Алдаа гарах үед агент:

\begin{enumerate}
    \item Алдааны төрөл, шалтгааныг тодорхойлно
    \item Retry стратеги сонгоно (exponential backoff)
    \item Альтернатив сервис байгаа эсэхийг шалгана
    \item Хэрэглэгчид ойлгомжтой алдааны мэдэгдэл өгнө
    \item Алдааны логийг хадгална
\end{enumerate}

\section{Моделийн давуу тал}

\subsection{Хиймэл оюун агентын онцлогууд}

\begin{enumerate}
    \item \textbf{Натурал хэл интерфейс}: Хэрэглэгч натурал хэл дээр хүсэлт илгээж болно
    \item \textbf{Уян хатан орчуулалт}: Бизнес дүрэм өөрчлөгдөхөд код өөрчлөх шаардлагагүй
    \item \textbf{Ухаалаг алдаа засалт}: Агент өөрөө алдааг таньж, засах арга санал болгоно
    \item \textbf{Түүх санах}: Өмнөх харилцааг санаж, контекст хадгална
    \item \textbf{Өгөгдлийн нэгтгэл}: Олон сервисийн өгөгдлийг нэгтгэж ойлгомжтой болгоно
    \item \textbf{Өөрөө сайжрах}: Логуудаас суралцаж, цаашид илүү сайн ажиллана
\end{enumerate}

\subsection{Event-Driven давуу тал}

\begin{enumerate}
    \item \textbf{Салангид байдал (Decoupling)}:
    \begin{itemize}
        \item Агентууд хоорондоо шууд хамааралгүй
        \item Нэг агент унах нь бусдад шууд нөлөөлөхгүй
        \item Агентыг өөрчлөх, солих хялбар
    \end{itemize}
    
    \item \textbf{Өргөжүүлэх чадвар (Scalability)}:
    \begin{itemize}
        \item Агент бүр бие даан өргөжиж болно
        \item Kafka partition ашиглан параллель боловсруулалт
        \item Consumer group-оор ачааллыг хуваарилах
    \end{itemize}
    
    \item \textbf{Найдвартай байдал (Resilience)}:
    \begin{itemize}
        \item Kafka-ийн replication алдагдал хамгаална
        \item Үйл явдал дахин тоглуулах боломжтой
        \item Агент тасалдах ч үйл явдал алдагдахгүй
    \end{itemize}
    
    \item \textbf{Бодит цагийн хариу үйлдэл}:
    \begin{itemize}
        \item Үйл явдал тэр даруйдаа дамждаг
        \item Streaming боловсруулалт
        \item Бага хоцрогдол
    \end{itemize}
    
    \item \textbf{Олон хэрэглэгч дэмжлэг}:
    \begin{itemize}
        \item Нэг үйл явдлыг олон систем ашиглаж болно
        \item CRM, CDP, analytics руу автоматаар урсах
        \item Шинэ consumer нэмэхэд producer өөрчлөх шаардлагагүй
    \end{itemize}
    
    \item \textbf{Observability ба Debugging}:
    \begin{itemize}
        \item Бүх үйл явдал хадгалагдана
        \item Lineage tracking: үйл явдал хаашаа явсныг мэдэх
        \item Үйл явдал дахин тоглуулж bug олох
        \item Дахин сургалтад ашиглах
    \end{itemize}
\end{enumerate}


\subsection{Үр дүн}

Энэхүү судалгааны ажил нь хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлж болох боломжит арга замыг харуулсан. Гол үр дүнгүүд:

\begin{enumerate}
    \item Хиймэл оюун агентууд нь микросервис хоорондын нарийн төвөгтэй логикийг удирдаж чадна
    \item RAG систем нь олон сервисийн мэдээллийг нэгтгэхэд үр дүнтэй
    \item Натурал хэл интерфейс нь хэрэглэгчийн туршлагыг сайжруулна
    \item Агент нь алдаа засалтын чадвартай
    \item Систем нь уян хатан, өргөжүүлэх боломжтой
\end{enumerate}

\subsection{Хязгаарлалт}

Санал болгосон загвар нь дараах хязгаарлалттай:

\begin{enumerate}
    \item \textbf{Хоцрогдол}: LLM inference хоцрогдолтой. Бодит цагийн шаардлагатай системд тохиромжгүй.
    \item \textbf{Өртөг}: API дуудлага бүр өртөгтэй. Өндөр ачаалалтай системд үнэтэй.
    \item \textbf{Найдвартай байдал}: LLM-ийн найдвартай байдал 100\% биш. Чухал системд баталгаат тохиргоо шаардлагатай.
    \item \textbf{Аюулгүй байдал}: Prompt injection довтолгооноос хамгаалах шаардлагатай.
\end{enumerate}


%----------------------------------------------------------------------------------------
%   Дүгнэлт эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\conclusion{Дүгнэлт}

Энэхүү судалгааны ажил нь хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг судалж, практик загвар санал болгосон. Судалгааны явцад дараах гол үр дүнд хүрсэн:

\textbf{Онолын хувьд:}

Хиймэл оюуны инженерчлэл нь програм хангамж хөгжүүлэлтийн шинэ салбар болж хөгжиж байгаа нь тодорхой. Суурь моделийн гарч ирэх нь аппликейшн хөгжүүлэлтийн саад бэрхшээлийг эрс багасгасан. Хэл загваруудаас том хэлний загвар, цаашлаад суурь загвар руу хөгжих үйл явц нь арван жилийн технологийн дэвшлийн үр дүн юм. Өөрийгөө удирдсан сургалт, Transformer архитектур, post-training аргууд зэрэг гол түлхүүрүүд нь өнөөгийн хүчирхэг хиймэл оюун системүүдийн суурь болгосон.

Хиймэл оюун агентуудын онол нь орчин, үйлдэл, даалгавар гэсэн гурван гол бүрэлдэхүүн дээр суурилдаг. Агентууд нь төлөвлөлт, хэрэглүүрийн хэрэглээ, эргэцүүлэн бодох чадвартайгаар уламжлалт програмуудаас давуу талтай. RAG систем нь агентуудын мэдлэгийг өргөтгөж, илүү найдвартай, бодит мэдээлэл дээр суурилсан хариулт өгөх боломжийг олгодог.

\textbf{Практикийн хувьд:}

Микросервис архитектур дахь сервис хоорондын нарийн төвөгтэй логик, өгөгдлийн нэгтгэл, динамик routing зэрэг асуудлуудыг хиймэл оюун агентууд ашиглан шийдэж болох нь тодорхой болсон. Санал болгосон Orchestrator Agent, Service Agent, Knowledge Agent, Monitoring Agent зэрэг бүрэлдэхүүн хэсгүүд нь уян хатан, өргөжүүлэх боломжтой системийг бий болгодог.

Гэхдээ агентуудыг үйлдвэрлэлийн түвшинд өргөжүүлэхийн тулд зөвхөн агентын ур чадвар биш, тэдгээрийг холбодог архитектур чухал гэдгийг ойлгосон. Монолит болон RPC/API суурилсан холболт нь монолит архитектурт тулгарсан асуудалтай адил саад болдог. Үүнийг шийдэхийн тулд үйл явдлаар Event-Driven архитектур ашиглан агентуудыг салангид микросервис болгон хөгжүүлэх шаардлагатай.

\textbf{Event-Driven архитектур}

Apache Kafka болон Apache Flink ашиглан event-driven агентын систем бүтээх нь:

\begin{itemize}
    \item \textbf{Салангид байдал}: Kafka topics-оор харилцах нь агентууд хоорондоо шууд хамааралгүй байхыг баталгаажуулна
    \item \textbf{Параллель боловсруулалт}: Kafka partitions ашиглан олон агент зэрэг ажиллаж, системийн дамжуулалтыг нэмэгдүүлнэ
    \item \textbf{Найдвартай байдал}: Үйл явдлын хадгалалт нь мэдээлэл алдагдахгүй, дахин тоглуулж болохыг баталгаажуулна
    \item \textbf{Bодит цагийн боловсруулалт}: Streaming архитектур нь тэр даруй хариу үйлдэл үзүүлэх боломжийг олгоно
    \item \textbf{Олон хэрэглэгч}: Агентын гаралт нь CRM, CDP, analytics зэрэг олон системд автоматаар урсах боломжтой
\end{itemize}

Flink AI Inference ашиглах нь orchestrator агентыг stream processing app болгон хөгжүүлэх боломжийг олгож, Flink-ийн stateful боловсруулалт, exactly-once семантик зэрэг давуу талыг ашиглах боломжтой болгоно.

Apache Kafka болон Apache Flink зэрэг технологиудыг ашиглан event-driven агентын систем нь:
\begin{itemize}
    \item Бие даан өргөжиж чадна
    \item Бодит цагт өгөгдөл боловсруулна
    \item Системийн хэмжээнд мэдээллээ хуваалцана
    \item Алдаанаас сэргэж чадна
    \item Дахин тоглуулах замаар сайжирна
\end{itemize}

Микросервис архитектурт хиймэл оюун агентууд нэвтрүүлэх нь системийг илүү ухаалаг, уян хатан, хэрэглэгчид ээлтэй болгох боломжийг олгоно. Хэдийгээр одоогоор хязгаарлалтууд(Жич:хоцрогдол, өртөг, найдвартай байдал) байгаа ч технологи хурдацтай хөгжиж байгаа тул ойрын ирээдүйд эдгээр асуудлууд шийдэгдэх болно гэж найдаж байна.

Энэхүү дипломын ажил нь хиймэл оюуны инженерчлэлийн үндсийг тавьж, микросервис архитектурт агент суурилсан шийдлийг практикт хэрхэн хэрэглэж болохыг харуулсан. 

% Техникийн хөгжүүлэлтийн хувьд Next.js React фронтенд, Node.js Express бэкенд, TypeScript, MySQL ашиглан SOLID зарчмыг дагасан архитектур бүтээсэн. Merchant Super App OAuth механизм, ҮЦТХТ SOAP API интеграци, 300,000+ мөртэй өгөгдлөөс binary search алгоритмаар хурдан хайлт хийх(5-40ms), үнэт цаасны real-time дата WebSocket ашиглан дамжуулах систем зэрэг олон чухал арга техникийг амжилттай хэрэгжүүлсэн.

% Фүллстек веб хөгжүүлэлт, API интеграци, real-time дата боловсруулалт, Docker containerization, DevOps практик зэрэг олон чиглэлийн техникийн чадваруудыг эзэмшсэн. Мөн багийн ажиллагаа, төслийн удирдлага, Git workflow, CI/CD pipeline зэрэг мэргэжлийн ур чадваруудыг хөгжүүлсэн.

% Энэхүү дадлагын үр дүнд санхүүгийн технологийн салбарт бодит ажлын туршлага олж авч, ирээдүйд илүү том, нарийн төвөгтэй системүүд хөгжүүлэх, санхүүгийн технологийн салбарт хувь нэмрээ оруулах чадварыг эзэмшсэн.

%----------------------------------------------------------------------------------------
%   Дипломын номзүй, хавсралтын хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------

\singlespace
\addcontentsline{toc}{part}{НОМ ЗҮЙ}
\begin{thebibliography}{99}
	% Үндсэн ном зохиол
	\bibitem{huyen2024}
	Huyen, Chip. \textit{AI Engineering}. O'Reilly Media, 2024.
	
	\bibitem{goldman2023}
	Goldman Sachs Research. "Generative AI Could Raise Global GDP by 7\%", 2023. 
	\url{https://www.goldmansachs.com/intelligence/pages/generative-ai-could-raise-global-gdp-by-7-percent.html}
	
	% Foundation Models
	\bibitem{vaswani2017}
	Vaswani, A., et al. "Attention Is All You Need". \textit{Advances in Neural Information Processing Systems}, 2017.
	
	\bibitem{devlin2019}
	Devlin, J., et al. "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding". \textit{NAACL-HLT}, 2019.
	
	\bibitem{brown2020}
	Brown, T., et al. "Language Models are Few-Shot Learners". \textit{Advances in Neural Information Processing Systems}, 2020.
	
	\bibitem{touvron2023}
	Touvron, H., et al. "Llama 2: Open Foundation and Fine-Tuned Chat Models". \textit{arXiv preprint arXiv:2307.09288}, 2023.
	
	\bibitem{touvron2024}
	Touvron, H., et al. "The Llama 3 Herd of Models". \textit{arXiv preprint arXiv:2407.21783}, 2024.
	
	% RAG
	\bibitem{lewis2020}
	Lewis, P., et al. "Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks". \textit{Advances in Neural Information Processing Systems}, 2020.
	
	\bibitem{gao2023}
	Gao, Y., et al. "Retrieval-Augmented Generation for Large Language Models: A Survey". \textit{arXiv preprint arXiv:2312.10997}, 2023.
	
	% AI Agents
	\bibitem{wei2022}
	Wei, J., et al. "Chain-of-Thought Prompting Elicits Reasoning in Large Language Models". \textit{Advances in Neural Information Processing Systems}, 2022.
	
	\bibitem{yao2023}
	Yao, S., et al. "ReAct: Synergizing Reasoning and Acting in Language Models". \textit{ICLR}, 2023.
	
	\bibitem{schick2023}
	Schick, T., et al. "Toolformer: Language Models Can Teach Themselves to Use Tools". \textit{arXiv preprint arXiv:2302.04761}, 2023.
	
	% Evaluation & Hallucination
	\bibitem{ortega2021}
	Ortega, P.A., et al. "Shaping Representations Through Communication: Community Size and Stability Determine the Emergence of Shared Symbols". \textit{DeepMind Technical Report}, 2021.
	
	\bibitem{schulman2022}
	Schulman, J. "Reinforcement Learning from Human Feedback: Progress and Challenges". \textit{Berkeley EECS Colloquium}, 2022.
	
	% Prompt Engineering
	\bibitem{openai2023}
	OpenAI. "Prompt Engineering Guide", 2023. \url{https://platform.openai.com/docs/guides/prompt-engineering}
	
	\bibitem{liu2023}
	Liu, P., et al. "Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing". \textit{ACM Computing Surveys}, 2023.
	
	% Microservices
	\bibitem{newman2015}
	Newman, Sam. \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media, 2015.
	
	\bibitem{richardson2018}
	Richardson, Chris. \textit{Microservices Patterns: With Examples in Java}. Manning Publications, 2018.
	
	\bibitem{fowler2014}
	Fowler, Martin and Lewis, James. "Microservices: A Definition of This New Architectural Term", 2014. \url{https://martinfowler.com/articles/microservices.html}
	
	% Vector Databases & Search
	\bibitem{johnson2019}
	Johnson, J., Douze, M., and Jégou, H. "Billion-scale Similarity Search with GPUs". \textit{IEEE Transactions on Big Data}, 2019.
	
	\bibitem{malkov2018}
	Malkov, Y.A. and Yashunin, D.A. "Efficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs". \textit{IEEE Transactions on Pattern Analysis and Machine Intelligence}, 2018.
	
	% Embeddings
	\bibitem{reimers2019}
	Reimers, N. and Gurevych, I. "Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks". \textit{EMNLP-IJCNLP}, 2019.
	
	\bibitem{muennighoff2023}
	Muennighoff, N., et al. "MTEB: Massive Text Embedding Benchmark". \textit{EACL}, 2023.
	
	% API & Integration
	\bibitem{fielding2000}
	Fielding, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.
	
	% Python & Tools
	\bibitem{python}
	Python Software Foundation. "Python 3 Documentation". \url{https://docs.python.org/3/}
	
	\bibitem{fastapi}
	Ramírez, Sebastián. "FastAPI Documentation". \url{https://fastapi.tiangolo.com/}
	
	\bibitem{openai-api}
	OpenAI. "OpenAI API Reference". \url{https://platform.openai.com/docs/api-reference}
	
	\bibitem{anthropic2024}
	Anthropic. "Claude 3 Model Card", 2024. \url{https://www.anthropic.com/claude}
	
	\bibitem{langchain}
	LangChain. "LangChain Documentation". \url{https://python.langchain.com/docs/}
	
	\bibitem{faiss}
	Facebook AI Research. "FAISS: A Library for Efficient Similarity Search". \url{https://github.com/facebookresearch/faiss}
	
	% Event-Driven Architecture & Streaming
	\bibitem{falconer2025agents}
	Falconer, Sean. "AI Agents are Microservices with Brains". Medium, March 2025. \url{https://medium.com/@seanfalconer}
	
	\bibitem{falconer2025future}
	Falconer, Sean. "The Future of AI Agents is Event-Driven". BigDataWire, March 2025.
	
	\bibitem{polak2025}
	Polak, Adi. "Building AI Agents with Event-Driven Microservices". Confluent Developer Advocate, 2025.
	
	\bibitem{kafka}
	Apache Kafka Documentation. "Apache Kafka: A Distributed Streaming Platform". \url{https://kafka.apache.org/documentation/}
	
	\bibitem{kreps2014}
	Kreps, Jay, Narkhede, Neha, and Rao, Jun. "Kafka: A Distributed Messaging System for Log Processing". \textit{Proceedings of the NetDB}, 2011.
	
	\bibitem{flink}
	Apache Flink Documentation. "Stateful Computations over Data Streams". \url{https://flink.apache.org/}
	
	\bibitem{carbone2017}
	Carbone, Paris, et al. "State Management in Apache Flink: Consistent Stateful Distributed Processing". \textit{Proceedings of the VLDB Endowment}, 2017.
	
	% Multi-Agent Systems
	\bibitem{wooldridge2009}
	Wooldridge, Michael. \textit{An Introduction to MultiAgent Systems}. John Wiley \& Sons, 2009.
	
	\bibitem{park2023}
	Park, Joon Sung, et al. "Generative Agents: Interactive Simulacra of Human Behavior". \textit{arXiv preprint arXiv:2304.03442}, 2023.
	
	% Microservices Evolution
	\bibitem{wolff2016}
	Wolff, Eberhard. \textit{Microservices: Flexible Software Architecture}. Addison-Wesley Professional, 2016.
	
	\bibitem{nadareishvili2016}
	Nadareishvili, Irakli, et al. \textit{Microservice Architecture: Aligning Principles, Practices, and Culture}. O'Reilly Media, 2016.
	
	% Anthropic MCP
	\bibitem{anthropic2024mcp}
	Anthropic. "Model Context Protocol: A Universal Standard for AI Integration", 2024. \url{https://www.anthropic.com/news/model-context-protocol}
	
\end{thebibliography}


%----------------------------------------------------------------------------------------
%   Хавсралтууд эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\appendix
\addcontentsline{toc}{part}{ХАВСРАЛТ}

% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
% \chapter{Нүүр хуудас}


% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
% \chapter{Кодын хэрэгжүүлэлт}

% \section{Merchant Super App OAuth нэвтрэлт}

% \begin{lstlisting}[language=Java, caption=Merchant App Authorization Redirect Handler]
% router.get("/merchantA", async (req, res) => {
%   const { code, scope } = req.query;
  
%   // Merchant OAuth code-г token-д солих
%   const tokenRes = await merchantService.getCode(code as string);
%   const merchantInformation = await merchantService.getUserInfo(
%     tokenRes.access_token
%   );
  
%   // Хэрэглэгч өгөгдлийн санд байгаа эсэхийг шалгах
%   const user = await db.user.findFirst({
%     where: { merchantUser: { userIdMerchant: merchantInformation.userId } },
%     include: { user: true, merchantUser: true }
%   });
  
%   let token;
%   if (user) {
%     // Хэрэглэгч бүртгэлтэй бол JWT токен үүсгэх
%     const payload = { id: user.user.id, role: "USER", type: "merchant" };
%     token = jwt.sign(payload, env.JWT_SECRET);
    
%     // Хэрэглэгчийн Refresh Token-ыг шинэчлэх
%   } else {
%     // Шинэ хэрэглэгч бүртгэх
%     token = jwt.sign({ id: merchantUser.id, role: "USER" }, env.JWT_SECRET);
%   }
  
%   // JWT токенийг cookie-д хадгалах
%   res.cookie("token", token, {
%     httpOnly: false,
%     secure: process.env.NODE_ENV === "production",
%     sameSite: "lax",
%     maxAge: 24 * 60 * 60 * 1000 // 1 day
%   });
  
%   res.redirect(process.env.PROD_FRONTURL);
% });
% \end{lstlisting}

% \section{Cron job болон тогтмол синхронизаци}



\end{document}
