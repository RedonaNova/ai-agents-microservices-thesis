%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[12pt,a4paper]{report}

\usepackage{fontspec,xltxtra,xunicode}
\setmainfont[Ligatures=TeX]{Times New Roman}
\setsansfont{Arial}

% \usepackage[utf8x]{inputenc}
% \usepackage[mongolian]{babel}
%\usepackage{natbib}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\setlength{\headheight}{29.03363pt}
%\usepackage{fancyheadings} fancyheadings is obsolete: replaced by fancyhdr. JL
\usepackage{fancyhdr}
% Set up page numbering style
\pagestyle{fancy}
\fancyhf{} % Clear all headers and footers
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{float}
\usepackage{afterpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsbsy}
\usepackage{dcolumn,array}
\usepackage{tocloft}
\usepackage{styles/dics}
% Ensure proper page numbering after dics.sty is loaded
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{nomencl}
\usepackage{upgreek}
\newcommand{\argmin}{\arg\!\min}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}

% Packages for better text wrapping and line breaking
\usepackage{microtype} % Improves text appearance and reduces overfull boxes
\usepackage{ragged2e} % Better text justification
\usepackage{hyphenat} % Better hyphenation control
\usepackage{url} % Better URL line breaking

% Emergency stretch to prevent overfull hboxes
\emergencystretch=1em

% Additional settings for better text handling
\tolerance=1000
\hyphenpenalty=50
\exhyphenpenalty=50

% Set line breaking parameters
\linespread{1.05} % Slightly increase line spacing
\clubpenalty=10000 % Prevent single lines at bottom of page
\widowpenalty=10000 % Prevent single lines at top of page

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{listings}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\makeatletter
\usepackage{caption}
\captionsetup[table]{belowskip=0.5pt}
\renewcommand{\tablename}{Хүснэгт}
\usepackage{longtable}
\usepackage{subfiles}

\usepackage{listings}
\renewcommand{\lstlistingname}{Код}
\renewcommand{\lstlistlistingname}{\lstlistingname ын жагсаалт}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.99,0.99,0.99}
\definecolor{lightgray}{rgb}{0.83,0.83,0.83}
\definecolor{darkgray}{rgb}{0.3,0.3,0.3}

% Define JavaScript language for listings
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, const, let, async, await, export, import, class, extends},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={boolean, number, string, any, void},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
 
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=false,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=true,
    showtabs=false,                  
    tabsize=2,
    % Additional settings for better line breaking
    breakindent=1.5em,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    frame=single,
    rulecolor=\color{lightgray},
    columns=flexible,
    % Ensure lines don't exceed margins
    xleftmargin=2em,
    xrightmargin=2em
}
 
\lstset{style=mystyle, label=DescriptiveLabel} 



\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\makenomenclature
\begin{document}


%----------------------------------------------------------------------------------------
%   Өөрийн мэдээллээ оруулах хэсэг
%----------------------------------------------------------------------------------------

% Дипломийн ажлын сэдэв
\title{Микросервис архитектурт суурилсан хиймэл оюун агентууд}
% Дипломын ажлын англи нэр
\titleEng{AI agents for microservices}
% Өөрийн овог нэрийг бүтнээр нь бичнэ
\author{Булганы Раднаабазар}
% Өөрийн овгийн эхний үсэг нэрээ бичнэ
\authorShort{Б.Раднаабазар}
% Удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\supervisor{Дэд профессор Б.Сувдаа}
% Хамтарсан удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\cosupervisor{}

% СиСи дугаар 
\sisiId{22B1NUM0286}
% Их сургуулийн нэр
\university{МОНГОЛ УЛСЫН ИХ СУРГУУЛЬ}
% Бүрэлдэхүүн сургуулийн нэр
\faculty{МЭДЭЭЛЛИЙН ТЕХНОЛОГИ, ЭЛЕКТРОНИКИЙН СУРГУУЛЬ}
% Тэнхимийн нэр
\department{МЭДЭЭЛЭЛ, КОМПЬЮТЕРЫН УХААНЫ ТЭНХИМ}
% Зэргийн нэр
\degreeName{Дипломын ажлын тайлан}
% Суралцаж буй хөтөлбөрийн нэр
\programeName{Мэдээллийн технологи (D061304)}
% Хэвлэгдсэн газар
\cityName{Улаанбаатар}
% Хэвлэгдсэн огноо
\gradyear{2025 оны 12 сар}


%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
\include{src/main-pre}

% Удиртгалыг оруулж ирэх ба abstract.tex файлд удиртгалаа бичнэ
\include{src/abstract}

% Нэр томьёоны тайлбар
\include{src/terminology}

%----------------------------------------------------------------------------------------
%   Дипломын үндсэн хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------



\textbf{Зорилго:}

Энэхүү судалгааны ажлын гол зорилго нь хиймэл оюун агентуудыг микросервис архитектур хэлбэрээр нэвтрүүлэх боломжийг онол, практикийн хувьд судалж, Үзэгдэлд суурилсан архитектур (EDA) ашиглан уян хатан, өргөжих боломжтой системийн зохиомж гаргах юм. Уг зохиомжийн үр ашигтай байдлыг баталгаажуулахын тулд Монголын хөрөнгийн биржийн бодит өгөгдөлд суурилсан демо систем хөгжүүлж туршина.

\textbf{Зорилт:}

\begin{enumerate}
    \item Хиймэл оюуны инженерчлэл, суурь загвар, RAG, агентуудын онол, онцлогийг судлах
    \item Микросервис архитектур болон EDA-ийн давуу талыг тодорхойлох
    \item Apache Kafka, Apache Flink ашиглан агентуудыг тархмал микросервист нэгтгэсэн зохиомж гаргах
    \item Монголын хөрөнгийн биржийн өгөгдөлд суурилсан демо систем хөгжүүлж, санал болгосон зохиомжийг туршиж үзэх
\end{enumerate}

\chapter{Хиймэл оюуны инженерчлэл ба агентууд}

Энэхүү бүлэгт хиймэл оюуны инженерчлэлийн үндсэн ойлголтууд, суурь загварын хөгжил, промпт инженерчлэл, цаашлаад RAG, олон агент системийн архитектурыг тайлбарлана. Мөн ижил төстэй системүүдийн судалгааг хийж, энэхүү судалгааны ажлын онцлог байр суурийг тодорхойлно.

\section{Хиймэл оюуны инженерчлэл гэж юу вэ}

Хиймэл оюуны инженерчлэл гэдэг нь бэлэн бэлтгэгдсэн суурь загвар дээр аппликейшн хөгжүүлэх үйл явцийг хэлнэ. Энэ нь уламжлалт машин сургалтын инженерчлэлээс ялгаатай байдаг ~\cite{huyen2024}. Хэрэв уламжлалт машин сургалтын инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн бол, хиймэл оюуны инженерчлэл нь бэлтгэгдсэн загварыг программ хангамжид интеграц хийхэд чиглэсэн байдаг. Энэ ч утгаараа фүллстэк хөгжүүлэгч заавал машин сургалтын 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/aiAndML.png}
    \caption{Хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэл ~\cite{huyen2024}}
    \label{fig:home}
\end{figure}

Зураг \ref{fig:home}-д хиймэл оюуны инженерчлэл ба машин сургалтын инженерчлэлийн ялгааг дүрсэлсэн. Зураг \ref{fig:home}-оос харахад хиймэл оюуны инженерчлэл нь бэлэн загварыг ашиглахад чиглэсэн бол машин сургалтын инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн байна.

OpenAI, Anthropic зэрэг компаниудын гаргасан хүчирхэг суурь загварын хүртээмж нь гурван гол хүчин зүйлээс шалтгаалан хиймэл оюуны инженерчлэлийг хурдан өсөж буй салбар болгожээ. ~\cite{goldman2023} Эхнийх нь өндөр эрэлт юм. Компаниуд хиймэл оюуныг бусад бизнесээс ялгарах өрсөлдөөнт давуу тал болгон үзэж байна. FactSet-ийн судалгаагаар 2023 оны хоёрдугаар улиралд S\&P 500 компаниудын гуравны нэг нь өөрсдийн санхүүгийн тайланд хиймэл оюуныг дурдсан тоо нь өмнөх оноос гурав дахин их байна. Хоёр дахь нь технологийн хөгжилтэй холбоотой. Өмнө нь хиймэл оюун систем бүтээхэд өндөр мэргэжлийн ур чадвар, их хэмжээний өгөгдөл, тооцооллын нөөц шаардлагатай байсан бол одоо суурь загвар ашиглан хэрэглээнд нэвтрүүлэх нь илүү боломжтой болов. Улмаас хиймэл оюуны инженерүүд программ хангамжийг хүртээмжтэй загварууд ашигласнаар өндөр түвшний математикийн мэдлэг өндөр түвшинд байх шаардлагагүй болов. Гурав дахь нь том боломж юм. Хиймэл оюун технологи нь ажил хэргийг автоматжуулах, шинэ бүтээгдэхүүнүүдийг бий болгох зэрэг асар том боломжуудыг санал болгож байна. Энэхүү хандлагын нотолгоо болох хиймэл оюунт аппликейшний нээлттэй эхийн кодууд (AutoGPT, Stable Diffusion WebUI, LangChain, Ollama) нь GitHub дээр Bitcoin-оос ч илүү од цуглуулсан нь энэхүү салбарын хурдацтай өсөлтийг тод илэрхийлж байна. ~\cite{huyen2024}.

\section{Суурь загварын хөгжил}

Хэл загваруудээс том хэлний загвар болон суурь загвар руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Энэхүү хэсэгт гол түлхүүр үйл явдлыг тайлбарлах болно. ~\cite{huyen2024}

\subsection{Хэл загварын үндэс}

Хэл загвар гэдэг нь нэг буюу олон хэлүүдийг статистик өгөгдөл рүү кодлодог загвар юм. Энэхүү мэдээлэл нь өгөгдсөн контекстэд уг үг гарах магадлалыг илэрхийлдэг. Жишээлбэл, "Миний дуртай өнгө бол \_\_" гэсэн контекст өгөхөд монгол хэлээр кодолсон хэл загвар нь "машин" биш, харин "цэнхэр" гэсэн үгийг таамаглах ёстой. ~\cite{huyen2024}

Анхны текстийг токен болгон хуваах үйл явцыг токенжуулалт гэнэ. GPT-4 суурь загварын хувьд дунджаар нэг токен нь үгийн ойролцоогоор 75\%-ийн уртад тохирно. Тиймээс 100 токен нь ойролцоогоор 75 үг юм.

Хэл загвард хоёр үндсэн төрөл байдаг. Эхний төрөл нь далдлагдсан хэлний загварууд бөгөөд эдгээр нь өгүүлбэр доторх далдлагдсан үгсийг таамаглах замаар сурдаг. BERT нь энэ төрлийн алдартай жишээ юм. Хоёр дахь төрөл нь автoрегрессив хэл загварууд бөгөөд өмнөх токенуудад үндэслэн дараагийн токенийг таамаглах замаар сурдаг. Одоогийн ChatGPT, Claude зэрэг өргөн ашиглагдаж буй системүүд нь энэ ангилалд хамаарагддаг.

\subsection{Өөрийгөө удирдсан сургалт (Self-Supervised Learning)}

Хэл загварын хамгийн чухал давуу тал нь өөрийгөө удирдсан сургалтыг ашиглах чадвар юм ~\cite{huyen2024}. Өөрийгөө удирдсан сургалт нь удирдлагатай сургалтаас ялгаатай байдаг. Удирдлагатай сургалт нь тэмдэглэгдсэн өгөгдөл шаарддаг бөгөөд энэ үйл явц нь цаг хугацаа их зарцуулдаг. ~\cite{huyen2024}

Энэ нь хэл загварыг номнуудаас, блог нийтлэлээс, өгүүллүүд, Reddit-ийн сэтгэгдэл зэргээс ашиглан сургаж болно. Энэ нь асар их сургалтын өгөгдөл бүрдүүлэх боломжийг олгож, хэл загварыг том хэлний загвар буюу LLM болтол өргөжүүлэх боломжтой болгосон.

\subsection{Том хэлний загвараас суурь загвар руу}

2017 онд Transformer архитектур гарч ирснээр хэл загварын чадамж харьцангуй өндөр нэмэгдсэн. Attention механизм нь загваруудад өгөгдлийн хамаарлыг илүү сайн ойлгох боломжийг олгосон. ~\cite{huyen2024}

Том хэлний загварууд нь хэл загварын томорсон хувилбар бөгөөд тэрбум тооны параметр агуулдаг. Параметр гэдэг нь сургалтын явцад загварын сурч авдаг утга юм. Жишээлбэл, GPT-3 нь 175 тэрбум параметртэй, харин GPT-4 нь 1.2 их наяд параметртэй байдаг. 

Суурь загварууд нь LLM-ээс цааш өргөжсөн ойлголт юм. Эдгээр нь зөвхөн текст биш, зураг, аудио, видео зэрэг олон төрлийн өгөгдөл боловсруулж чаддаг том мульти модал загварууд юм. Суурь загварын гол онцлог нь тодорхой үүрэгтэй загвараас цаашлаад ерөнхий зориулалтын загвар руу шилжсэн юм.

\section{Хиймэл оюуны агент ба бизнесийн үйл ажиллагаа}

Энтерпрайзийн хувьд хиймэл оюун нь дахин давтагддаг нэхэмжлэл үүсгэх, харилцагчийн асуултад хариулах, өгөгдөл бүртгэх зэрэг үйл ажиллагааг автоматжуулах боломж гаргаж байдаг. Нэгэн сонирхолтой хиймэл оюуны нэвтрүүлэлтийн хэлбэр нь өгөгдлийг дахин сайжруулах арга зам юм. Энэ нь өөрийнхөө өгөгдөлд тэмдэглэгээ хийгээд, дараа нь энэ тэмдэглэгээний үр дүнгээс хамаарч жинхэнэ хүний тусламжтайгаар алдааг багасгахын тулд олон дахин уг тэмдэглэгээнүүдийг сайжруулах юм. Энтерпрайзуудад хамгийн алдартай хиймэл оюуны хэрэглээ нь харилцагчийн туслах бот юм. Туслах бот нь хүнээс хурдан хариулснаар харилцагчийн туршлагыг сайжруулж, бас бизнесийн хувьд зардал хэмнэх боломжийг бүрдүүлдэг. ~\cite{huyen2024} ~\cite{goldman2023}

Хиймэл оюунд гадна орчинтой хандах хэрэглүүр өгөх нь маш олон боломжийг нээж өгдөг. Ресторанд цаг захиалахад сул цаг харах, захиалга өгөх зэрэг үйлдлийг хэрэглүүрүүд хийх боломжтой ба хиймэл оюунд уг хэрэглүүр өгснөөр харилцагчийн өмнөөс уг үйлдлийг автоматаар хийж болох юм. Уг үйлдлүүдийг зохион байгуулж, хэрэглүүр ашигладаг программ хангамжийг хиймэл оюун агентууд гэнэ.     

\section{Суурь загварын сургалт}

Суурь загварыг бэлтгэх нь хоёр үндсэн үе шаттай:

\subsection{Урьдчилан сургалт}

Урьдчилан сургалт нь өөрийгөө удирдсан сургалт ашиглан их хэмжээний өгөгдөл дээр загварыг сургах үйл явц юм. Энэ үе шатанд загвар нь хэл, ерөнхий мэдлэг, дүрэм, баримт бичгүүдээс суралцдаг. 2022 онд сургалтын дата олохын тулд нэгэн ашгийн бус байгууллага 2-3 тэрбум веб хуудсуудыг автоматаар авч сургасан байна. Гэвч худал хуурмаг мэдээлэл, хүнд сурталтай мэдээлэл их байдаг тул хьюристик филтер хийдэг. Жишээ нь реддит платформд 5-аас олон эерэг хариу үйлдэлтэй бол уг өгөгдлийг авах юм.  ~\cite{huyen2024}

Суурь загвар нь олон төрөлтэй байна. Нэгт, тодорхой зорилготой агентууд нь домейнд л хамаарагдах өгөгдлийг ашиглаж тооцоолол хийдэг. Үүнд эм эмчилгээний жорыг гаргах, ДНХ, хавдрын, уурагны симуляц явах зэрэг үйлдлүүдтэй байна. Хоёрт, ерөнхий зориулалттай хиймэл оюуны загвар байна. Сургагдсан өгөгдлийн талаас дээш хувийг технологи, бизнес, үйлдвэр, мэдээ, урлаг уран сайхны өгөгдлүүд эзлэх ба үлдсэн хувийг бусад бага бага хувьтай гэр, аялал зэрэг секторууд эзлэж байна.

Олон улсын хэлүүд суурь загвар дээр өөр өөр ажиллах зарчимтай байна. Сургалтан дээр суурь загварын ойролцоогоор тал хувийг англи хэл эзэлдэг бол орос, герман хэл 10 хувийг эзлэж байна. GPT-4 суурь загварын хувьд ашиглах токений хэмжээ ба төөрөгдөл хамгийн бага байх ба, Бирм хэл англи хэлээс 70 дахин их токен ашиглаж, төөрөгдөл хамгийн өндөр байна. Шалтгаан нь уг хэлний соёлийн бүтэц юм. Жишээлбэл зарим хэлд эзэн бие ашигладаггүй учир хэл хөрвөхөд оновчтой байх магадлал бага юм. 

Иймээс суурь загварын хэлний хязгаарлалтыг давахын тулд өөрсдийн хэл дээр суурь загвар хөгжүүлж байна. Жишээлбэл, хятадын "Llama-Chinese", францийн "Croissant-LLM", Виетнамын "PhoGPT" гэх зэрэг. Монгол улсын хувьд "Чимэгэ систем" нь монгол хэл дээр суурь загвар хөгжүүлж байгаа. 

Урьдчилан сургагдсан үе шатд хэрэглэгчдийн хүсэлтэд нийцсэн хариулт өгөхөд сайн биш байдаг. Учир нь харилцан яриа өрнүүлэх гэхээс илүүтэйгээр зөвхөн өгүүлбэрийн гүйцээлт рүү тулгуурлан сургагдсан байдаг. Иймээс дараах сургалт, sampling техникүүд, нарийвчилсан сургалтууд шаардалагатай байдаг.

\subsection{Дараах сургалт}

Урьдчилан сургасан загварыг хэрэглэгчдийн хүсэлтэд тохируулахын тулд дараах сургалт хийдэг. Энэ нь хоёр үе шаттай. Эхний үе шат нь удирдлагатай нарийвчилсан сургалт юм. Энэ үе шатанд өндөр чанартай зааварчилгааны өгөгдөл дээр загварыг нарийвчлан сургаж, зөвхөн өгүүлбэрийн гүйцээлт биш харин харилцан ярианы горимд оновчтой болгоно. Хоёр дахь үе шат нь сонголтын нарийвчилсан сургалт юм. Энэ үе шатанд загварыг хүний сонголттой нийцсэн хариулт өгөхийн тулд цаашид нарийвчлан сургана. Үүнд хүний санал хүсэлтээр бэхжүүлсэн сургалт, хиймэл оюуны санал хүсэлтээр бэхжүүлсэн сургалт зэрэг аргууд ордог. ~\cite{huyen2024}


\subsection{Загварын үнэлгээ}

Суурь загварыг үнэлэх нь эрсдлийг бууруулах, боломжуудыг илрүүлэх тал дээр чухал ач холбогдолтой. Үнэлгээ нь загварыг сонгох, үр дүнг хэмжих, бодит хэрэглээнд нэвтэрч болох эсэхийг тодорхойлох, асуудал болон боломжуудыг илрүүлэх зэрэгт шаардлагатай ~\cite{huyen2024}.

Сүүлийн жилүүдэд бага параметртэй загвар нь өмнөх үеийн их параметртэй загвараас илүү чадалтай байна. Жишээлбэл, 2024 оны Llama 3-8B загвар нь 2023 оны Llama 2-70B загвараас ч илүү сайн үр дүнг MMLU benchmark дээр харуулжээ. Энэ нь зөвхөн загварын хэмжээ биш, сургалтын аргууд болон өгөгдлийн чанар хамгийн чухал болохыг харуулж байна.

\section{Промпт инженерчлэл}

Промпт инженерчлэл гэдэг нь загвараас хүссэн үр дүнг гаргуулахын тулд промпт заавар бичих үйл явц юм ~\cite{openai2023}. Энэ нь загварын жинг өөрчлөхгүйгээр хиймэл оюуны зан чанарыг удирдах хамгийн хялбар бөгөөд түгээмэл дасан зохицох арга юм.

\subsection{Промпт бичих шилдэг арга барил}

Промпт заавруудыг хэрэглээнд тохирсон стратегиудын дагуу бичих нь илүү сайн үр дүн өгдөг. ~\cite{openai2023} OpenAI-ийн санал болгож буй промпт бичих шилдэг арга барил нь эхлээд юу хийлгэхээ хоёрдмол утгагүй байдлаар тодорхой тайлбарлах хэрэгтэй. Дараа нь загвараар тодорхой дүрд тоглуулж болно. Жишээ нь "Та том компанид 20 жил ажилласан туршлагатай программист. Кодыг шалгаад сайжруулж өг" гэх мэт. Anthropic-ийн зөвлөмжөөр промптод 500 хуудас бүхий номын урттай тэмдэгт мөр багтаж чадах тул промптод урт жишээ өгснөөр хариултын формат болон хариултын хоёрдмол утгыг багасгадаг. Цар хүрээ, агуулгыг мэдээлүүлснээр төөрөгдлийг багасгадаг. Хэрэв загвар шаардлагатай мэдээллээр хангагдаагүй бол өөрийн дотоод мэдлэгтээ найдах бөгөөд найдваргүй байж болдог. Түүнчлэн нарийн төвөгтэй даалгавруудыг хялбар дэд даалгавруудад хувааж өгөх нь үр дүнтэйгээр бага токен ашиглах боломжийг олгоно.

\subsection{Промптын хамгаалалт}

Программ хангамж бодит орчинд байрших үе шатанд ормогц хортой довтолгооноос хамгаалах шаардлагатай болдог. Энэхүү хортой код нь хэрэглэгчийн хувийн хэвшлийн эсвэл байгууллагын нууц мэдээллийг хиймэл оюуны цоорхойгоор авах оролдлого юм. Үүнд загварын сургалтын өгөгдөл, контекстын мэдээлэл зэрэг багтана. ~\cite{huyen2024}

Иймээс хиймэл оюуны агент эсвэл загвар хөгжүүлж буй тохиолдолд процессын оролт болон гаралтыг хамгаалах шаардлагатай байдаг. 

\section{Хайлтаар нэмэгдүүлсэн үүсгэлт (RAG)}

RAG буюу хайлтаар нэмэгдүүлсэн үүсгэлт нь загварын мэдлэгийг гадаад эх сурвалжаар өргөтгөх арга юм. Энэ нь загварын дотоод мэдлэг нь хангалтгүй, хуучирсан эсвэл алдаатай байх асуудлыг шийддэг ~\cite{huyen2024}.

Хэдийгээр загварын контекстийн урт тогтмол нэмэгдэж байгаа ч RAG-ийн ач холбогдол алдагдахгүй байна. Зарим аппликейшнд өгөгдлийн хэмжээ байнга өсөж байдаг. Иймээс RAG удааширч магадгүй тул үүнийг сайтар үнэлж, тасралтгүй хөгжүүлэлт хийснээр бодит хэрэглээнд үр нөлөө алдахгүй байх боломжийг бүрдүүлнэ. Урт контекстийг боловсруулж чаддаг гэдэг нь тэр контекстийг сайн ашигладаг гэсэн үг биш. Контекст урт байх тусам загвар буруу хэсэгт анхаарал хандуулах магадлал өсдөг. Түүнчлэн контекстын токен бүр нэмэлт өртөг, нэмэлт хоцрогдол авчирдаг. RAG нь асуулт бүрд зөвхөн хамгийн холбогдолтой мэдээллийг ашиглах боломжийг олгоно.

Anthropic-ийн зөвлөмжөөр хэрэв мэдээлэл нь 200,000 токеноос бага (ойролцоогоор 500 хуудас бүхий өгөгдөл) бол RAG ашиглалгүй бүх мэдлэгийг промпт зааварт оруулж болно гэжээ.

\subsection{RAG-ийн бүтэц}

RAG нь хоёр гол бүрэлдэхүүнтэй. Хайгч нь асуултад хамгийн холбогдолтой баримтуудыг олж авдаг. Үүсгэгч нь олж авсан баримтуудыг асуултад ашиглан хариулт үүсгэдэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/RAG.png}
    \caption{RAG-ийн бүтэц ~\cite{huyen2024}}
    \label{fig:rag}
\end{figure}

Зураг \ref{fig:rag}-аас харахад хайгч нь асуултад хамгийн их холбоотой баримтуудыг олж авдаг бол үүсгэгч нь олж авсан баримтуудыг суурь загварт дамжуулан хариулт үүсгэдэг.

\subsection{Хайлтын алгоритмууд}

Хайлтаар олдсон өгөгдөл нь хэр оновчтой байх нь RAG-ийн хамгийн чухал хэсгүүдийн нэг ~\cite{huyen2024}. Өгөгдлийг вектор эсвэл өгөгдлийн бааз руу оруулах хялбар ч үүнээс хайлт хийх нь харьцангуй хүнд байдаг. Хамгийн түгээмэл алдаа нь векторт хэсэгчилж хуваагдахад өгүүлбэрүүд утга зүй бусаар хуваагдаж, хайлт хийх боломжгүй болдог. Иймээс хайлтын алгоритмаа зөв сонгох нь маш чухал. Дараах үндсэн хайлтын аргууд байдаг ~\cite{huyen2024}. 

\subsubsection{Нэр томьёо суурилсан хайлт}

Энэ арга нь түлхүүр үгээр баримт хайдаг. Энэ арга Google, Bing зэрэг хөтчийн хайлтын алгоритмд ашиглагдсаар ирсэн. Нэр томьёоны давтамж нь баримт доор нэр томьёо хэдэн удаа гарч байгааг хэмждэг бол баримтын урвуу давтамж нь нэр томьёо хэдэн баримтад гарч байгааг үндэслэн түүний чухлыг хэмждэг. Түгээмэл шийдлүүд нь Elasticsearch, BM25 зэрэг байдаг. Эдгээр нь урвуу индекс ашигладаг.

\subsubsection{Утга зүй суурилсан хайлт}

Утга зүйн хайлт гэж нэрлэгддэг энэ арга нь утга зүйн түвшинд холбоотой байдлаар тооцож ажилладаг. Баримт бүр хуваагдаж embedding загвар болгон хувиргагдаж, векторын өгөгдлийн санд хадгалагдана. Асуулт ирэх үед түүний embedding загвартай хамгийн ойр векторуудыг хайдаг.

Векторын хайлтын алгоритмууд нь олон янз байдаг. Хамгийн ойр хөршүүд нь энгийн арга боловч өгөгдөл их бол удаан байдаг. Ойролцоо хамгийн ойр хөршүүд нь хурдан боловч ойролцоогоор хайдаг. Иймээс өгөгдлийн ангилал, форматаас шалтгаалж өөр өөр хайлтын алгоритм ашигладаг. Locality-Sensitive Hashing нь ижил төстэй векторуудыг нэг bucket-д hash хийдэг. Hierarchical Navigable Small World нь олон давхаргат граф ашигладаг. Inverted File Index нь K-means clustering ашиглан векторуудыг бүлэглэдэг. Алдартай векторын өгөгдлийн сангууд нь FAISS, Milvus, Pinecone, Weaviate, Qdrant зэрэг байна.

\subsection{RAG-ыг сайжруулах аргууд}

RAG-ийг сайжруулах олон арга байдаг. Баримтуудыг хэрхэн хэсэглэж салгах нь чухал ~\cite{huyen2024}. Тогтмол уртаар хэсэглэх, өгүүлбэр догол мөрөөр хэсэглэх, утга зүйгээр хэсэглэх зэрэг олон ялгаатай арга байдаг. Нэр томьёо болон утга зүйн хайлтыг хослуулсан арга ашиглаж болно. Асуултыг дахин найруулж илүү сайн хайлт хийж болно. Хэсэг бүрийг metadata, түлхүүр үг, холбогдох асуултуудаар баяжуулах нь хайлтын чанарыг сайжруулдаг. Аливаа ажиллаж байгаа RAG-аас ялгаатай гаралтуудыг хадгалж үнэлвэл тохирсон хайлтын аргыг сонгоход ойлгомжтой болдог.

\section{Хиймэл оюуны агентууд}

\subsection{Агент}

Агент гэдэг нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. ~\cite{huyen2024}. Хиймэл оюунаар дэмжигдсэн агентууд нь суурь загварын хүч чадлаар дамжуулан бидний туслах, хамтран ажиллагч, багш байж чадна. Агент нь вебсайт бүтээх, өгөгдөл цуглуулах, аялал төлөвлөх, зах зээлийн судалгаа хийх, харилцагчийн данс удирдах, өгөгдөл оруулалтыг автоматжуулах зэрэг олон ажил хэрэгт тусалж чадна.

\subsection{Агентын бүрэлдэхүүн хэсгүүд}

Хиймэл оюун агентыг тодорхойлдог орчин ба хэрэглүүр гэсэн хоёр гол хэсгүүд байдаг. ~\cite{huyen2024}. Орчин нь аливаа агентийн ажиллах орчин ба жишээ нь интернэт, гал тогоо зэрэг байж болно. Энэхүү орчинд үйлдэл хийх боломжийг үүсгэж өгдөг зүйл бол хэрэглүүр ба хэрэглүүрүүдийг хангаснаар агентийн чадамжийг өргөсгөдөг. Үүнийг зураг \ref{fig:agentComponents}-т дүрслэв. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/agentPre.png}
    \caption{Агентын бүрэлдэхүүн хэсгүүд ~\cite{huyen2024}}
    \label{fig:agentComponents}
\end{figure}

\subsection{Хэрэглүүрүүд}

Хэрэглүүр байхгүй бол агентын чадамж маш хязгаарлагдмал байх болно. Уян хатан шийдвэр гаргалт, найдвартай гүйцэтгэлийн хоорондох хоосон зайг нөхдөг онцлогтой. Хэрэглүүрийг гурван ангилалд хуваагддаг ~\cite{huyen2024}.

\begin{enumerate}
  \item Мэдлэг нэмэгдүүлэх хэрэглүүрүүд нь хайлтаар нэмэгдүүлсэн үүсгэлт систем буюу RAG-ын бүрэлдэхүүн хэсгүүд юм. Үүнд текст хайгч, зураг хайгч, SQL гүйцэтгэгч, интернэтийн орчинд хайлт хийх, дотоод хайлтын системүүд зэрэг багтана.
  \item Чадамж өргөтгөх хэрэглүүрүүд нь агентын үндсэн чадварыг өргөжүүлдэг. Хиймэл оюун загварууд математикт сул байдаг тул агентд бэлэн тооцоолуурын API өгснөөр тооцоог оновчтой, хурдан, токены бага зарцуулалтаар гүйцэтгэх боломжийг үүсгэдэг.
  \item Бичих үйлдлийн хэрэглүүрүүд нь зөвхөн унших биш, өөрчлөлт оруулах хэрэглүүрүүд юм. Үүнд өгөгдлийн санд өгөгдөл нэмэх, засварлах, устгах, мэйл илгээх, банкны шилжүүлэг хийх, календарт тэмдэглэл нэмэх зэрэг үйлдлүүд багтана. Бичих үйлдэл нь өндөр эрсдэлтэй байдаг. Иймээс хортой промптын довтолгооноос болгоомжлох хэрэгтэй.
\end{enumerate}

\subsection{Агентын санах ой}

Хиймэл оюуны загвар нь гурван санах ойн механизмтай ~\cite{huyen2024}. Дотоод мэдлэг нь загварын өөрийн дотоод мэдээлэл юм. Энэ нь сургалтын өгөгдлөөс олж авсан мэдлэг бөгөөд загварыг шинэчлэхгүй л бол өөрчлөгдөхгүй. Богино хугацааны санах ой нь загварын контекст юм. Өмнөх мессежнүүд контекстэд нэмэгдэж болно. Даалгавар дууссаны дараа устдаг. Хурдан боловч устдаг шинжээр хязгаарлагдмал. Урт хугацааны санах ой нь гадаад өгөгдлийн эх сурвалж буюу хайлтаар нэмэгдүүлсэн үүсгэлт (RAG) юм.

\section{Төлөвлөгч агент (ReAct agent)}

ReAct (Reasoning Acting) агент буюу төлөвлөгч агент нь хэрэглүүрийн тусламжтайгаар аливаа асуудлыг эргэцүүлэн бодож шийдэл гаргадаг фреймворк юм ~\cite{reAct} ~\cite{huyen2024}. Үндсэндээ ямарваа нэгэн орчинд олон агентуудыг уяж ажлуулдгаараа онцлогтой. Энэ агент нь даалгаврыг алхам алхмаар бодож задлаад, шаардлагатай үед хайлт, тооцоолуур, API зэрэг гаднын хэрэглүүрүүдийг дуудах замаар шийдэл гаргаж ажилладаг. Ингэснээр уламжлалт чатботоос илүү уян хатан, дасан зохицох, асуудлыг шийдвэрлэх чадвартай байдаг ~\cite{reAct}. ReAct нь RAG-ийн хослолоор алдаа багатай, баримтын үндэслэлтэй хариу гаргах давуу талтай.

Зураг \ref{fig:agentPlanning}-т эхний үе шат нь хүсэлтийн дагуу төлөвлөгөө үүсгэх юм. Төлөвлөгч нь орчны мэдээллийг аваад процессийг гүйцэтгэх төлөвлөгөө боловсруулна. Хоёр дахь үе шат нь эргэцүүлэн бодох ба алдаа засах юм. Үүсгэсэн төлөвлөгөөг үнэлэх бөгөөд муу байвал шинэ төлөвлөгөө гаргана. Гурав дахь үе шат нь гүйцэтгэл юм. Төлөвлөгөөнд заасан үйлдлүүдийг хийнэ. Эцсийн үе шат нь үр дүнг үнэлэх явдал юм. Үйлдлийн үр дүнг хүлээн авсны дараа зорилго биелсэн эсэхийг тодорхойлж дахин сайжруулж болох лог үлдээнэ.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/agentPost.png}
  \caption{Агентын төлөвлөлт ~\cite{huyen2024}}
  \label{fig:agentPlanning}
\end{figure}

\subsection{Яагаад олон агентын зохиомж хэрэгтэй вэ?}

Агент нь тодорхой даалгаврын хүрээнд л процесс гүйцэтгэх чадвартай байдаг. Жинхэнэ бизнесийн үйл ажиллагаа нь олон дэд процессд хуваагдаж болдог шиг агентийн хэрэглээ мөн адил олон хуваагдаж болдог. Тиймээс олон агентийн зохиомж нь ялгаатай орчинд нарийн төвөгтэй асуудлыг шийдэх, дасан зохицох, үр дүнтэй хамтран ажиллах боломжийг олгодог.
Жишээлбэл байгууллага өөрсдийн сургасан үнэтэй загвартай байлаа гэж үзэхэд уг загварыг зөвхөн хэрэгтэй процессд нь ажиллуулаад, харин хямдхан GPT-2 зэрэг загвараар чиглүүлэгч, ангилагч зэрэг хямд процессд үлдээж болно. Иймээс олон агент зохиомжтой байх нь тооцооллын зардлыг бууруулж болох ба практикт тохиромжтой арга зам юм.

\subsection{Суурь загварууд төлөвлөгч болж чадах уу}

Зарим судлаачид суурь загвар нь төлөвлөгч болж чадахгүй гэж үздэг. ~\cite{falconer2025agents}. Учир нь төлөвлөлт нь үндсэндээ хайлтын асуудал бөгөөд авторегрессив буюу магадлалт суурилсан загвар нь үргэлж ялгаатай, буруу эсвэл төөрөгдсөн хариулт өгдөг. Гэвч бодит байдал дээр загвар өөр өөрийнхөө үүсгэсэн төлөвлөгөөг үнэлээд дахин эхэлж чаддаг тул сургалт сайн хийснээр төөрөгдлийг багасгаснаар сайн төлөвлөгөө гарч болно.

Төлөвлөлтийг сайжруулах олон арга байдаг. Илүү сайн системийн промпт заавар бичиж, жишээ олноор өгөх нь чухал. Хэрэглүүрүүдын тайлбарыг илүү сайн бичих хэрэгтэй. Функцуудийг хялбарчлах, задлах нь төлөвлөлтийг хөнгөвчилдөг. Илүү хүчтэй загвар ашиглах нь илүү сайн төлөвлөгөө гаргах боломжийг олгоно. Төлөвлөлтөд зориулж загварыг нарийвчлан сургах нь бас үр дүнтэй. Зарим судалгаагаар оновчтой хэрэглүүр өгөх нь нарийвчилсан сургалт хийснээс илүү үр дүнтэй бас хямд гэж үзжээ ~\cite{huyen2024}.

\section{Жишээ хиймэл оюунт программ хангамжийн зохиомж}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/charAIAgent.png}
    \caption{Хиймэл оюунт аппликейшн ~\cite{huyen2024} ~\cite{falconer2025agents}}
    \label{fig:charAIAgent}
\end{figure}

Зураг \ref{fig:charAIAgent}-т олон агентийн архитектурын зохиомжийг дүрсэлнэ. Программ хангамж хөгжүүлэхэд бэлэн суурь загвар эсвэл өөрсдөө байршуулсан загварыг ашиглаж болдог. Суурь загвар нь илүү их тооцоолол шаардаж, мөн хоцрогдол өндөр байдаг учраас үр ашигтай дасан зохицуулалт хийх шаардлагатай байдаг. Зурган дээрхээр хүсэлтийг ангилахад хямд агент болох RAG, чиглүүлэгч ашиглаж мөн эдгээр нь бусад үнэтэй агент руу шилжүүлж болно. Мэдээллийн аюулгүй байдлын үүднээс хиймэл оюуны оролт эсвэл гаралтыг хамгаалж болдог. 

\section{Ижил төстэй системүүдийн судалгаа}

Хиймэл оюун агентийг нэвтрүүлсэн хэд хэдэн үйлдвэрийн түвшний шийдлүүд байдаг. Эдгээр системүүдтэй харьцуулалт хийснээр энэ судалгааны санал болгож буй зохиомжийн онцлог байр суурийг тодорхойлно ~\cite{inngest} ~\cite{temporal}.

\textbf{Inngest} нь serverless workflow платформ бөгөөд үзэгдэлд суурилсан архитектур ба хэрэглэгчийн функцийн түвшинд ажилладаг. LLM интеграци байдаг ч RAG систем дутмаг байна. Систем нь асинхрон харилцаа, параллель боловсруулт дэмждэгээрээ найдвартай байдаг. Уг систем нь үүлэн технологи дээр байршдаг ба хаалттай эхийн программ хангамж юм. Голдуу startup, жижиг багуудад зориулагдсан.

\textbf{Temporal} нь хиймэл оюуны агенттай дэмжлэгтэй ба үйл явдлын төлөв байдлаа хадгалж, унасан ч яг өмнөх төлөв дээр буцан сэргэж чаддаг найдвартай ажиллагаатай платформ юм. Workflow хэлбэрээр л процесс гүйцэтгэгдэх тул өргөжихөд хүндрэлтэй байдаг. Мөн хаалттай эхийн программ хангамж юм. Uber, Netflix, Stripe зэрэг томоохон компаниуд ашигладаг.

Дээрх системүүдээс ялгаатай нь энэ судалгааны санал болгож буй зохиомж нь хиймэл оюун агентуудыг анхнаасаа бие дан өргөжих тархмал микросервис болгон хөгжүүлж, үйл явдлыг лог хэлбэрээр хадгалж найдвартай байдлыг хангахаар зохиомжлогдсон. Энэ нь бодит цагийн шийдвэр гаргалт, аудит тест хийх боломжийг нэмэгдүүлэх ба шинэ агентийг хялбараар нэмэх давуу талтай. Мөн энэ ажилд төлөвлөгч агент байх ба энэ нь динамикаар асуудлыг шинжилж, зөв хэрэглүүр дуудаж, процессийг гүйцэтгэж чаддагаар онцлогтой ~\cite{reAct}. Kafka-Flink зэрэг нээлттэй эхийн технологи нэвтрүүлж лог хадгалах нь Temporal шиг дахин сэргэх чадвар боломжийг нээж, логуудыг үнэлээд уг программ хангамжийг сайжруулах боломжийг олж нээж болно. Гэвч, найдвартай төлөвлөгч агент болон олон агентыг уялдуулж ажиллах нь хөгжүүлэлтийн хувьд нөөц их шаардана. Энэхүү зохиомж нь олон агентийг хямд, найдвартай, системтэйгээр нэвтрүүлэхийг зорьж буй байгууллагуудад зохимжтой.

\section{Бүлгийн дүгнэлт}

Энэхүү бүлэгт хиймэл оюуны инженерчлэлийн үндсэн ойлголтуудыг тайлбарлалаа. Хиймэл оюуны инженерчлэл нь бэлтгэгдсэн суурь загвар дээр програм хангамж хөгжүүлэхэд чиглэсэн шинэ салбар юм ~\cite{huyen2024}. Суурь загварын хөгжлийн замнал нь хэл загвараас том хэлний загвар, улмаар суурь загвар руу шилжих үйл явц байсан. Өөрийгөө удирдсан сургалт, Transformer архитектур, дараах сургалт аргууд нь өнөөгийн хүчирхэг хиймэл оюун системүүдийн суурь болсон.

Промпт инженерчлэл нь загварыг дасан зохицуулах хамгийн хялбар арга бөгөөд машин сургалт хийхгүйгээр программ хангамжид хиймэл оюун интеграц хийх боломжийг олгодог. RAG систем нь загварын сургалтаас авсан мэдлэгийн хязгаарлалтыг даван, гадаад эх сурвалжаас мэдээлэл авч хариултын найдвартай байдлыг нэмэгдүүлдэг.

Хиймэл оюун агент нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. Агентын гурван гол бүрэлдэхүүн нь орчин, үйлдэл, даалгавар юм. Олон агентын зохиомж нь нарийн төвөгтэй бизнес процессуудыг шийдэхэд илүү тохиромжтой бөгөөд агент бүр мэргэшсэн даалгавартай байснаар системийг өргөжүүлэх боломжтой болгодог.

Inngest, Temporal зэрэг одоо байгаа системүүдтэй харьцуулахад энэ судалгааны санал болгож буй зохиомж нь хиймэл оюун агентуудад зориулан тусгайлан бүтээгдсэн, Kafka-Flink суурилсан, нээлттэй эхийн технологи ашигладгаараа онцлогтой.

\chapter{Микросервис ба агентууд}

Энэхүү бүлэгт микросервис архитектурын онолыг судлах ба үзэгдэлд суурилсан архитектур (EDA), Apache Kafka, Apache Flink технологиудыг тайлбарлаж, агентуудыг микросервис болгон хөгжүүлэх үндэслэлийг тодорхойлно.

\section{Монолитоос микросервис рүү}

\subsection{Монолитын эрин үе}

Вэб аппликейшн хөгжүүлэлтийн эхэн үед гол архитектурын зохиомж нь монолит байв. Бүх бизнес логик, өгөгдлийн логикууд нэг том, нэгдсэн кодын санд амьдардаг байв. Программ хангамжийн хөгжүүлэгчид монолитуудыг хөгжүүлэхэд, нэвтрүүлэлт хийхэд энгийн, хялбар байв. ~\cite{wolff2016}

\subsection{Монолитыг өргөжүүлэх сорилт}

Гэвч аппликейшнууд томрох тусам асуудлууд нэмэгдсээр ирсэн. Монолитыг өргөжүүлэх нь бүх зүйлийг нэгтгэсэн байдлаар өргөжүүлдэг. Нэг модульд хийсэн жижиг өөрчлөлт аливаа кодын санд орсноор энэ нь шинэчлэлтийг удаашруулж, унах эрсдлийг нэмэгдүүлдэг. Өөр өөр дэд процесс дээр ажиллаж байгаа багууд бие биенийхээ кодод хамаарал бүхий харилцаагаар холбогдож, хөгжлийг удаашруулж, алдаа гарах эрсдлийг нэмэгдүүлсээр ирсэн.

Монолит архитектураас эхэлсэн компаниуд эдгээр асуудлууд тулгарж хурдан үйл ажиллагаагаа явуулахын тулд багууд системийг шинэчлэх хүртэл хүлээх шаардлагатай байв. Энэ нь компанийн бизнесийн үйл ажиллагаанд маш том саад бэрхшээл болов.

\subsection{Микросервис рүү шилжих}

Эдгээр хязгаарлалтаас ангижрахын тулд компаниуд микросервис архитектур руу шилжиж эхлэв ~\cite{wolff2016}. Энэ өөрчлөлт нь багуудад тархмал байдлаар өөрчлөлтийг хурдан байршуулалт хийх, аппликейшнийг дахин байршуулалт хийхгүйгээр шинэчлэл гаргах боломжийг олгосон. Микросервис рүү шилжих нь зөвхөн өргөжүүлэх чадварыг сайжруулаад зогсохгүй, багуудад бие даасан байдал өгч, хамтын ажиллагааны ачааллыг бууруулж, инновацийг хурдасгасан.

\subsection{Микросервисийн тодорхойлолт}

Микросервис архитектур нь програм хангамжийн гол зохиомжийн аргуудын нэг бөгөөд аппликейшныг жижиг, бие даасан сервисүүдэд хувааж, өргөтгөхөд хялбар байдлаар хөгжүүлдэг. Энэхүү архитектурын гол онцлог нь дөрвөн чухал шинж чанарт илэрхийлэгддэг. ~\cite{wolff2016}.

Нэгт, бие даан ажиллах чадвартай байдаг. Микросервис бүр ялгаатай бизнесийн логик агуулах ба шаардлагатай бол өөрийн өгөгдлийн сантай байдаг. Энэ нь сервис бүр бусад сервисээс хараат бус ажиллах боломжийг олгодог. Хоёрт, уян хатан хөгжүүлэлэх боломж юм. Өөр өөр багууд өөр өөр технологи, програмчлалын хэл ашиглан өөрсдийн сервисийг хөгжүүлж болдог. Энэ нь багууд өөрсдийн мэргэжлийн чиглэлд тохирсон технологи сонгох эрх чөлөөг өгдөг. Гуравт, өргөжих чадвар юм. Системийг нэгтгэсэн байдлаар өргөжүүлэх шаардлагагүй болно. Дөрөвт, найдвартай байдал ба хэрэв нэг сервис алдаа гарч унавал бусад сервисүүд хэвийн ажиллаж үргэлжлэнэ. Энэ нь системийн тогтвортой байдлыг хангадаг.

\section{Микросервисийн давуу тал}

Микросервис архитектур нь монолит системээс олон талаараа давуу талтай байдаг. Технологийн талаас авч үзвэл, сервис бүр өөрийн хэрэгцээнд хамгийн тохирсон технологи сонгох боломжтой. Жишээлбэл, нэг сервис Python програмчлалын хэл ашиглаж өгөгдөл боловсруулалт хийж болох бол нөгөө сервис Go ашиглан өндөр гүйцэтгэлтэй серверийн хэсэг хариуцаж, өөр нэг сервис Node.js ашиглан бодит цагийн холболт зэргийг удирдаж болно. ~\cite{nadareishvili2016}.

Багуудын бие даасан ажиллагааны хувьд баг бүр өөрийн сервисийг хараат бусаар хөгжүүлж, шууд хэрэглээнд нэвтрүүлэх чадвартай. Энэ нь багуудын хурд, уян хатан байдлыг нэмэгдүүлдэг. Хурдан нэвтрүүлэлтийн талаас авч үзвэл том системийг бүхэлд нь дахин нэвтрүүлэх шаардлагагүй бөгөөд зөвхөн өөрчлөлт орсон сервисийг л нэвтрүүлэхэд цаг хугацааг ихээхэн хэмнэдэг. Илүү сайн өргөжих чадварт ачаалал их байгаа тодорхой сервисийг л өргөжүүлэх нь бүх системийг бүхэлд нь өргөжүүлэхээс илүү үр ашигтай бөгөөд зардал хэмнэлттэй. Эцэст нь алдааны тусгаарлалтын талаас авч үзвэл нэг сервисийн алдаа нь бусад сервист шууд дамжихгүй тул системийн бусад хэсэг хэвийн үргэлжлэн ажилладаг.

\section{Микросервисийн сорилтууд}

Микросервис архитектур олон давуу талтай боловч практикт тулгарах сорилтууд багагүй байдаг. Нарийн төвөгтэй байдлын хувьд олон сервисүүдийг зэрэг удирдах, тэдгээрийн харилцааг хянах, байршуулалтыг хийх нь монолит системээс илүү төвөгтэй бөгөөд тусгай хяналтын хэрэгслүүд шаарддаг. ~\cite{nadareishvili2016}.

Сүлжээний хоцрогдлын талаас авч үзвэл сервисүүд хоорондоо сүлжээгээр харилцдаг учир нэмэлт хоцрогдол гардаг бөгөөд энэ нь системийн ерөнхий гүйцэтгэлд нөлөөлдөг. Олон сервисүүдээр дамжин явах хүсэлтийн алдааг олж тодорхойлох, засах ажил үйл ажиллагаа төвөгтэй байдаг. Сервисүүд хэрхэн үр дүнтэй харилцах, ямар протокол ашиглах, өгөгдлийн формат хэрхэн нийцүүлэх зэрэг олон нарийн асуудлыг шийдэхийг шаарддаг. Эцэст нь өгөгдлийн сангийн эсвэл үйлдлийн системийн транзакцийн удирдлагын асуудал нь олон сервисүүдээр транзакци явуулах нь өгөгдлийн сангууд түгжигдэх, тогтворгүй байдал үүсэх эрсдлийг нэмэгдүүлдэг. 

\section{Микросервис хоорондын харилцаа}

Микросервисүүд хоорондоо дараах хоёр аргаар харилцдаг: ~\cite{nadareishvili2016}.

\subsection{Синхрон харилцаа}

Синхрон харилцаа нь HTTP REST API эсвэл gRPC ашиглан шууд хүсэлт илгээж хариу хүлээдэг арга юм. Энэ арга нь хэрэгжүүлэхэд харьцангуй энгийн боловч сул талтай. Нэгт, нягт хамаарал буюу tight coupling үүсгэдэг. Сервисүүд бие биенээсээ шууд хамаарч байдаг учир нэг сервис өөрчлөгдөх үед бусад сервист нөлөөлдөг. Хоёрт, нэг сервис унавал түүнээс хамааралтай бусад сервисүүд ч гэсэн дамжин унадаг. Гуравт, хоцрогдол нэмэгддэг. Сервисүүд бие биенээсээ цуваа байдлаар хариу хүлээж байдаг учир хариул авах цаг удаан байх тусам ерөнхий системийн хоцрогдол нэмэгддэг.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/microservice.png}
    \caption{Синхрон микросервис ~\cite{AWSMicroservices}}
    \label{fig:microservicesync}
\end{figure}

Сервисийн тоогоор NxM холболтын харьцаагаар холболт нэмэгдэх учир үүнийг найдвартай удирдахад маш хүндрэлтэй болно. Зураг \ref{fig:conmicroservicesync}-д уг холбоосуудыг дүрсэлсэн ба бие биетэй хамааралтай байхад дамжин унах магадлал авчирдаг. Энэ ч утгаараа олон агент нэвтэрвэл дамжин унах эрсдэлтэй.  
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/conMonolith.png}
    \caption{Синхрон микросервисийн NxM холбоо ~\cite{falconer2025future}}
    \label{fig:conmicroservicesync}
\end{figure}

\subsection{Асинхрон харилцаа}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/microserviceEda.png}
    \caption{Асинхрон микросервис ~\cite{AWSMicroservices}}
    \label{fig:microserviceasync}
\end{figure}

Асинхрон харилцаа нь мессежийн дараалал ашигладаг арга бөгөөд RabbitMQ, Apache Kafka зэрэг технологиудыг ашиглан мессеж солилцдог. Энэхүү аргууд дараах онцлогтой. Эхний онцлог нь тархмал байдлаар ажиллах боломжийг бүрдүүлдэг. Сервисүүд мессежийн брокероор дамжин харилцдаг учир бие биенээсээ хараат бус байдаг. Хоёр дахь онцлог нь илүү найдвартай байдаг. Нэг сервис түр зуур унасан ч мессеж хадгалагдсан байх тул дараа нь боловсруулах боломжтой болдог. Гурав дахь онцлог нь синхрон харилцаанаас илүү төвөгтэй хэрэгжилттэй байдаг. Мессежийн формат тодорхойлох, алдааны менежмент хийх, мессежийн дараалал хангах зэрэг нэмэлт асуудлыг шийдэх шаардлагатай.

\section{Үзэгдэлд суурилсан архитектур буюу EDA}

\subsection{EDA гэж юу вэ}

Микросервисүүд гарч ирснээр шинэ сорилт бий болсон ~\cite{nadareishvili2016}. Хэрэв сервисүүдийг шууд gRPC эсвэл API-ээр холбовол асар том хамаарлын сүлжээ үүсдэг. Хэрэв нэг сервис унавал энэ нь холбогдсон замын дагуух бүх мөчир буюу node-д нөлөөлнө. Мөн бие биенийгээ цуваа байдлаар хүлээснээр гацалт маш ихээр үүсдэг.

EDA нь энэхүү асуудлыг шийдэж болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд event-driven асинхрон харилцах боломжийг олгодог. Сервисүүд бие биенийгээ хүлээхгүйгээр, параллель боловсруулалт хийдэг. Зураг \ref{fig:microserviceaconsync}-д NxM сүлжээний хамаарлыг арилгаж чадсан байна. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/conMicroservice.png}
    \caption{EDA суурилсан микросервис ~\cite{falconer2025future}}
    \label{fig:microserviceaconsync}
\end{figure}

\subsection{EDA-ын давуу тал}

Сервисүүд үйл явдлаар (event) харилцдаг учир тэд бие биенээсээ бүрэн хараат бус байж тархмал шинжтэй болдог. Нэг сервис өөрчлөгдөх эсвэл түр зуур унах нь бусад сервист шууд нөлөөлөхгүй бөгөөд энэ нь системийн уян хатан чанартай байдлыг нэмэгдүүлдэг.

Энэ нь бүх системийг өргөжүүлэхээс хамаагүй хялбар бөгөөд зардал хэмнэлттэй. Уян хатан байдлын хувьд шинэ сервис нэмэх эсвэл одоо байгаа сервисийг өөрчлөх нь бусад сервист өөрчлөлт шаардахгүй. Үйл явдлын формат өөрчлөгдөөгүй бол бусад сервисүүдийн ажиллагаа хэвээр байдаг. Бодит цагийн боловсруулалтын талаас авч үзвэл үйл явдлууд тэр даруйдаа боловсруулагдах тул систем нь өөрчлөлт, шинэ мэдээлэлд маш хурдан хариу үйлдэл үзүүлэх чадвартай.

\subsection{Apache Kafka}

Apache Kafka нь тархмал, өндөр дамжуулалттай, бага хоцрогдолтой EDA-ийн төв хэсэг болж чаддаг. ~\cite{kafka}.

\subsubsection{Kafka-гийн үндсэн ойлголтууд}

Apache Kafka-гийн архитектур нь таван үндсэн ойлголттой ~\cite{kafka}. Сэдэв буюу topic нь үйл явдлуудыг (event) ангилах логик сувгийн үүрэг гүйцэтгэдэг. Жишээлбэл "user-events", "order-events" гэх мэт нэршлээр үйл явдлуудыг ангилж хадгалдаг. Үйлдвэрлэгч буюу producer нь үйл явдлыг topic руу бичдэг аппликейшн юм. Хэрэглэгч буюу consumer нь эсрэгээр сэдвээс үйл явдлыг уншиж боловсруулдаг аппликейшн болно. Хэсэглэл буюу partition нь topic-ийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог механизм юм. Нэг topic олон partition-д хуваагдаж, параллель уншигдаж боловсруулагдах боломжтой. Эцэст нь хэрэглэгчийн груп буюу consumer group нь олон consumer нэг баг болон зохион байгуулагдаж ачааллыг хуваарилан боловсруулах боломжийг олгодог.

Хэвтээ өргөжих чадварын хувьд Kafka-гийн тархмал зохиомж нь шинэ сервис, эсвэл агент нэмэх боломжийг олгодог. Системийн ачаалал нэмэгдэх тусам partition нэмж, сервис нэмж өргөжүүлэх нь маш энгийн. Эцэст нь дахин ачааллуулж гүйцэтгэх боломжийн хувьд Kafka нь тархмал лог ашигладаг учраас үйл явдал бүр хадгалагдаж, алдаа засах, үнэлгээ хийх, загварыг дахин сургахад тохиромжтой.

\subsection{Apache Flink}

Apache Flink нь төлөв байдал удирддаг үйл явдлын боловсруулалт хийх чадвартай тархмал процессын удирдлагын фреймворк юм. ~\cite{flink} Flink нь Kafka-тай хамт ашиглах замаар хүчирхэг бодит цагийн өгөгдөл боловсруулалтын систем бүтээх боломжийг олгодог.

Apache Flink нь дараах давуу талуудтай. Flink нь төлөв байдлыг найдвартай удирдаж, нарийн төвөгтэй тооцоолол хийх боломжийг олгодог. Үйл явдлуудын хоорондох хамаарлыг хадгалж, өөр бусад цар хүрээний өгөгдлийг ашиглан нарийн шинжилгээ хийж чаддаг. Үйл явдлын цаг дээр үндэслэн бодит цагийн шинжилгээ хийх чадвартай. Энэ нь хоцрогдсон мессежнүүдийг зөв цагийн дагуу боловсруулах боломжийг олгодог. Flink нь секундэд сая сая үйл явдлыг боловсруулах чадвартай бөгөөд параллель боловсруулалт ашиглан асар их хэмжээний өгөгдлийг боловсруулж чаддаг. Эцэст нь "яг ганц" эшлэлээс ~\cite{flink} авч үзвэл мэдээлэл яг нэг удаа л боловсруулагддаг. Энэ нь өгөгдөл алдагдах эсвэл давхардах асуудлыг шийддэг.

\section{Flink ба ReAct төлөвлөгч}

Flink нь том хэлний загвартай ажиллах чадвартай. ~\cite{falconer2025future} Flink нь өгөгдлийг процессын төлөв байдалд хадгалж, том хэлний загвар руу илгээж, хариу аваад төлөв байдалдаа олон мэдээлэл нэгтгэх боломжийг олгодог. Энэ нь төлөвлөгч агентыг Flink болгон хөгжүүлэх зохимжтой байдаг ~\cite{polak2025}.

Жишээлбэл, эхлээд Kafka сэдвээс үйл явдлыг (events) уншина. Дараа нь аливаа нэгэн загвар ашиглан цар хүрээг ойлгох, даалгаврыг задлах, төлөвлөгөө гаргах үйл явцыг гүйцэтгэнэ. Үр дүнг өөр Kafka topic руу бичнэ. Эцэст нь энэ topic-ийг хүлээж авах агентууд энэ үр дүнг уншиж процессоо гүйцэтгэнэ. Иймээс ReAct(Reasoning Acting) буюу төлөвлөлтийн дагуу ажиллаж чаддаг байна. Үүнийг хэрэгжүүлэлт дээр бататгах болно. 

\section{Бүлгийн дүгнэлт}

Энэхүү бүлэгт микросервис архитектурын онол, практик, түүнчлэн EDA-ийн давуу талыг дэлгэрүүлэн судалсан. Монолит системээс микросервис рүү шилжих нь программ хангамжийн хөгжлийн чухал дэвшил болов. ~\cite{falconer2025future}

Микросервис хоорондын харилцаа нь хоёр гол аргаар хэрэгждэг. Синхрон харилцаа нь HTTP REST эсвэл gRPC ашигладаг боловч нягт хамаарал үүсгэж, нэг сервис унавал бусад сервисүүдэд алдаа гаргадаг. Сервисийн тоогоор NxM холболтын нарийн төвөгтэй байдал нь системийг удирдахад хүндрэлтэй болгодог. Асинхрон харилцаа нь мессежийн брокер ашигладаг бөгөөд тархмал байдлыг бий болгож, найдвартай боловч илүү төвөгтэй хэрэгжилттэй.

EDA нь микросервисийн энэхүү харилцааны хамгийн үр дүнтэй шийдэл болдог. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар (kafka event) асинхрон харилцах боломжийг олгодог. Тархмал байдал, өргөжүүлэх чадвар, уян хатан байдал, бодит цагийн боловсруулалт зэрэг давуу талууд нь EDA-г орчин үеийн микросервис архитектурын суурь болгосон.

Apache Kafka нь EDA-ын хүчирхэг хэрэглүүр ба "Topic, producer, consumer, partition, consumer group" зэрэг үндсэн ойлголтууд нь системийг өргөжүүлэх, параллель боловсруулалт хийх боломжийг олгодог. ~\cite{polak2025} Kafka-ийн хэвтээ өргөжих чадвар, бага хоцрогдол, тархмал байдал, үйл явдлын хадгалалт, дахин тоглуулах боломж зэрэг онцлогууд нь өргөн ашиглагддаг шалтгаан болов.

Apache Flink нь Kafka-тай хамт ашиглахад илүү хүчирхэг болдог. Өгөгдөл холбож дамжуулах боловсруулалт, өндөр дамжуулалт, "яг л нэг" зарчим зэрэг давуу талууд нь нарийн төвөгтэй урсгал боловсруулалтад тохиромжтой. Flink нь хиймэл оюуны загвартай холбогдож, төлөвлөгч агентыг Flink app болгон хөгжүүлэх боломжийг олгодог. Flink болон RAG-ийг хослуулах нь төөрөгдлийг багасгаж, бодит өгөгдөлд суурилсан хиймэл оюун систем бүтээхэд тусалдаг.

Хиймэл оюун агентууд бүр өөр өөрийн гэсэн даалгаврын цар хүрээ хариуцах учраас микросервис шиг тархмал байдлаар ашиглагдвал цаашдын хиймэл оюунт программ хөгжүүлэхэд үр дүнтэй. Агентуудын олон цар хүрээт мэдээллийн хамаарлаар, олон хэрэглэгчдэд үйлчлэхэд EDA зайлшгүй шаардлагатай болгодог. Агентуудыг gRPC эсвэл API-аар холбох нь боломжтой боловч нягт холбоос үүсгэж, өргөжүүлэх, дасан зохицоход хүндрэлтэй болгодог. EDA нь агентуудыг тархмал микросервис болгон хөгжүүлэх, өргөжүүлэх, найдвартай байлгах хамгийн тохиромжтой арга замуудын нэг болох юм.

Энэхүү бүлгээс харахад микросервис архитектур нь монолитын асуудлуудыг шийдэж чадсан боловч шинэ сорилтууд авчирсан. EDA, Kafka, Flink зэрэг технологиуд нь эдгээр сорилтуудыг шийдэж, илүү уян хатан, өргөжих боломжтой, найдвартай систем бүтээх суурийг бүрдүүлсэн. Дараагийн бүлэгт эдгээр онолуудыг ашиглан тодорхой асуудлуудыг хэрхэн шийдэх талаар авч үзнэ.

% Асуудлын тодорхойлолт ба шийдэл - Нэгдсэн бүлэг
\include{src/problem-solution}

% Хэрэгжүүлэлт бүлэг
\include{src/implementation}

%----------------------------------------------------------------------------------------
%   Дүгнэлт эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\conclusion{Дүгнэлт}

Энэхүү судалгааны ажил нь орчин үеийн мэдээллийн технологийн хоёр гол чиг хандлага болох микросервис архитектур ба хиймэл оюуны агентыг нэгтгэн судалсан. Микросервис архитектур нь системүүдийг жижиг, бие даасан, өргөтгөх боломжтой нэгжүүд болгон хувааж хөгжүүлэх орчин үеийн аргачлал бөгөөд хиймэл оюуны агент нь тархмал орчинд бие даан шийдвэр гаргах чадвартай программчлалын загвар юм. Эдгээр хоёр чиглэлийг нэгтгэснээр системийн архитектур, тархмал боловсруулалт, хиймэл оюуны логик, агентуудын харилцаа зэрэг олон талт ойлголтыг хослуулсан судалгааны ажил болсон.

\textbf{Онолын үр дүн:}

Судалгааны явцад хиймэл оюуны инженерчлэлийн үндсийг гүнзгий судлав. Хэл загвараас том хэлний загвар, улмаар суурь загвар руу хөгжих үйл явц нь арван жилийн технологийн дэвшлийн үр дүн бөгөөд өөрийгөө удирдсан сургалт, Transformer архитектур, дараах сургалт аргууд нь энэхүү хөгжлийн гол түлхүүрүүд болсон. Хиймэл оюун агентуудын онол нь орчин, үйлдэл, даалгавар гэсэн гурван бүрэлдэхүүн дээр суурилж, төлөвлөлт, хэрэглүүрийн хэрэглээ, эргэцүүлэн бодох чадвартай.

Микросервис архитектурын давуу тал болох бие даасан байршуулалт, технологийн уян хатан байдал, хэвтээ өргөжих боломж нь хиймэл оюун агентуудыг тархмал сервис болгон хөгжүүлэхэд тохиромжтой болохыг тодорхойлсон. Гэвч синхрон харилцааны NxM холболтын нарийн төвөгтэй байдал нь EDA шаардлагатай болохыг батлав.

\textbf{Практик үр дүн:}

Монголын Хөрөнгийн Биржийн бодит өгөгдөлд суурилсан демо систем амжилттай хөгжүүлсэн. Системд дараах таван агент хэрэгжүүлсэн:

\begin{enumerate}
    \item Төлөвлөгч агент (Orchestrator): ReAct загварын дагуу хэрэглэгчийн хүсэлтийг Gemini AI-аар ангилж, хэрэглэгчийн профайл авч, зохих агент руу чиглүүлдэг
    \item Хөрөнгө оруулалтын агент: МХБ өгөгдөлд суурилан хэрэглэгчийн эрсдлийн хүлээцтэй байдал, хөрөнгө оруулалтын зорилгод тохируулсан монгол хэл дээрх хувийн зөвлөмж өгдөг
    \item Мэдээний агент: Finnhub API-аас мэдээ татаж, AI-аар утга зүйн шинжилгээ хийж, хураангуй бэлддэг
    \item Мэдлэгийн агент: RAG системийн үүргийг гүйцэтгэж, мэдлэгийн сангаас холбогдолтой мэдээлэл хайдаг
    \item PyFlink төлөвлөгч: Нарийн төвөгтэй даалгаврыг олон алхамт төлөвлөгөө болгон задалдаг
\end{enumerate}

Apache Kafka ашиглан 8 сэдвээр агентуудын асинхрон харилцааг зохион байгуулсан нь агентуудыг бие даасан, тархмал байлгаж, хэвтээ өргөжих боломжийг олгосон. Системийн гүйцэтгэлийн хэмжилтээр Kafka мессеж 5-10ms, PostgreSQL хайлт 50-100ms, бүрэн AI шинжилгээ 5-12 секундэд хийгдэж байна.

\textbf{Хязгаарлалт ба цаашдын чиглэл:}

Судалгааны хүрээ өргөн байсан тул зарим хэсгийг гүнзгийрүүлэх боломж хязгаарлагдмал байв. Суурь загварын хоцрогдол, өртөг, найдвартай байдал зэрэг асуудлууд байгаа боловч технологи хурдацтай хөгжиж байгаа тул ойрын ирээдүйд эдгээр асуудлууд шийдэгдэнэ. Цаашид агентуудын санах ойн удирдлага, олон агентын хамтын ажиллагаа, Монгол хэлний NLP оновчлол зэрэг чиглэлээр судалгааг үргэлжлүүлэх боломжтой.

\textbf{Дүгнэлт:}

Энэхүү дипломын ажил нь хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг онол, практикийн хувьд судалж, ажиллагаатай демо систем хөгжүүлснээр санал болгосон зохиомжийн үр ашигтай байдлыг баталгаажуулсан. Хиймэл оюуны инженерчлэл, микросервис архитектур, EDA зэрэг орчин үеийн технологиудыг хослуулсан нь ирээдүйн программ хангамжийн хөгжүүлэлтэд чухал суурь болно гэж үзэж байна.

%----------------------------------------------------------------------------------------
%   Дипломын номзүй, хавсралтын хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------

\singlespace
\addcontentsline{toc}{part}{НОМ ЗҮЙ}
\begin{thebibliography}{99}
	% Үндсэн ном зохиол
	\bibitem{huyen2024}
	Huyen, Chip. \textit{AI Engineering}. O'Reilly Media, 2024.
	
	\bibitem{goldman2023}
	Goldman Sachs Research. "Generative AI Could Raise Global GDP by 7\%", 2023. 
	\url{https://www.goldmansachs.com/intelligence/pages/generative-ai-could-raise-global-gdp-by-7-percent.html}
	
	% Foundation Models
	\bibitem{vaswani2017}
	Vaswani, A., et al. "Attention Is All You Need". \textit{Advances in Neural Information Processing Systems}, 2017.
	
	% RAG
	\bibitem{gao2023}
	Gao, Y., et al. "Retrieval-Augmented Generation for Large Language Models: A Survey". \textit{arXiv preprint arXiv:2312.10997}, 2023.
	
	% AI Agents
  \bibitem{reAct}
  What is ReAct Agent? \url{https://www.ibm.com/think/topics/react-agent}
	
	% Prompt Engineering
	\bibitem{openai2023}
	OpenAI. "Prompt Engineering Guide", 2023. \url{https://platform.openai.com/docs/guides/prompt-engineering}
	
	% Microservices
	\bibitem{newman2015}
	Newman, Sam. \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media, 2015.
	
	
	\bibitem{fowler2014}
	Fowler, Martin and Lewis, James. "Microservices: A Definition of This New Architectural Term", 2014. \url{https://martinfowler.com/articles/microservices.html}
	
	
	% API & Integration
	\bibitem{fielding2000}
	Fielding, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.
	
	% Python & Tools
	\bibitem{python}
	Python Software Foundation. "Python 3 Documentation". \url{https://docs.python.org/3/}
	
	\bibitem{gemini-api}
	Gemini. "Gemini API Reference". \url{https://ai.google.dev/gemini-api/docs}
	
	\bibitem{faiss}
	Facebook AI Research. "FAISS: A Library for Efficient Similarity Search". \url{https://github.com/facebookresearch/faiss}
	
	% Event-Driven Architecture & Streaming
	\bibitem{falconer2025agents}
	Falconer, Sean. "AI Agents are Microservices with Brains". Medium, March 2025. \url{https://medium.com/@seanfalconer}
	
	\bibitem{falconer2025future}
	Falconer, Sean. "The Future of AI Agents is Event-Driven". BigDataWire, March 2025.
	
	\bibitem{polak2025}
	Polak, Adi. "Building AI Agents with Event-Driven Microservices". Confluent Developer Advocate, 2025.
	
	\bibitem{kafka}
	Apache Kafka Documentation. "Apache Kafka: A Distributed Streaming Platform". \url{https://kafka.apache.org/documentation/}
	
	\bibitem{flink}
	Apache Flink Documentation. "Stateful Computations over Data Streams". \url{https://flink.apache.org/}

  \bibitem{temporal}
  Temporal Documentation. \url{https://docs.temporal.io/}

	\bibitem{inngest}
	Inngest Documentation. \url{https://www.inngest.com/}
	
	% Microservices Evolution
	\bibitem{wolff2016}
	Wolff, Eberhard. \textit{Microservices: Flexible Software Architecture}. Addison-Wesley Professional, 2016.
	
	\bibitem{nadareishvili2016}
	Nadareishvili, Irakli, et al. \textit{Microservice Architecture: Aligning Principles, Practices, and Culture}. O'Reilly Media, 2016.
	
	% Anthropic MCP
	\bibitem{anthropic2024mcp}
	Anthropic. "Model Context Protocol: A Universal Standard for AI Integration", 2024. \url{https://www.anthropic.com/news/model-context-protocol}

  \bibitem{AWSMicroservices}
  AWS. "What are Microservices?". \url{https://aws.amazon.com/microservices/}
	
\end{thebibliography}


%----------------------------------------------------------------------------------------
%   Хавсралтууд эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\appendix
\addcontentsline{toc}{part}{ХАВСРАЛТ}

% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
\chapter{Хэрэгжүүлэлтийн үр дүн}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/homePage.png}
    \caption{Нэвтрэх хуудас}
    \label{fig:homePage}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/dashboardPage.png}
    \caption{Нүүр хуудас}
    \label{fig:dashboardPage}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/welcome.jpg}
    \caption{AI Боловсруулсан бүртгэлийн мэдэгдлийг э-мэйлээр авах}
    \label{fig:mailRegistration}
\end{figure}

Хэрэглэгч системд бүртгүүлэхэд хөрөнгө оруулах зорилго, эрсдлийн үнэлгээ, хөрөнгө оруулах зорилго зэрэг мэдээлэл оруулж байгаа ба бүртгэлийн дараа хиймэл оюун агентд уг мэдээллийг өгч, тохирсон э-мэйл агуулга гаргаж хэрэглэгч рүү илгээнэ. Зургийн ёроолд API Лог үр дүнг доор үзүүлэв.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/daily.png}
    \caption{AI боловсруулсан өдөр тутмын мэдээний э-мэйл авах}
    \label{fig:dailyEmail}
\end{figure}

Хэрэглэгч өөрийн сонирхсон хувьцааны мэдээллээ системд бүртгүүлж болох ба, хиймэл оюун ашиглаж бүх хэрэглэгчдэд өдөр тутмын сонирхсон мэдээг нь илгээж болно. Finnhub API ашиглана. Хэрвээ мэдээлэл олдохгүй бол ерөнхий мэдээ илгээнэ.  

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/huvitsaa.png}
  \caption{Хөрөнгө оруулалтын агентийн хэрэглэгчийн хувийн зөвлөмж авах}
  \label{fig:aiResponse}
\end{figure}

Төлөвлөгч агент нь "KHAN хувьцааны талаар товч мэдээлэл өгнө үү" гэсэн хүсэлтээр хэрэглэгчийн мэдээлэл болон хаан банкны хувьцааны мэдээллийг нэгтгэж Gemini AI-аар шинжилгээ хийнэ. Хэрэглэгчийн мэдээлэлд эрсдлийн хүлээцтэй байдал, зорилго зэрэг мэдээ байх ба агент нь үүний үндсэнд тохирсон зөвлөгөө өгнө.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{figures/health.png}
  \caption{Агентийн ажиллаж байгаа процессуудын мониторинг}
  \label{fig:monitoringProcesses}
\end{figure}

Байршуулалтаа docker дээр хийгдсэн ба, бүх агент, сервис ажиллаж байгаа эсэхийг мониторинг дүрсэлж байна. Kafka UI дээр бүх topic-үүд, кластер, хүлээн авагч Stable буюу асуудалгүй ажиллаж байна. Postman-аар агент хоорондын харилцааг мөн системийн нөөцийн ашиглалтыг шалгасан. Нийт процессүүд ойролцоогоор idle үед 123mb ашиглаж байна. 

\chapter{Кодын жишээ}

Энэхүү хавсралтад системийн гол бүрэлдэхүүн хэсгүүдийн кодын жишээг оруулав.

\section{Төлөвлөгч агент: Хэрэглэгчийн хүсэлт боловсруулах}

Төлөвлөгч агент нь user.requests topic-оос хүсэлт хүлээн авч, intent ангилж, хэрэглэгчийн профайл авч, зохих агент руу чиглүүлнэ.

\begin{lstlisting}[language=JavaScript, caption=Orchestrator Agent - Request Processing]
private async processUserRequest(payload: any): Promise<void> {
  const { requestId, userId, query, type, context } = payload;
  
  // Step 1: Classify intent using Gemini AI
  const intent = type || await intentClassifier.classify(query);
  logger.info(`Intent classified: ${intent}`, { requestId });

  // Step 2: Fetch user profile for personalization
  let userProfile = null;
  if (userId && agentType === 'investment') {
    userProfile = await this.getUserProfile(userId);
  }

  // Step 3: Detect complexity
  const complexity = await complexityDetector.detect(query);

  // Step 4: Route based on complexity
  if (complexity.level === 'simple') {
    await this.routeToAgent(requestId, userId, intent, query);
  } else {
    await this.routeToPlanner(requestId, userId, intent, query);
  }
}

private async getUserProfile(userId: string): Promise<any> {
  const result = await db.query(
    `SELECT investment_goal, risk_tolerance, 
            preferred_industries
     FROM users WHERE id = $1`,
    [userId]
  );
  return result.rows[0] || {};
}
\end{lstlisting}

\section{Хөрөнгө оруулалтын агент: Хувийн зөвлөмж үүсгэх}

Хэрэглэгчийн профайлд суурилан МХБ хувьцааны шинжилгээ хийж, монгол хэлээр зөвлөмж өгнө.

\begin{lstlisting}[language=JavaScript, caption=Investment Agent - Personalized Response]
async function generateAIResponse(action: string, payload: any) {
  const { userId, query, userProfile } = payload;
  const symbols = payload.context?.symbols || [];
  
  // Fetch MSE data from PostgreSQL
  const mseData = symbols.length > 0 
    ? await getMSEData(symbols) 
    : await getMSEData();
  
  // Build personalization context
  let context = '';
  if (userProfile) {
    context = `User Profile:
- Goal: ${userProfile.investmentGoal}
- Risk Tolerance: ${userProfile.riskTolerance}
- Preferred Industries: ${userProfile.preferredIndustries}

IMPORTANT: If risk is "Low", recommend safe stocks.
If risk is "High", recommend growth stocks.`;
  }
  
  // Generate response with Gemini AI
  const prompt = `MSE Analyst. MONGOLIAN, BRIEF (150 words).
${context}
MSE Data: ${JSON.stringify(mseData.slice(0, 8))}
Query: ${query}
Provide personalized investment advice.`;

  const result = await model.generateContent(prompt);
  return result.response.text();
}
\end{lstlisting}

\section{API Gateway: Kafka Event Publishing}

Хэрэглэгчийн асуултыг Kafka-ийн user.requests topic руу илгээнэ.

\begin{lstlisting}[language=JavaScript, caption=API Gateway - Kafka Event Publishing]
router.post('/query', async (req: Request, res: Response) => {
  const { query, type, context } = req.body;
  const userId = getUserId(req);
  const requestId = uuidv4();

  // Send to Kafka user.requests topic
  await kafkaService.sendEvent('user.requests', requestId, {
    requestId,
    userId,
    timestamp: new Date().toISOString(),
    query,
    type: type || undefined,
    context: context || {},
  });

  res.json({
    success: true,
    requestId,
    message: 'Query submitted successfully',
    pollEndpoint: `/api/agent/response/${requestId}`,
  });
});
\end{lstlisting}

\section{PyFlink Planner: Execution Plan Generation}

Нарийн төвөгтэй даалгаврыг олон алхамт төлөвлөгөө болгон задална.

\begin{lstlisting}[language=Python, caption=PyFlink Planner - Plan Generation]
def generate_execution_plan_with_gemini(task: dict) -> dict:
    query = task.get('query', '')
    intent = task.get('intent', '')
    
    prompt = f"""Generate execution plan for financial AI.
Query: {query}
Intent: {intent}

Available Agents:
1. knowledge - RAG for MSE company info
2. investment - Portfolio analysis, recommendations
3. news - Financial news and sentiment

Generate JSON with steps array. Max 3 steps."""

    response = model.generate_content(prompt)
    plan = json.loads(response.text)
    
    # Send tasks to each agent
    for step in plan.get('steps', []):
        agent_task = {
            "taskId": str(uuid.uuid4()),
            "agentType": step.get('agent'),
            "action": step.get('action'),
            "payload": step.get('params', {}),
        }
        producer.send('agent.tasks', 
                      value=json.dumps(agent_task))
    
    return plan
\end{lstlisting}

\section{Мэдээний агент: Sentiment Analysis}

Finnhub API-аас мэдээ татаж, Gemini AI-аар sentiment шинжилгээ хийнэ.

\begin{lstlisting}[language=JavaScript, caption=News Agent - Sentiment Analysis]
async function analyzeSentiment(headline: string, summary: string) {
  const prompt = `Analyze sentiment of this financial news:

Headline: ${headline}
Summary: ${summary}

Respond with ONLY ONE WORD: positive, negative, or neutral.`;
  
  const result = await model.generateContent(prompt);
  const sentiment = result.response.text().trim().toLowerCase();
  
  if (['positive', 'negative', 'neutral'].includes(sentiment)) {
    return sentiment;
  }
  return 'neutral';
}

async function handleNewsTask(message: any) {
  const news = await fetchNews(message.payload.symbol);
  
  // Analyze sentiment for each article
  const processedNews = [];
  for (const item of news.slice(0, 5)) {
    const sentiment = await analyzeSentiment(
      item.headline, item.summary
    );
    processedNews.push({ ...item, sentiment });
  }
  
  // Generate summary
  const summary = await model.generateContent(
    `Summarize these news: ${JSON.stringify(processedNews)}`
  );
  
  return { news: processedNews, summary: summary.text() };
}
\end{lstlisting}



\end{document}
