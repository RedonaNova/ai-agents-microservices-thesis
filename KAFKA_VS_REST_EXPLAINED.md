# ğŸ”„ Kafka vs REST API - Complete Explanation

**Your Question**: "We're using REST API instead of Kafka on some parts. How do we get responses from Kafka?"

---

## ğŸ¯ The Architecture Explained

### Why Mix REST and Kafka?

Your system uses **BOTH** for different purposes:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Frontend   â”‚
â”‚  (Browser)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘  REST API (synchronous)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  API Gateway     â”‚ â† You are here
â”‚  (Port 3001)     â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
     â”‚      â‘¡ Kafka (asynchronous)
     â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  Kafka    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•
     â”‚
     â†“
  [Agents]
```

**Why this hybrid approach?**
- **REST**: Frontend â†” API Gateway (browsers can't use Kafka directly)
- **Kafka**: API Gateway â†” Backend Agents (event-driven, scalable)

---

## ğŸ“ How It Actually Works

### Step-by-Step Flow

#### **1. User Sends Query (REST)**
```typescript
// Frontend code
const response = await fetch('http://localhost:3001/api/agent/query', {
  method: 'POST',
  body: JSON.stringify({ query: "Investment advice?", type: "investment" })
});

const { requestId } = await response.json();
// Response: {"success": true, "requestId": "abc-123"}
```

**What happens**: API Gateway receives HTTP request, generates requestId

---

#### **2. API Gateway Publishes to Kafka**
```typescript
// API Gateway (agent.routes.ts)
await kafkaService.sendEvent('user.requests', requestId, {
  requestId,
  query: "Investment advice?",
  type: "investment"
});
```

**What happens**: Message published to Kafka `user.requests` topic

---

#### **3. Orchestrator Consumes from Kafka**
```typescript
// Orchestrator Agent
consumer.run({
  eachMessage: async ({ message }) => {
    const request = JSON.parse(message.value);
    // Classify intent and route to appropriate agent
    await kafkaService.send('agent.tasks', {...});
  }
});
```

**What happens**: Orchestrator reads from Kafka, routes to Investment Agent

---

#### **4. Investment Agent Processes**
```typescript
// Investment Agent
consumer.run({
  eachMessage: async ({ message }) => {
    const task = JSON.parse(message.value);
    // Generate AI response with Gemini
    const response = await generateInvestmentAdvice(task.query);
    // Publish response back to Kafka
    await kafkaService.send('agent.responses', {
      requestId: task.requestId,
      response: response
    });
  }
});
```

**What happens**: Agent generates response, publishes to `agent.responses` topic

---

#### **5. Frontend Gets Response (SSE)**

**Option A: Server-Sent Events** â­ **RECOMMENDED**

```typescript
// Frontend code
const eventSource = new EventSource(
  `http://localhost:3001/api/agent/stream/${requestId}`
);

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  if (data.type === 'connected') {
    console.log('âœ… Connected, waiting for AI...');
  } 
  else if (data.response) {
    console.log('ğŸ¤– AI Response:', data.response);
    // Display in UI
    setAiResponse(data.response);
  }
  else if (data.type === 'complete') {
    eventSource.close();
  }
};
```

**What happens**: 
- API Gateway subscribes to `agent.responses` Kafka topic
- Filters messages by requestId
- Streams responses to frontend via SSE

---

## ğŸ” Testing the Complete Flow

### Test 1: Send Query
```bash
curl -X POST http://localhost:3001/api/agent/query \
  -H "Content-Type: application/json" \
  -d '{"query": "Investment advice for 10M MNT", "type": "investment"}'

# Response:
# {"success": true, "requestId": "abc-123"}
```

### Test 2: Stream Response with SSE
```bash
# This will wait for AI response
curl -N http://localhost:3001/api/agent/stream/abc-123

# Output:
# data: {"type":"connected","requestId":"abc-123"}
# 
# data: {"requestId":"abc-123","response":"Based on your...","status":"success"}
# 
# data: {"type":"complete"}
```

---

## ğŸ§ª YOUR TEST RESULTS (Just Now)

### âœ… What Worked:

1. **Query Submitted**: 
   ```json
   {
     "success": true,
     "requestId": "2db739f7-78a3-4a71-bc57-6604e3dc2053"
   }
   ```

2. **Orchestrator Received**: âœ…
   ```
   ğŸ“¥ New user request
   ğŸ§  Intent classified: investment
   âš¡ Complexity: simple
   â¡ï¸  Routing to investment agent
   ```

3. **Investment Agent Processed**: âœ…
   ```
   ğŸ“¥ Processing task
   âœ… Task completed (duration: 16831ms)
   ```

4. **SSE Connection Established**: âœ…
   ```
   data: {"type":"connected","requestId":"2db739f7..."}
   ```

### â³ What's Happening:
- Response is being generated by Gemini AI
- Will be published to `agent.responses` Kafka topic
- SSE will stream it to frontend when ready

---

## ğŸ’¡ Implementing Chat History

To show past conversations, add a database table:

### Backend Changes:

```sql
-- Add to schema.sql
CREATE TABLE chat_history (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id),
  request_id UUID UNIQUE,
  query TEXT NOT NULL,
  response TEXT,
  agent_type VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP
);
```

```typescript
// In Investment Agent (after generating response)
async function saveToHistory(requestId, query, response) {
  await db.query(
    `INSERT INTO chat_history (user_id, request_id, query, response, agent_type, completed_at)
     VALUES ($1, $2, $3, $4, $5, NOW())`,
    [userId, requestId, query, response, 'investment']
  );
}
```

```typescript
// New API endpoint in API Gateway
router.get('/chat/history', authenticate, async (req, res) => {
  const userId = req.userId;
  const result = await db.query(
    `SELECT * FROM chat_history 
     WHERE user_id = $1 
     ORDER BY created_at DESC 
     LIMIT 50`,
    [userId]
  );
  res.json({ success: true, history: result.rows });
});
```

### Frontend:

```typescript
// Fetch chat history
async function getChatHistory() {
  const res = await fetch('http://localhost:3001/api/chat/history', {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  const { history } = await res.json();
  return history;
}

// Display in UI
history.map(chat => (
  <div key={chat.id}>
    <div className="user-message">{chat.query}</div>
    <div className="ai-message">{chat.response}</div>
  </div>
))
```

---

## ğŸ¯ Summary

### Why REST + Kafka?

| Component | Protocol | Reason |
|-----------|----------|--------|
| **Frontend â†’ API Gateway** | REST API | Browsers don't support Kafka |
| **API Gateway â†’ Agents** | Kafka | Event-driven, scalable, async |
| **Agents â†’ API Gateway** | Kafka | Asynchronous responses |
| **API Gateway â†’ Frontend** | SSE | Real-time streaming over HTTP |

### Getting Responses: 3 Options

| Method | Implementation | Best For |
|--------|----------------|----------|
| **SSE** | âœ… Already implemented | Real-time, production |
| **Polling** | Need to add DB + endpoint | Quick demo |
| **Chat History** | Need DB table | Thesis demo â­ |

### What's Currently Working:

âœ… Query submission (REST â†’ Kafka)  
âœ… Orchestrator routing (Kafka â†’ Kafka)  
âœ… Agent processing (Kafka â†’ Kafka)  
âœ… SSE connection (Kafka â†’ SSE â†’ REST)  
â³ Response streaming (works, needs testing)  

---

## ğŸš€ Next Steps

1. **Test SSE with Frontend** - Implement EventSource in React
2. **Add Chat History** - Save conversations to database
3. **Improve Error Handling** - Show errors in UI
4. **Add Loading States** - Show "AI is thinking..."

---

**Key Insight**: You're NOT "using REST instead of Kafka" - you're using **BOTH**!
- REST is the **interface** for browsers
- Kafka is the **backbone** for agents
- SSE is the **bridge** between them

This is actually a **best practice** for microservices! ğŸ‰

