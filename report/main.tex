%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode
\documentclass[12pt,a4paper]{report}

\usepackage{fontspec,xltxtra,xunicode}
\setmainfont[Ligatures=TeX]{Times New Roman}
\setsansfont{Arial}

% \usepackage[utf8x]{inputenc}
% \usepackage[mongolian]{babel}
%\usepackage{natbib}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\setlength{\headheight}{29.03363pt}
%\usepackage{fancyheadings} fancyheadings is obsolete: replaced by fancyhdr. JL
\usepackage{fancyhdr}
% Set up page numbering style
\pagestyle{fancy}
\fancyhf{} % Clear all headers and footers
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{float}
\usepackage{afterpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsbsy}
\usepackage{dcolumn,array}
\usepackage{tocloft}
\usepackage{styles/dics}
% Ensure proper page numbering after dics.sty is loaded
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage} % Page number at center bottom
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\usepackage{nomencl}
\usepackage{upgreek}
\newcommand{\argmin}{\arg\!\min}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}

% Packages for better text wrapping and line breaking
\usepackage{microtype} % Improves text appearance and reduces overfull boxes
\usepackage{ragged2e} % Better text justification
\usepackage{hyphenat} % Better hyphenation control
\usepackage{url} % Better URL line breaking

% Emergency stretch to prevent overfull hboxes
\emergencystretch=1em

% Additional settings for better text handling
\tolerance=1000
\hyphenpenalty=50
\exhyphenpenalty=50

% Set line breaking parameters
\linespread{1.05} % Slightly increase line spacing
\clubpenalty=10000 % Prevent single lines at bottom of page
\widowpenalty=10000 % Prevent single lines at top of page

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{listings}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\makeatletter
\usepackage{caption}
\captionsetup[table]{belowskip=0.5pt}
\usepackage{subfiles}

\usepackage{listings}
\renewcommand{\lstlistingname}{Код}
\renewcommand{\lstlistlistingname}{\lstlistingname ын жагсаалт}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.99,0.99,0.99}
\definecolor{lightgray}{rgb}{0.83,0.83,0.83}
 
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=false,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=true,
    showtabs=false,                  
    tabsize=2,
    % Additional settings for better line breaking
    breakindent=1.5em,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    frame=single,
    rulecolor=\color{lightgray},
    columns=flexible,
    % Ensure lines don't exceed margins
    xleftmargin=2em,
    xrightmargin=2em
}
 
\lstset{style=mystyle, label=DescriptiveLabel} 

\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\makenomenclature
\begin{document}


%----------------------------------------------------------------------------------------
%   Өөрийн мэдээллээ оруулах хэсэг
%----------------------------------------------------------------------------------------

% Дипломийн ажлын сэдэв
\title{Агент суурилсан хиймэл оюун}
% Дипломын ажлын англи нэр
\titleEng{AI agents for microservices}
% Өөрийн овог нэрийг бүтнээр нь бичнэ
\author{Булганы Раднаабазар}
% Өөрийн овгийн эхний үсэг нэрээ бичнэ
\authorShort{Б.Раднаабазар}
% Удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\supervisor{Дэд профессор Б.Сувдаа}
% Хамтарсан удирдагчийн зэрэг цол овгийн эхний үсэг нэр
\cosupervisor{}

% СиСи дугаар 
\sisiId{22B1NUM0286}
% Их сургуулийн нэр
\university{МОНГОЛ УЛСЫН ИХ СУРГУУЛЬ}
% Бүрэлдэхүүн сургуулийн нэр
\faculty{МЭДЭЭЛЛИЙН ТЕХНОЛОГИ, ЭЛЕКТРОНИКИЙН СУРГУУЛЬ}
% Тэнхимийн нэр
\department{МЭДЭЭЛЭЛ, КОМПЬЮТЕРИЙН УХААНЫ ТЭНХИМ}
% Зэргийн нэр
\degreeName{Дипломын ажлын тайлан}
% Суралцаж буй хөтөлбөрийн нэр
\programeName{Мэдээллийн технологи (D061304)}
% Хэвлэгдсэн газар
\cityName{Улаанбаатар}
% Хэвлэгдсэн огноо
\gradyear{2025 оны 10 сар}


%----------------------------------------------------------------------------------------
%   Доорх хэсгийг өөрчлөх шаардлагагүй
%----------------------------------------------------------------------------------------
\include{src/main-pre}

% Удиртгалыг оруулж ирэх ба abstract.tex файлд удиртгалаа бичнэ
\include{src/abstract}

%----------------------------------------------------------------------------------------
%   Дипломын үндсэн хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------



\section{Судалгааны зорилго}

Энэхүү судалгааны ажлын гол зорилго нь дараах асуултуудад хариулах явдал юм:

\begin{enumerate}
    \item Хиймэл оюуны инженерчлэлийн үндсэн онол болон суурь загваруудын хөгжлийн түүхийг тайлбарлах
    \item Хиймэл оюун агентуудын архитектур, төлөвлөлтийн механизм, багажуудын ашиглалтыг судлах
    \item Микросервис архитектурын давуу болон сул талуудыг тодорхойлох
    \item Хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэхэд тулгарах асуудлуудыг тодорхойлох
    \item Хиймэл оюун агентуудыг микросервис архитектурт нэгтгэсэн загвар санал болгох
    \item Санал болгож буй загварыг практик жишээгээр батлан харуулах
\end{enumerate}

\chapter{Онолын хэсэг}

\section{Хиймэл оюун ухааны хөгжлийн түүх}

\subsection{Хиймэл оюуны гурван давалгаа}

Хиймэл оюун ухаан нь өөрийн хөгжлийн явцад гурван чухал давалгааг туулсан. Эдгээр давалгаа бүр нь өмнөх давалгааны хязгаарлалтыг даван туулах замаар бий болсон.

\subsubsection{Нэгдүгээр давалгаа: Таамаглах загварууд}

Анхны давалгаа нь уламжлалт машин сургалтад тулгуурласан бөгөөд нарийн тодорхойлсон даалгавруудад таамаглал хийх чадварт чиглэгдсэн. Эдгээр загварууд нь тодорхой domain-д зориулагдсан бөгөөд тухайн domain-ийн мэдлэг нь сургалтын өгөгдөлд агуулагдсан байдаг.

Гэвч эдгээр загварууд хатуу байсан. Шинэ domain-д дасан зохицох нь төвөгтэй, ихэвчлэн эхнээс нь эхлэх шаардлагатай болдог. Энэ нь өргөжүүлэх боломжгүй, хөгжлийг удаашруулах шалтгаан болсон.

\subsubsection{Хоёрдугаар давалгаа: Үүсгэх загварууд}

Генератив Хиймэл оюун (Generative AI) нь гүн сургалтаар дэмжигдэн чухал эргэлт болсон. Нэг domain-д хязгаарлагдахын оронд эдгээр загварууд өргөн хүрээний, олон янзын өгөгдлийн иж бүрдэл дээр сургагдаж, янз бүрийн контекстэд ерөнхийлөх чадвартай болсон. Тэд текст, зураг, бүү��эс видео үүсгэж чаддаг болсон.

Гэвч энэ давалгаа нь өөрийн гэсэн сорилтуудтай ирсэн:

\begin{itemize}
    \item \textbf{Цаг хугацаанд бэхлэгдсэн}: Загварууд нь шинэ, динамик мэдээллийг өөртөө нэгтгэж чадахгүй
    \item \textbf{Дасан зохицох хүндрэл}: Finetuning хийх боломжтой боловч үнэтэй, алдаа гаргах магадлал өндөр
    \item \textbf{Domain-ийн мэдлэгийн дутагдал}: Олон нийтийн өгөгдөл дээр сургагдсан тул тодорхой domain-ийн мэдлэгт хүрч чадахгүй
\end{itemize}

\subsubsection{Гуравдугаар давалгаа: Агентын Хиймэл оюун}

Salesforce-ийн CEO Marc Benioff сая хэлэхдээ, бид LLM-ийн хийж чадах зүйлийн дээд хязгаарт хүрчихсэн байна гэжээ. Google-ийн Gemini загвар нь том хэмжээний өгөгдөл дээр сургагдсан хэдий ч дотооддоо хүлээлтээ хангаж чадахгүй байна гэж мэдээлэгдсэн. OpenAI-ийн Orion загварт ч төст асуудал байна.

Ирээдүй нь бие даасан агентууд - бодож, дасан зохицож, бие даан үйлдэл хийх чадвартай системүүдэд оршино. Агентууд нь шинэ зүйл авчирч байна: динамик, контекст дээр суурилсан workflow. Тогтмол зам биш, агентын системүүд дараагийн алхмуудыг тухайн нөхцөл байдалд үндэслэн шийддэг.

\subsection{Хиймэл оюун инженерчлэл гэж юу вэ}

Хиймэл оюуны инженерчлэл гэдэг нь урьд өмнө бэлтгэгдсэн суурь загваруудын дээр аппликейшн хөгжүүлэх үйл явц юм. Энэ нь уламжлалт машин сургалтын инженерчлэл (ML engineering) эсвэл MLOps-оос ялгаатай байдаг. Хэрэв уламжлалт МS инженерчлэл нь загвар хөгжүүлэхэд чиглэсэн бол, Хиймэл оюун инженерчлэл нь одоо байгаа загваруудыг ашиглахад илүү анхаарал хандуулдаг~\cite{huyen2024}.

Хүчирхэг суурь загваруудын олдоц болон хүртээмж нь дараах гурван хүчин зүйлийг бүрдүүлж, Хиймэл оюун инженерчлэл хурдан өсч буй салбар болоход хүргэсэн:

\begin{enumerate}
    \item \textbf{Өндөр эрэлт}: Компаниуд хиймэл оюуныг өрсөлдөх давуу тал болгон үзэж байна. FactSet-ийн судалгаагаар 2023 оны хоёрдугаар улиралд S\&P 500 компаниудын гуравны нэг нь өөрсдийн орлогын тайланд хиймэл оюуныг дурдсан нь өмнөх оноос гурав дахин их юм.
    \item \textbf{Бага саад бэрхшээл}: Өмнө нь Хиймэл оюун систем бүтээхэд өндөр мэргэжлийн ур чадвар, их хэмжээний өгөгдөл, тооцооллын нөөц шаардлагатай байсан бол одоо API дуудлага хийх замаар чадварлаг загварууд ашиглах боломжтой болсон.
    \item \textbf{Том боломж}: Хиймэл оюун технологи нь үйлдвэрлэлийн өсөлт, автоматжуулалт, шинэ бүтээгдэхүүнүүдийг бий болгох асар том эдийн засгийн боломжуудыг санал болгож байна.
\end{enumerate}

Хиймэл оюуны инженерчлэлийн багажуудын популяр болох хурд нь өмнө нь байгаагүй түвшинд хүрсэн. Хоёрхан жилийн дотор дөрвөн нээлттэй эх код бүхий Хиймэл оюун инженерчлэлийн багаж (AutoGPT, Stable Diffusion WebUI, LangChain, Ollama) нь GitHub дээр Bitcoin-оос ч илүү од цуглуулжээ.

\subsection{Суурь загваруудын хөгжил}

Хэл загваруудаас том хэлний загвар, суурь загвар руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Энэхүү хэсэгт гол түлхүүр цэгүүдийг авч үзэх болно.

\subsubsection{Хэл загваруудын үндэс}

Хэл загвар (language model) гэдэг нь нэг буюу хэд хэдэн хэлний тухай статистик мэдээллийг кодлодог загвар юм. Энэхүү мэдээлэл нь өгөгдсөн контекстэд тодорхой үг гарах магадлалыг илэрхийлдэг. Жишээлбэл, "Миний дуртай өнгө бол \_\_" гэсэн контекст өгөхөд Монгол хэлийг кодолсон хэл загвар нь "машин"-аас илүүтэйгээр "цэнхэр" гэсэн үгийг таамаглах ёстой.

Анхны текстийг токен болгон хуваах үйл явцыг токенжуулалт (tokenization) гэнэ. GPT-4-ийн хувьд дунджаар нэг токен нь үгийн ойролцоогоор 75\%-ийн уртад тохирно. Тиймээс 100 токен нь ойролцоогоор 75 үг юм.

Хэл загваруудын хоёр үндсэн төрөл байдаг:

\begin{itemize}
    \item \textbf{Masked language models (Далдлагдсан хэл загварууд)}: Өгүүлбэр доторх далдлагдсан үгсийг таамаглах замаар сурдаг. BERT нь энэ төрлийн алдартай жишээ юм.
    \item \textbf{Autoregressive language models (Автoрегрессив хэл загварууд)}: Өмнөх токенуудад үндэслэн дараагийн токенийг таамаглах замаар сурдаг. GPT гэр бүл нь энэ төрлийн загвар юм.
\end{itemize}

\subsubsection{Өөрийгөө удирдсан сургалт}

Хэл загваруудын хамгийн чухал давуу тал нь өөрийгөө удирдсан сургалт (self-supervision) ашиглах чадвар юм. Өөрийгөө удирдсан сургалт нь удирдлагатай сургалт (supervised learning)-аас ялгаатай байдаг. Удирдлагатай сургалт нь тэмдэглэгдсэн өгөгдөл (labeled data) шаарддаг бөгөөд энэ нь үнэтэй, цаг хугацаа их зарцуулдаг.

Өөрийгөө удирдсан сургалтад шошго нь оролтын өгөгдлөөс дүгнэгддэг. Өөрөөр хэлбэл, хэл загваруудыг номууд, блог нийтлэл, өгүүллүүд, Reddit-ийн сэтгэгдэл зэрэг текст дараалал ашиглан ямар нэг шошгогүйгээр сургаж болно. Энэ нь асар их сургалтын өгөгдөл бүрдүүлэх боломжийг олгож, хэл загваруудыг Том Хэлний Загвар (LLM) болтол өргөжүүлэх боломжтой болгосон.

\subsubsection{Том хэлний загвараас суурь загвар руу}

2017 онд Transformer архитектур гарч ирснээр хэл загваруудын чадавхи үсрэнгүй нэмэгдсэн. Attention механизм нь загваруудад урт хугацааны хамаарлыг илүү сайн ойлгох боломжийг олгосон. Энэ нь GPT, BERT, T5 зэрэг алдартай загваруудын үндэс болсон.

Том хэлний загварууд (Large Language Models, LLMs) нь хэл загваруудын томорсон хувилбар бөгөөд тэрбум тооны параметр агуулдаг. Параметр гэдэг нь сургалтын явцад загварын сурч авдаг утга юм. Жишээлбэл, GPT-3 нь 175 тэрбум параметртэй, харин GPT-4 нь үүнээс ч илүү параметртэй гэж үздэг.

Суурь загваруд (foundation models) нь LLM-ээс цааш өргөжсөн ойлголт юм. Эдгээр нь зөвхөн текст биш, зураг, аудио, видео зэрэг олон төрлийн өгөгдөл боловсруулж чаддаг том мульти модаль загварууд юм. Суурь загваруудын гол онцлог нь даалгаврын тодорхой (task-specific) загвараас ерөнхий зориулалтын (general-purpose) загвар руу шилжсэн явдал юм.

\subsection{Суурь загваруудын сургалт}

Суурь загваруудыг бэлтгэх нь хоёр үндсэн үе шаттай:

\subsubsection{Урьдчилан сургалт (Pre-training)}

Урьдчилан сургалт нь өөрийгөө удирдсан сургалт ашиглан их хэмжээний өгөгдөл дээр загварыг сургах үйл явц юм. Энэ үе шатанд загвар нь хэл, ертөнцийн мэдлэг, энгийн дүрэм зүйлсийг суралцдаг. Гэвч энэхүү үе шатны загвар нь хэрэглэгчдийн хүсэлтэд нийцсэн хариулт өгөхөд сайн биш байдаг, учир нь зөвхөн өгүүлбэр үргэлжлүүлэх (completion) дээр сургагдсан байдаг.

\subsubsection{Дараах сургалт (Post-training)}

Урьдчилан сургасан загварыг хэрэглэгчдийн хүсэлтэд тохируулахын тулд дараах сургалт хийдэг. Энэ нь хоёр үе шаттай:

\begin{enumerate}
    \item \textbf{Удирдлагатай нарийвчлал (Supervised Finetuning, SFT)}: Өндөр чанартай зааварчилгаа өгөгдөл (instruction data) дээр загварыг нарийвчлан сургаж, үргэлжлүүлэх биш харин ярианы горимд оновчтой болгоно.
    \item \textbf{Хүний сонголтод тохируулах (Preference Finetuning)}: Загварыг хүний сонголттой нийцсэн хариулт өгөхийн тулд цаашид нарийвчлан сургана. Үүнд RLHF (Reinforcement Learning from Human Feedback), DPO (Direct Preference Optimization), RLAIF (Reinforcement Learning from AI Feedback) зэрэг аргууд ордог.
\end{enumerate}

\subsection{Загваруудын үр дүнг хэмжих}

Суурь загваруудыг үнэлэх нь эрсдэлийг бууруулах, боломжуудыг илрүүлэх талаас чухал ач холбогдолтой. Үнэлгээ нь загвар сонгох, дэвшлийг хэмжих, аппликейшн ашиглалтад бэлэн эсэхийг тодорхойлох, үйлдвэрлэлд асуудал болон боломжуудыг илрүүлэх зэрэгт шаардлагатай.

Загваруудын чадавхи сайжирч байгаа нь тодорхой харагдаж байна. Жишээлбэл, 2024 оны Llama 3-8B загвар нь 2023 оны Llama 2-70B загвараас ч илүү сайн үр дүнг MMLU benchmark дээр харуулжээ. Энэ нь зөвхөн загварын хэмжээ биш, сургалтын аргууд болон өгөгдлийн чанар хамгийн чухал болохыг харуулж байна.

Үнэлгээний гол асуудлууд:

\begin{itemize}
    \item \textbf{Нээлттэй төгсгөлтэй гаралт}: Суурь загварууд нь нээлттэй төгсгөлтэй хариулт үүсгэдэг тул үнэлэхэд хэцүү.
    \item \textbf{Тогтворгүй байдал}: Загвар нь ижил эсвэл бага зэрэг өөр prompt-д маш өөр хариулт өгч болно.
    \item \textbf{Hallucination (Төөрөгдөл)}: Загвар нь баримт дээр үндэслээгүй хариулт өгч болно.
\end{itemize}

\section{Prompt инженерчлэл}

Prompt инженерчлэл гэдэг нь загвараас хүссэн үр дүнг гаргуулахын тулд зааврыг бичих үйл явц юм. Энэ нь загварын жинг өөрчлөхгүйгээр түүний зан үйлийг удирдах хамгийн хялбар бөгөөд түгээмэл загвар дасан зохицох арга юм.

\subsection{Prompt бичих шилдэг арга барил}

OpenAI-ийн санал болгосон дараах стратегиудыг дагах нь илүү сайн үр дүн өгдөг:

\begin{enumerate}
    \item \textbf{Тодорхой зааварчилгаа өгөх}: Юу хийлгэхээ хоёрдмол утгагүй байдлаар тайлбарлах хэрэгтэй.
    \item \textbf{Persona өгөх}: Загвараас тодорхой дүрд тоглуулж болно. Жишээ нь: "Та туршлагатай программист. Кодыг шалгаад алдаа зааж өг."
    \item \textbf{Жишээ өгөх}: Жишээ нь хариултын формат, стилийн талаар хоёрдмол утгыг багасгадаг. Энэ нь few-shot learning гэгддэг.
    \item \textbf{Хангалттай контекст өгөх}: Контекст нь hallucination-ийг багасгадаг. Хэрэв загвар шаардлагатай мэдээллээр хангагдаагүй бол өөрийн дотоод мэдлэгтээ найдах бөгөөд энэ нь найдваргүй байж болно.
    \item \textbf{Нарийн төвөгтэй даалгавруудыг хялбар дэд даалгавруудад хувааж өгөх}: Энэ нь chain-of-thought prompting гэгддэг.
\end{enumerate}

\subsection{Sampling стратегиуд}

Загвар нь гаралтаа sampling гэж нэрлэгддэг процессоор бүтээдэг. Sampling нь Хиймэл оюуны гаралтыг магадлалтай (probabilistic) болгодог. Дараах параметрууд нь sampling-д нөлөөлдөг:

\begin{itemize}
    \item \textbf{Temperature}: Температур өндөр байх тусам загвар илүү бүтээлч, гэнэтийн хариулт өгдөг. Температур бага байх тусам илүү таамагладаг, баттай хариулт өгнө.
    \item \textbf{Top-k}: Хамгийн магадлалтай k ширхэг токеноос сонгодог.
    \item \textbf{Top-p (nucleus sampling)}: Нийлбэр магадлал нь p-д хүрэх хамгийн бага токенуудын багцаас сонгодог.
\end{itemize}

\subsection{Хамгаалалтын prompt инженерчлэл}

Аппликейшн олон нийтэд ашиглагдах болмогц гурван төрлийн довтолгооноос хамгаалах шаардлагатай:

\begin{itemize}
    \item \textbf{Prompt extraction}: Аппликейшнийг хуулбарлах эсвэл хэрэглэх зорилгоор system prompt-ыг задруулах оролдлого.
    \item \textbf{Jailbreaking болон prompt injection}: Загварыг зөвшөөрөөгүй үйлдэл хийлгэх оролдлого.
    \item \textbf{Мэдээлэл задруулах}: Загварын сургалтын өгөгдөл эсвэл контекстын мэдээллийг задруулах оролдлого.
\end{itemize}

\section{Retrieval-Augmented Generation (RAG)}

RAG буюу Хайлтаар Дэмжигдсэн Генераци нь загваруудын мэдлэгийг гадаад эх сурвалжаар өргөтгөх арга юм. Энэ нь загварын дотоод мэдлэг хангалтгүй, хуучирсан эсвэл алдаатай байх асуудлыг шийддэг.

\subsection{RAG хэрэгтэй болох шалтгаан}

Хэдийгээр загваруудын контекстын урт улам нэмэгдэж байгаа ч RAG-ийн ач холбогдол алдагдахгүй байна:

\begin{enumerate}
    \item Контекстын урт хэдий өсвөр байсан ч зарим аппликейшнд хангалтгүй байх болно. Өгөгдлийн хэмжээ байнга өсч байдаг.
    \item Урт контекстыг боловсруулж чаддаг гэдэг нь тэр контекстыг сайн ашигладаг гэсэн үг биш. Контекст урт байх тусам загвар буруу хэсэгт анхаарал хандуулах магадлал өсдөг.
    \item Контекстын токен бүр нэмэлт өртөг, нэмэлт хоцрогдол авчирдаг. RAG нь асуулт бүрт зөвхөн хамгийн холбогдолтой мэдээллийг ашиглах боломжийг олгоно.
\end{enumerate}

Anthropic-ийн зөвлөмжөөр хэрэв таны мэдлэгийн сан 200,000 токеноос бага (ойролцоогоор 500 хуудас) бол RAG-ын оронд бүх мэдлэгийг prompt-д оруулж болно гэжээ.

\subsection{RAG системийн бүтэц}

RAG систем нь хоёр гол бүрэлдэхүүнтэй:

\begin{enumerate}
    \item \textbf{Retriever (Хайгч)}: Асуултад хамгийн холбогдолтой баримтуудыг олж авдаг.
    \item \textbf{Generator (Үүсгэгч)}: Олж авсан баримтууд болон асуултыг ашиглан хариулт үүсгэдэг.
\end{enumerate}

\subsection{Retrieval алгоритмууд}

\subsubsection{Нэр томьёо суурилсан хайлт (Term-based retrieval)}

Энэ арга нь түлхүүр үгээр баримт хайдаг. TF-IDF (Term Frequency - Inverse Document Frequency) нь энэ аргын үндэс юм:

\begin{itemize}
    \item \textbf{TF (Term Frequency)}: Нэр томьёо баримт доор хэдэн удаа гарч байгааг хэмждэг.
    \item \textbf{IDF (Inverse Document Frequency)}: Нэр томьёо хэдэн баримтад гарч байгааг үндэслэн түүний чухлыг хэмждэг.
\end{itemize}

Түгээмэл шийдлүүд: Elasticsearch, BM25. Эдгээр нь inverted index ашигладаг.

\subsubsection{Embedding суурилсан хайлт (Embedding-based retrieval)}

Semantic хайлт гэж нэрлэгддэг энэ арга нь утгын түвшинд холбоотой байдлыг тооцдог. Баримт бүр vector embedding болгон хувиргагдаж, vector database-д хадгалагдана. Асуулт ирэх үед түүний embedding-тэй хамгийн ойр векторуудыг хайдаг.

\textbf{Vector search алгоритмууд:}

\begin{itemize}
    \item \textbf{k-NN (k-Nearest Neighbors)}: Энгийн арга боловч өгөгдөл их бол удаан.
    \item \textbf{ANN (Approximate Nearest Neighbors)}: Хурдан боловч ойролцоогоор хайна.
    \item \textbf{LSH (Locality-Sensitive Hashing)}: Ижил төстэй векторуудыг нэг bucket-д hash хийнэ.
    \item \textbf{HNSW (Hierarchical Navigable Small World)}: Олон давхаргын граф ашиглана.
    \item \textbf{IVF (Inverted File Index)}: K-means clustering ашиглан векторуудыг бүлэглэнэ.
\end{itemize}

Алдартай vector database-үүд: FAISS, Milvus, Pinecone, Weaviate, Qdrant.

\subsection{RAG-ын үнэлгээ}

RAG системийг үнэлэхэд дараах метрикүүд ашигладаг:

\begin{itemize}
    \item \textbf{Context Precision}: Олж авсан баримтуудын хэдэн хувь нь асуулттай холбоотой вэ?
    \item \textbf{Context Recall}: Асуулттай холбоотой бүх баримтуудын хэдэн хувийг олж авсан бэ?
    \item \textbf{Answer Quality}: Эцсийн хариултын чанар хэр сайн вэ?
\end{itemize}

\subsection{RAG-ыг сайжруулах аргууд}

\begin{enumerate}
    \item \textbf{Chunking стратеги}: Баримтуудыг хэрхэн хэсэглэх нь чухал. Тогтмол урттай хэсэглэх, өгүүлбэр/догол мөрөөр хэсэглэх, semantic хэсэглэх зэрэг аргууд байдаг.
    \item \textbf{Reranking}: Анхны хайлтын үр дүнг дахин эрэмбэлэн илүү нарийвчлалтай болгох.
    \item \textbf{Query rewriting}: Асуултыг дахин найруулж илүү сайн хайлт хийх.
    \item \textbf{Hybrid хайлт}: Нэр томьёо болон embedding суурилсан хайлтыг хослуулах.
    \item \textbf{Contextual retrieval}: Хэсэг бүрийг metadata, түлхүүр үг, холбогдох асуултуудаар баяжуулах.
\end{enumerate}

\subsection{Агентын RAG (Agentic RAG)}

Уламжлалт RAG нь тогтмол workflow ашигладаг - асуулт ирэх бүрд ижил үйл явц дагана: хайлт хийх, топ-k баримт олох, контекст үүсгэх, хариулт үүсгэх. Гэвч энэ арга нь хатуу, нарийн төвөгтэй даалгавруудад хязгаарлагдмал байдаг.

Агентын RAG нь RAG-ыг илүү динамик, контекст дээр суурилсан болгож хөгжүүлдэг. Тогтмол workflow-д найдахын оронд, агентууд нь бодит цагт ямар өгөгдөл хэрэгтэйгээ, хаанаас олохоо, өгөгдсөн даалгаврын үндсэн дээр асуултаа хэрхэн боловсронгуй болгохоо шийддэг.

\textbf{Агентын RAG vs Уламжлалт RAG:}

\begin{itemize}
    \item \textbf{Динамик хайлт}: Агент нь шаардлагатай бол олон эх сурвалжаас мэдээлэл цуглуулж, асуултаа боловсронгуй болгож, шинэ мэдээлэл гарч ирэхэд дасан зохицож чаддаг.
    \item \textbf{Олон алхам бүхий дүгнэлт}: Агент нь анхны хайлтын үр дүнд үндэслэн дараагийн асуултуудыг үүсгэж, илүү гүнзгий мэдлэг олж авч чаддаг.
    \item \textbf{Багажийн ашиглалт}: Агент нь зөвхөн баримтын хайлт биш, API дуудах, өгөгдлийн сангаас асуулт хийх, тооцоолол хийх зэрэг олон багаж ашиглаж болно.
    \item \textbf{Контекст санах}: Санах ойгоороо агент нь өмнөх асуултууд болон хариултуудыг хадгалж, дараагийн асуултдаа илүү нарийвчлалтай хандаж чаддаг.
\end{itemize}

Жишээлбэл, маркетингийн стратеги боловсруулж байгаа агент нь:
\begin{enumerate}
    \item CRM-ээс харилцагчийн өгөгдөл татаж авна
    \item API ашиглан зах зээлийн чиг хандлагыг цуглуулна
    \item Шинэ мэдээлэл гарч ирэхэд өөрийн аргачлалаа боловсронгуй болгоно
    \item Санах ой болон итераци ашиглан илүү нарийвчлалтай, холбогдолтой үр дүн гаргана
\end{enumerate}

Агентын RAG нь хайлт, дүгнэлт, үйлдлийг нэгтгэдэг. Энэ нь RAG-ыг тогтмол конвейероос төвлөрсөн, дасан зохицох боломжтой систем болгон хувиргадаг.

\section{Хиймэл оюун агентууд}

\subsection{Агент гэж юу вэ}

Агент гэдэг нь өөрийн орчныг мэдрэх, түүн дээр үйлдэл хийх чадвартай систем юм. Хиймэл оюун-оор дэмжигдсэн агентууд нь суурь загваруудын хүч чадлаар дамжуулан бидний туслах, хамтран ажиллагч, сургагч байж чадна. Тэд вебсайт бүтээх, өгөгдөл цуглуулах, аялал төлөвлөх, зах зээлийн судалгаа хийх, харилцагчийн данс удирдах, өгөгдөл оруулалтыг автоматжуулах зэрэг олон зүйлд тусалж чадна.

\subsection{Агентын бүрэлдэхүүн хэсгүүд}

Хиймэл оюун агентыг тодорхойлдог гурван гол зүйл:

\begin{enumerate}
    \item \textbf{Орчин (Environment)}: Агент ажиллах орчин нь түүний хэрэглээний тохиолдлоор тодорхойлогдоно. Жишээ нь: тоглоом (Minecraft, Go), интернэт, гал тогоо, зам.
    \item \textbf{Үйлдлүүд (Actions)}: Агентын хийж чадах үйлдлүүд нь түүний хандах боломжтой багажуудаар өргөжинө.
    \item \textbf{Даалгавар (Task)}: Хэрэглэгчээс өгөгдсөн зорилго, зорилт.
\end{enumerate}

\subsection{Багажууд (Tools)}

Гадаад багажууд байхгүй бол агентын чадавхи маш хязгаарлагдмал байх болно. Багажууд нь агентыг илүү чадварлаг болгодог. Багажуудын гурван ангилал:

\subsubsection{Мэдлэг нэмэгдүүлэх багажууд}

RAG системийн бүрэлдэхүүн хэсгүүд:
\begin{itemize}
    \item Текст retriever
    \item Зураг retriever
    \item SQL executor
    \item Интернэт хайлт API
    \item Дотоод хайлтын системүүд
\end{itemize}

\subsubsection{Чадавхи өргөтгөх багажууд}

\begin{itemize}
    \item \textbf{Тооны машин}: Хиймэл оюун загварууд математикт сул байдаг. Тооны машин нь энгийн тооцоог гүйцэтгэнэ.
    \item \textbf{Код интерпретер}: Код бичиж, ажиллуулах, үр дүнг задлах. Энэ нь кодчилолын туслах, өгөгдөл шинжлэгч, судалгааны туслах боломжийг олгоно.
\end{itemize}

\subsubsection{Бичих үйлдлийн багажууд}

Зөвхөн унших биш, өөрчлөлт оруулах багажууд:
\begin{itemize}
    \item Өгөгдлийн санд өгөгдөл нэмэх, засварлах, устгах
    \item Email илгээх
    \item Банкны шилжүүлэг эхлүүлэх
    \item Календарт үйл явдал нэмэх
\end{itemize}

\textbf{Анхааруулга}: Бичих үйлдэл нь өндөр эрсдэлтэй. Code injection довтолгооноос болгоомжлох хэрэгтэй.

\subsection{Төлөвлөлт (Planning)}

Төлөвлөлт нь агентын гол үүрэг бөгөөд дараах үе шаттай:

\begin{enumerate}
    \item \textbf{Төлөвлөгөө үүсгэх (Plan Generation)}: Даалгаврыг гүйцэтгэх дараалсан үйлдлүүдийн төлөвлөгөө гаргах. Үүнийг task decomposition буюу даалгавар задлах гэж нэрлэнэ.
    \item \textbf{Эргэцүүлэн бодох ба алдаа засах (Reflection)}: Үүсгэсэн төлөвлөгөөг үнэлэх. Муу байвал шинэ төлөвлөгөө гаргах.
    \item \textbf{Гүйцэтгэл (Execution)}: Төлөвлөгөөнд заасан үйлдлүүдийг хийх. Энэ нь ихэвчлэн функц дуудалт хийх явдал юм.
    \item \textbf{Үр дүнг үнэлэх}: Үйлдлийн үр дүнг хүлээн авсны дараа зорилго биелсэн эсэхийг тодорхойлох. Алдааг тодорхойлж засах.
\end{enumerate}

\subsection{Суурь загварууд төлөвлөгч болж чадах уу}

Зарим судлаачид LLM нь төлөвлөгч байж чадахгүй гэж үздэг. Учир нь төлөвлөлт нь үндсэндээ хайлтын асуудал бөгөөд autoregressive загвар нь зөвхөн урагш үйлдэл үүсгэж чаддаг гэж үздэг. Гэвч бодит байдал дээр загвар дахин эхлэж өөр зам сонгож чаддаг тул энэ нь төдийлөн хатуу хязгаарлалт биш юм.

Төлөвлөлтийг сайжруулах аргууд:

\begin{itemize}
    \item Илүү сайн system prompt бичих, жишээ олноор өгөх
    \item Багажуудын тайлбарыг илүү сайн бичих
    \item Функцүүдийг хялбарчлах, задлах
    \item Илүү хүчтэй загвар ашиглах
    \item Төлөвлөлтөд зориулж загвар нарийвчлан сургах
\end{itemize}

\subsection{Эргэцүүлэн бодох ба алдаа засах}

Хамгийн сайн төлөвлөгөө ч байнга үнэлэгдэж, тохируулагдах шаардлагатай. Reflection нь агентын амжилтад чухал үүрэг гүйцэтгэнэ. Үүнийг хоёр аргаар хийж болно:

\begin{itemize}
    \item \textbf{Self-critique}: Ижил загвар өөртэйгөө ярилцаж алдааг илрүүлнэ.
    \item \textbf{Тусдаа үнэлэгч}: Тусдаа загвар эсвэл функц үр дүнд оноо өгнө.
\end{itemize}

\subsection{Агентын санах ой}

Хиймэл оюун загвар нь гурван санах ойн механизмтай:

\begin{enumerate}
    \item \textbf{Дотоод мэдлэг (Internal Knowledge)}: Загвар өөрөө нь санах ой юм. Сургалтын өгөгдлөөс олж авсан мэдлэг. Загварыг шинэчлэхгүй бол өөрчлөгдөхгүй.
    \item \textbf{Богино хугацааны санах ой (Short-term Memory)}: Загварын контекст. Өмнөх мессежүүд контекстэд нэмэгдэж болно. Даалгавар дууссаны дараа устдаг. Хурдан боловч багтаамж хязгаарлагдмал.
    \item \textbf{Урт хугацааны санах ой (Long-term Memory)}: Гадаад өгөгдлийн эх сурвалж (RAG). Даалгавруудын хооронд үргэлжилдэг. Өгөгдлийг устгаж болно.
\end{enumerate}

\subsection{Агентын дизайны загварууд}

Агентууд нь зөвхөн үндсэн чадваруудаасаа биш, тэдгээрийн workflow болон харилцааг бүтэцлэх дизайны загваруудаас ч хүч авдаг. Эдгээр загварууд нь агентуудад нарийн төвөгтэй асуудлыг шийдэх, хувьсах орчинд дасан зохицох, үр дүнтэй хамтран ажиллах боломжийг олгодог.

\subsubsection{Эргэцүүлэн бодох (Reflection)}

Reflection нь агентуудад өөрсдийн шийдвэрийг үнэлж, үйлдэл хийх эсвэл эцсийн хариулт өгөхөөсөө өмнө гаралтаа сайжруулах боломжийг олгодог. Энэ чадвар нь агентуудад алдаагаа олж засах, дүгнэлтээ боловсронгуй болгох, илүү өндөр чанартай үр дүн гаргах боломжийг олгоно.

Жишээлбэл, код бичиж байгаа агент нь эхлээд код үүсгээд, дараа нь өөрөө тухайн кодыг шалгаж, алдаа олж, сайжруулалт хийснийхээ дараа хэрэглэгчид хүргэнэ. Энэ нь эцсийн үр дүнгийн чанарыг мэдэгдэхүйц сайжруулдаг.

\subsubsection{Багажийн ашиглалт (Tool Use)}

Гадаад багажуудтай холбогдох нь агентын функционалыг өргөжүүлж, өгөгдөл авах, үйл явцыг автоматжуулах, эсвэл детерминист workflow-г гүйцэтгэх зэрэг даалгаврыг гүйцэтгэх боломжийг олгоно. Энэ нь математик тооцоолол эсвэл өгөгдлийн сангийн асуулга гэх мэт нарийвчлал шаардлагатай үйлдлүүдэд онцгой ач холбогдолтой.

Багажийн ашиглалт нь уян хатан шийдвэр гаргалт болон таамагладаг, найдвартай гүйцэтгэлийн хоорондох хоосон зайг нөхдөг.

\subsubsection{Төлөвлөлт (Planning)}

Төлөвлөлтийн чадвартай агентууд нь өндөр түвшний зорилгуудыг үйлдэл хийх боломжтой алхмуудад задалж, даалгавруудыг логик дарааллаар зохион байгуулж чаддаг. Энэ дизайны загвар нь олон алхам бүхий асуудлыг шийдэх эсвэл хамааралтай workflow-г удирдахад чухал юм.

Жишээлбэл, аялал төлөвлөх агент нь дараах төлөвлөгөө гаргаж болно:
\begin{enumerate}
    \item Нислэг хайх
    \item Зочид буудал захиалах
    \item Үзвэр сервисийн цэгүүдийг судлах
    \item Өдөр бүрийн маршрут үүсгэх
\end{enumerate}

\subsubsection{Олон агентын хамтын ажиллагаа (Multi-Agent Collaboration)}

Олон агентын системүүд нь асуудлыг шийдэхэд модуль чиглэсэн арга барил ашигладаг - тодорхой даалгавруудыг мэргэшсэн агентуудад хуваарилдаг. Энэ арга нь уян хатан байдлыг санал болгодог: та үр ашигтай байдлыг сайжруулахын тулд даалгавар тодорхой агентуудад илүү жижиг хэлний загварууд (SLMs) ашиглаж болно.

Модульчлагдсан дизайн нь тэдгээрийн контекстыг тусгай даалгаврууддаа чиглүүлэх замаар агент тус бүрийн нарийн төвөгтэй байдлыг багасгадаг. Хамтран ажиллахаар эдгээр мэргэшсэн агентууд мэдээлэл солилцож, хариуцлагыг хуваарилж, нарийн төвөгтэй сорилтуудыг илүү үр дүнтэй шийдэхийн тулд үйлдлүүдээ зохицуулдаг.

Уламжлалт системийн дизайнтай адилаар, асуудлыг модульчлагдсан бүрэлдэхүүн хэсгүүдэд задлах нь тэднийг засварлах, өргөжүүлэх, дасан зохицуулахад илүү хялбар болгодог.

\section{Хиймэл оюун инженерчлэлийн хэрэгжүүлэлт}

Суурь загварууд ашиглан аппликейшн хөгжүүлэх нь уламжлалт ML инженерчлэлээс гурван чухал талаараа ялгаатай:

\begin{enumerate}
    \item \textbf{Загвар дасан зохицуулалт}: Өөрөө загвар сургахын оронд бусдын сургасан загварыг ашиглана. Үүнээс болж загвар дасан зохицуулалт (model adaptation) илүү чухал болсон.
    \item \textbf{Тооцоолол эрчимт}: Загварууд том, илүү их тооцоолол шаарддаг, хоцрогдол өндөр. Үр ашигтай сургалт болон inference optimization илүү чухал.
    \item \textbf{Нээлттэй гаралт}: Загварууд нээлттэй төгсгөлтэй гаралт үүсгэдэг тул үнэлгээ илүү том асуудал болсон.
\end{enumerate}

\textbf{Загвар дасан зохицуулалтын хоёр гол арга:}

\begin{itemize}
    \item \textbf{Prompt-based techniques}: Загварын жин өөрчлөхгүйгээр зааварчилгаа, контекст өгч дасан зохицуулна. Хялбар, цөөн өгөгдөл шаардана. Prompt engineering энд хамаарна.
    \item \textbf{Finetuning}: Загварын жинг өөрчилж дасан зохицуулна. Илүү нарийн төвөгтэй, илүү их өгөгдөл шаардана. Гэвч чанар, хоцрогдол, өртгийг мэдэгдэхүйц сайжруулж чадна.
\end{itemize}

\chapter{Микросервис архитектур}

\section{Монолитоос микросервис рүү}

\subsection{Монолитын эрин үе}

Вэб аппликейшн хөгжүүлэлтийн эхэн үед бүх зүйлийг монолит хэлбэрээр бүтээдэг байсан - бүх бизнес логик, хэрэглэгчийн харилцаа, өгөгдлийн үйлдлүүд нэг том, нягт нэгдсэн кодын санд амьдардаг байв. Энэ арга нь эхэндээ утга учиртай байсан. Монолитууд нь хөгжүүлэх, deploy хийхэд энгийн байсан, ялангуяа аппликейшнууд хязгаарлагдмал нарийн төвөгтэй байдалтай, нэг сервер дээр ажилладаг үед.

\subsection{Монолитыг өргөжүүлэх сорилт}

Гэвч аппликейшнууд томрох тусам асуудлууд ч өсдөг. Монолитыг өргөжүүлэх нь бүх зүйлийг өргөжүүлэх гэсэн үг - системийн зөвхөн нэг хэсэгт илүү их нөөц шаардлагатай байсан ч гэсэн. Нэг модульд хийсэн жижиг өөрчлөлт бүх код санд өргөжиж болох бөгөөд энэ нь шинэчлэлийг удаан, эрсдэлтэй болгодог. Хамгийн муу нь, өөр өөр функц дээр ажиллаж байгаа багууд байнга бие биенийхээ хөлд гишгэж, хөгжлийг удаашруулж, алдаа гарах эрсдэлийг нэмэгдүүлдэг.

Монолит архитектураас эхэлсэн олон компани эцэст нь эдгээр хязгаарлалтад тулгарсан. Atlassian, Jira болон Confluence-ийн ард байгаа компани, тэдний нэг нь байв. 2018 оноос өмнө Atlassian нь эдгээр бүтээгдэхүүндээ монолит архитектурт найдаж байсан. Компани өргөжихийн хэрээр, дэлхийн таван хөгжлийн төвд тархсан багуудтай, энэхүү төвлөрсөн монолит бүтэц нь томоохон саад болов. Бүх бизнес логикийн нэг кодын санд нягт холбогдсон байдал нь жижиг өөрчлөлт ч гэсэн бүх stack-ийг дахин бүтээж, дахин deploy хийх шаардлагатай болгосон.

Хөгжүүлэгчид монолит руу хандах эрхийг зохицуулах ёстой байсан, энэ нь хоцрогдол, багуудын хоорондын үрэлт нэмэгдэхэд хүргэсэн. Хурдан хөдлөхийн оронд багууд бүх системийг шинэчлэх, турших хүртэл хүлээх шаардлагатай байв. Энэ нь хурдан хөгжлөөр амьдардаг компанид үндсэн саад байсан.

\subsection{Микросервис рүү шилжих}

Эдгээр хязгаарлалтаас ангижрахын тулд Atlassian 2018 онд Jira болон Confluence-г микросервис архитектур руу шилжүүлсэн. Энэ өөрчлөлт нь тархсан багуудад бие даан ажиллах, өөрчлөлтийг хурдан deploy хийх, бүх платформыг дахин deploy хийхгүйгээр шинэчлэл гаргах боломжийг олгосон. Микросервис рүү шилжих нь зөвхөн өргөжүүлэх чадварыг сайжруулаад зогсохгүй, багуудад автономи өгч, зохицуулалтын ачааллыг бууруулж, инновацийг хурдасгасан.

\subsection{Микросервисийн тодорхойлолт}

Микросервис архитектур нь програм хангамжийг хөгжүүлэх арга бөгөөд аппликейшныг жижиг, бие даасан сервисүүдэд хувааж хөгжүүлдэг.

Микросервисийн гол онцлогууд:

\begin{itemize}
    \item \textbf{Бие даасан байдал}: Микросервис бүр бие даасан үүрэгтэй, өөрийн өгөгдлийн сантай.
    \item \textbf{Уян хатан хөгжүүлэлт}: Өөр өөр багууд өөр өөр технологи, хэл ашиглаж хөгжүүлж болно.
    \item \textbf{Өргөжих чадвар}: Зөвхөн шаардлагатай сервисийг л өргөжүүлж болно.
    \item \textbf{Найдвартай байдал}: Нэг сервис унавал бусад сервисүүд ажиллаж үргэлжлэнэ.
\end{itemize}

\section{Микросервисийн давуу тал}

\begin{enumerate}
    \item \textbf{Технологийн олон янз байдал}: Сервис бүр өөрийн хэрэгцээнд тохирсон технологи сонгож болно. Жишээ нь: нэг сервис Python, нөгөө нь Go, өөр нь Node.js ашиглаж болно.
    \item \textbf{Багуудын бие даасан ажиллагаа}: Баг бүр өөрийн сервисийг бие даан хөгжүүлж, deploy хийж чадна.
    \item \textbf{Хурдан deployment}: Том системийг бүхэлд нь дахин deploy хийх шаардлагагүй. Зөвхөн өөрчлөгдсөн сервисийг л deploy хийнэ.
    \item \textbf{Илүү сайн өргөжих чадвар}: Ачаалал их сервисийг л өргөжүүлэх нь бүх системийг өргөжүүлэхээс үр ашигтай.
    \item \textbf{Алдааны тусгаарлалт}: Нэг сервисийн алдаа бусад сервисд дамжихгүй.
\end{enumerate}

\section{Микросервисийн сорилтууд}

Микросервис архитектур олон давуу талтай ч дараах сорилтуудтай:

\begin{enumerate}
    \item \textbf{Нарийн төвөгтэй байдал}: Олон сервисүүдийг удирдах, тэдгээрийн харилцааг хянах нь монолит системээс илүү төвөгтэй.
    \item \textbf{Өгөгдлийн консистенс}: Сервис бүр өөрийн өгөгдлийн сантай байх нь өгөгдлийн нийцтэй байдлыг хангахад хэцүү болгодог.
    \item \textbf{Сүлжээний хоцрогдол}: Сервисүүд хоорондоо сүлжээгээр харилцах нь нэмэлт хоцрогдол авчирна.
    \item \textbf{Алдаа илрүүлэх хэцүү байдал}: Олон сервисийгээр дамжин явах хүсэлтийн алдааг олох, засах хэцүү.
    \item \textbf{Сервис хоорондын харилцаа}: Сервисүүд хэрхэн харилцах, мэдээлэл солилцох нь нарийн асуудал.
    \item \textbf{Transaction удирдлага}: Олон сервисийгээр transaction явуулах нь үл нэгдэл өгөгдлийн сангийн transaction-аас илүү төвөгтэй.
\end{enumerate}

\section{Микросервис хоорондын харилцаа}

Микросервисүүд хоорондоо хоёр гол аргаар харилцдаг:

\subsection{Синхрон харилцаа (Synchronous Communication)}

HTTP/REST API эсвэл gRPC ашиглан шууд хүсэлт илгээж хариу хүлээнэ. Энэ нь хялбар боловч:
\begin{itemize}
    \item Tight coupling үүсгэдэг
    \item Нэг сервис унавал бусад сервисүүд алдаа гаргана
    \item Latency нэмэгддэг
\end{itemize}

\subsection{Асинхрон харилцаа (Asynchronous Communication)}

Message queue (RabbitMQ, Kafka) ашиглан мессеж солилцоно. Энэ нь:
\begin{itemize}
    \item Loose coupling үүсгэнэ
    \item Илүү найдвартай
    \item Илүү төвөгтэй
\end{itemize}

\section{Үйл явдлаар удирдагдах архитектур}

\subsection{Үйл явдлаар удирдагдах архитектур гэж юу вэ}

Микросервисүүд гарч ирснээр шинэ сорилт бий болсон: эдгээр сервисүүд хэрхэн үр дүнтэй харилцах вэ? Хэрэв бид сервисүүдийг шууд RPC эсвэл API дуудлагаар холбовол бид асар том хамааралын сүлжээ үүсгэнэ. Хэрэв нэг сервис унавал энэ нь холбогдсон замын дагуух бүх node-д нөлөөлнө.

Үйл явдлаар удирдагдах архитектур (Event-Driven Architecture, EDA) нь энэ асуудлыг шийдсэн. Нягт холбогдсон, синхрон харилцааны оронд EDA нь бүрэлдэхүүн хэсгүүдэд үйл явдлаар асинхрон харилцах боломжийг олгодог. Сервисүүд бие биенийхээ хүлээхгүй - тэд бодит цагт юу болж байгаад хариу үйлдэл үзүүлдэг.

\subsection{EDA-ын давуу тал}

\begin{enumerate}
    \item \textbf{Салангид байдал (Decoupling)}: Сервисүүд үйл явдлаар харилцдаг тул тэд бие биенээсээ хараат бус байна. Нэг сервис өөрчлөгдөх эсвэл унах нь бусад сервисд шууд нөлөөлөхгүй.
    \item \textbf{Өргөжүүлэх чадвар}: Сервис бүр үйл явдлыг бие даан боловсруулах тул системийг өргөжүүлэх илүү хялбар.
    \item \textbf{Уян хатан байдал}: Шинэ сервис нэмэх эсвэл одоо байгаа сервисийг өөрчлөх нь бусад сервисд өөрчлөлт шаардахгүй.
    \item \textbf{Бодит цагийн боловсруулалт}: Үйл явдлууд тэр даруйдаа боловсруулагдах тул систем нь өөрчлөлтөд хурдан хариу үйлдэл үзүүлнэ.
\end{enumerate}

\subsection{Apache Kafka: Үйл явдлын хүчирхэг суурь}

Apache Kafka нь салангид, өндөр дамжуулалттай, бага хоцрогдолтой үйл явдлын streaming платформ юм. Kafka нь EDA архитектурын төв мэдрэлийн систем болж чаддаг.

\subsubsection{Kafka-ийн үндсэн ойлголтууд}

\begin{itemize}
    \item \textbf{Topic}: Үйл явдлуудыг ангилах логик channel. Жишээ нь: "user-events", "order-events"
    \item \textbf{Producer}: Үйл явдлыг topic руу бичдэг аппликейшн
    \item \textbf{Consumer}: Topic-оос үйл явдлыг уншдаг аппликейшн
    \item \textbf{Partition}: Topic-ийг өргөжүүлэх, параллель боловсруулалт хийх боломжтой болгодог
    \item \textbf{Consumer Group}: Олон consumer нэг багаар ажиллаж ачааллыг хуваарилдаг
\end{itemize}

\subsubsection{Kafka-ийн давуу тал}

\begin{enumerate}
    \item \textbf{Хэвтээ өргөжих чадвар}: Kafka-ийн салангид дизайн нь саадгүйгээр шинэ агент эсвэл consumer нэмэх боломжийг олгоно.
    \item \textbf{Бага хоцрогдол}: Бодит цагийн үйл явдал боловсруулалт нь агентуудад өөрчлөлтөд шууд хариу үйлдэл үзүүлэх боломжийг олгоно.
    \item \textbf{Loose Coupling}: Topic-уудаар харилцах нь агентууд хараат бус, өргөжүүлэх боломжтой байхыг баталгаажуулна.
    \item \textbf{Үйл явдлын хадгалалт}: Тогтвортой мессежийн хадгалалт нь өгөгдөл дамжилтын явцад алга болохгүй гэдгийг баталгаажуулна.
    \item \textbf{Дахин тоглуулах боломж (Replayability)}: Kafka нь үл хөдлөх салангид log учраас үйл явдал бүр хадгалагдаж, debug, үнэлгээ, дахин сургалтад дахин тоглуулж болно.
\end{enumerate}

\subsection{Apache Flink: Streaming боловсруулалтын хөдөлгүүр}

Apache Flink нь stateful тооцоолол, үйл явдал цагийн боловсруулалт хийх чадвартай салангид stream processing framework юм. Flink нь Kafka-тай хамт ашиглах замаар хүчирхэг бодит цагийн өгөгдөл боловсруулалтын конвейер бүтээх боломжийг олгоно.

\subsubsection{Flink-ийн давуу тал}

\begin{itemize}
    \item \textbf{Stateful боловсруулалт}: Flink нь state-г найдвартай удирдаж, нарийн төвөгтэй тооцоолол хийх боломжийг олгоно.
    \item \textbf{Цаг цагийн боловсруулалт}: Үйл явдлын цаг дээр үндэслэн бодит цагийн шинжилгээ хийх.
    \item \textbf{Өндөр дамжуулалт}: Секундэд сая сая үйл явдлыг боловсруулж чаддаг.
    \item \textbf{Exactly-once семантик}: Мэдээлэл нэг удаа л боловсруулагдахыг баталгаажуулна.
\end{itemize}

\subsubsection{Flink AI Inference}

Flink нь LLM-тэй ажиллах чадвартай. Flink AI inference нь өгөгдлийг авч, LLM рүү илгээж, хариу авах боломжийг олгоно. Энэ нь төлөвлөгч агентыг Flink app болгон хөгжүүлэх боломжийг олгодог.

Жишээлбэл:
\begin{itemize}
    \item Kafka topic-оос үйл явдал уншина
    \item LLM ашиглан контекст ойлгох, төлөвлөгөө гаргах
    \item Үр дүнг өөр Kafka topic руу бичих
    \item Бусад агентууд энэ үр дүнг уншиж гүйцэтгэнэ
\end{itemize}

\subsubsection{Flink болон RAG}

Hallucination-ийг багасгахын тулд LLM-ийг бодит өгөгдөлд суурилуулах хэрэгтэй. Flink нь RAG pattern-ийг бүтээхэд тусална:

\begin{enumerate}
    \item Flink нь өгөгдлийг боловсруулна
    \item LLM inference ашиглан өгөгдлийг embedding болгон хөрвүүлнэ
    \item Embedding-ыг Kafka topic руу бичнэ
    \item Kafka Connect ашиглан vector database руу синхрончлоно
    \item Агентууд RAG ашиглан бодит өгөгдөл дээр суурилсан хариулт өгнө
\end{enumerate}

\subsection{Агентууд ба EDA}

Хиймэл оюун агентуудыг өргөжүүлэх нь үндсэндээ салангид системийн асуудал юм. Агентууд нь шийдвэр гаргаж, үйлдэл хийхийн тулд олон эх сурвалж, бусад агентууд, багажууд, гадаад системүүдээс мэдээлэл цуглуулах шаардлагатай.

\textbf{Агентууд яагаад EDA шаарддаг:}

\begin{itemize}
    \item \textbf{Асинхрон шинж чанар}: Агентууд нь хүн шиг ажилладаг - тэд олон эх сурвалжаас мэдээлэл цуглуулж, өгөгдлийг шинжилж, үйлдэл хийхээсээ өмнө шийдвэр гаргах хэрэгтэй. Эдгээр үйл явцууд нь асинхрон шинжтэй.
    \item \textbf{Мэдээллийн хамаарал}: Микросервисүүд ихэвчлэн салангид үйлдлүүдийг боловсруулдаг бол агентууд нь контекст баялаг, хуваалцсан мэдээлэлд найддаг. Энэ нь хамаарлыг удирдах, бодит цагийн өгөгдлийн урсгалыг баталгаажуулах онцгой шаардлагыг бий болгоно.
    \item \textbf{Олон хэрэглэгчдэд үйлчлэх}: Агентын гаралт нь зөвхөн AI app руу буцахгүй - тэд өгөгдлийн агуулах, CRM, CDP, customer success платформ зэрэг бусад чухал системүүд рүү урсах ёстой.
\end{itemize}

Тийм ээ, та агентуудыг RPC болон API-аар холбож болно, гэхдээ энэ нь нягт холбогдсон системүүд бий болгох жор юм. Нягт холбоос нь өргөжүүлэх, дасан зохицох, эсвэл ижил өгөгдлийн олон хэрэглэгчдийг дэмжихэд хэцүү болгодог. Агентууд нь уян хатан байдал шаарддаг. Тэдний гаралт нь бусад агентууд, сервисүүд, платформуудад хатуу хамааралгүйгээр үр дүнгүй дамжих ёстой.

\chapter{Асуудлын тодорхойлолт}

\section{Микросервис архитектур дахь сорилтууд}

Микросервис архитектурт дараах гол асуудлууд байдаг:

\subsection{Сервис хоорондын нарийн төвөгтэй логик}

Хэрэглэгчийн нэг хүсэлт нь олон сервисийгээр дамжин явах ёстой. Жишээ нь онлайн худалдааны систем дээр:

\begin{enumerate}
    \item Хэрэглэгч бараа захиална
    \item Захиалгын сервис захиалга үүсгэнэ
    \item Агуулахын сервисээс бараа байгаа эсэхийг шалгана
    \item Төлбөрийн сервисийгээр төлбөр хийнэ
    \item Хүргэлтийн сервисд мэдэгдэнэ
    \item Notification сервисийгээр хэрэглэгчид мэдэгдэнэ
\end{enumerate}

Эдгээр алхам бүрт алдаа гарч болох бөгөөд алдаа гарах үед юу хийх нь тодорхойгүй байдаг. Уламжлалт аргаар энэ workflow-г хатуу кодлох нь:

\begin{itemize}
    \item Уян хатан бус
    \item Шинэ сервис нэмэхэд хэцүү
    \item Алдаа засалт хэцүү
    \item Бизнес дүрмийн өөрчлөлт хийхэд том код өөрчлөлт шаардлагатай
\end{itemize}

\subsection{Өгөгдлийн нэгтгэл ба шинжилгээ}

Микросервис бүр өөрийн өгөгдлийн сантай байх нь:

\begin{itemize}
    \item Олон өгөгдлийн сангийн өгөгдлийг нэгтгэх хэцүү
    \item Cross-service шинжилгээ хийх төвөгтэй
    \item Тайлангийн системд өгөгдөл цуглуулах асуудалтай
    \item Хэрэглэгчийн бүрэн дүр төрхийг харах хэцүү
\end{itemize}

\subsection{Динамик routing ба шийдвэр гаргалт}

Хэрэглэгчийн хүсэлтийг аль сервис рүү чиглүүлэх, хэдэн сервисийг дуудах шаардлагатайг тодорхойлох нь:

\begin{itemize}
    \item Бизнес логик өөрчлөгдөх бүрд код өөрчлөх шаардлагатай
    \item A/B testing хийхэд төвөгтэй
    \item Орчны өөрчлөлтөд дасан зохицох чадваргүй
\end{itemize}

\subsection{Мониторинг ба алдаа илрүүлэлт}

\begin{itemize}
    \item Олон сервисийн логийг нэгтгэх хэцүү
    \item Хэрэглэгчийн хүсэлт аль сеовисд алдаа гаргасныг тодорхойлох хэцүү
    \item Алдааны язгуур шалтгааныг олох төвөгтэй
\end{itemize}

\subsection{Агентын монолит}

Агент суурилсан систем хөгжүүлэхдээ анхны хувилбар нь ихэвчлэн монолит хэлбэртэй байдаг. Controller, Planner, SQL Handler, Streaming Handler зэрэг агентууд нэг аппликейшн дотор ажилладаг. Энэ арга нь эхэндээ ажилладаг ч дараах асуудлуудтай:

\begin{itemize}
    \item \textbf{Deployment хамаарал}: Planner-ийн v2 гаргахын тулд бүх системийг дахин deploy хийх шаардлагатай.
    \item \textbf{Hardware хязгаарлалт}: Planner агент нь LLM ашиглаж GPU шаарддаг бол SQL Handler нь жижиг SLM ашиглан CPU дээр ажиллаж болно. Монолит систем энэ хоёрыг салгаж чадахгүй.
    \item \textbf{Өргөжүүлэх боломжгүй}: Нэг агентад их ачаалал ирсэн ч бүх системийг өргөжүүлэх шаардлагатай болно.
    \item \textbf{Нягт холбоос}: Агентууд хоорондоо шууд дуудлагаар холбогдсон байх нь алдааны дамжлага, хоцрогдлын асуудал бий болгоно.
\end{itemize}

\section{Хиймэл оюун агентууд хэрхэн туслах вэ}

Хиймэл оюун агентууд нь дээрх асуудлуудыг дараах аргаар шийдэж чадна:

\begin{enumerate}
    \item \textbf{Ухаалаг орчуулагч (Intelligent Orchestrator)}: Агент нь хүсэлтийг ойлгож, аль сервисүүдийг дуудах хэрэгтэй, ямар дарааллаар дуудах, алдаа гарвал яах талаар төлөвлөгөө гарган гүйцэтгэнэ.
    \item \textbf{Контекст бүтээгч (Context Builder)}: RAG ашиглан олон өгөгдлийн сангийн мэдээллийг нэгтгэж, ойлгомжтой контекст бүтээнэ.
    \item \textbf{Динамик routing}: Хэрэглэгчийн хүсэлтийг ойлгож, хамгийн тохиромжтой сервис рүү чиглүүлнэ.
    \item \textbf{Өгөгдлийн задлагч (Data Analyst)}: Олон сервисийн өгөгдлийг цуглуулж, шинжилж, ойлгомжтой тайлан гаргана.
    \item \textbf{Алдаа засагч (Error Handler)}: Алдаа гарсан тохиолдолд шалтгааныг олж, засах төлөвлөгөө санал болгоно.
\end{enumerate}

\section{Үйл явдлаар удирдагдах архитектурын шаардлага}

Агентуудыг үр дүнтэй өргөжүүлэхийн тулд тэдгээрийг микросервис болгон салгах шаардлагатай. Гэхдээ микросервисүүд нь RPC эсвэл API дуудлагаар харилцах нь дахин монолиттой адилхан асуудал үүсгэнэ - зөвхөн салгагдсан хэлбэртэй.

Үйл явдлаар удирдагдах архитектур (EDA) нь дараах асуудлуудыг шийднэ:

\begin{itemize}
    \item \textbf{Салангид байдал}: Агентууд хоорондоо Kafka topics-оор харилцах тул шууд хамаарал байхгүй.
    \item \textbf{Асинхрон}: Агентууд бие биенийхээ хүлээхгүй, бодит цагт хариу үйлдэл үзүүлдэг.
    \item \textbf{Олон хэрэглэгч}: Нэг агентын гаралтыг олон агент, систем ашиглаж болно.
    \item \textbf{Өргөжих чадвар}: Агент бүр бие даан өргөжиж болно.
    \item \textbf{Найдвартай байдал}: Kafka-ийн үйл явдлын хадгалалт нь мэдээлэл алдагдахгүйг баталгаажуулна.
\end{itemize}

\chapter{Шийдэл ба санал болгож буй загвар}

\section{Хиймэл оюун агент суурилсан микросервис архитектур}

Энэхүү судалгаанд микросервис архитектурт Хиймэл оюун агентуудыг нэвтрүүлэх загварыг санал болгож байна. Уг загвар нь дараах гол бүрэлдэхүүнтэй:

\subsection{Агентын архитектур}

\subsubsection{Orchestrator Agent (Орчуулагч агент)}

Энэ агент нь хэрэглэгчийн хүсэлтийг хүлээн авч, ямар сервисүүдийг дуудах, ямар дарааллаар дуудах талаар төлөвлөгөө гаргадаг. Үүний бүтэц:

\begin{itemize}
    \item \textbf{Intent Understanding}: LLM ашиглан хэрэглэгчийн хүсэлтийг ойлгох
    \item \textbf{Service Discovery}: Боломжтой сервисүүдийн жагсаалтыг мэдэх
    \item \textbf{Execution Planning}: Дуудах сервисүүдийн дараалал, параметрүүдийг тодорхойлох
    \item \textbf{Error Handling}: Алдаа гарвал алдааг засах төлөвлөгөө гаргах
\end{itemize}

\subsubsection{Service Agents (Сервисийн агентууд)}

Сервис бүр өөрийн агенттай байж болно. Энэ агент нь:

\begin{itemize}
    \item Сервисийн API-г тайлбарлаж өгнө
    \item Хүсэлтийг тухайн сервисд тохирсон форматруу хөрвүүлнэ
    \item Үр дүнг ойлгомжтой хэлбэрт хөрвүүлнө
    \item Сервисийн статус, чадавхийг мэдээлнэ
\end{itemize}

\subsubsection{Knowledge Agent (Мэдлэгийн агент)}

RAG систем ашиглан:

\begin{itemize}
    \item Сервисүүдийн баримт бичгийг хадгална
    \item Өмнөх хүсэлт, хариултуудыг санана
    \item Бизнес дүрэм, журмуудыг мэднэ
    \item API спецификацийг хадгална
\end{itemize}

\subsubsection{Monitoring Agent (Хяналтын агент)}

\begin{itemize}
    \item Логуудыг цуглуулж, шинжилнэ
    \item Алдаануудыг илрүүлнэ
    \item Системийн эрүүл байдлыг хянана
    \item Сайжруулах санал өгнө
\end{itemize}

\subsection{Системийн архитектур}

Санал болгож буй үйл явдлаар удирдагдах архитектур нь:

\begin{verbatim}
Хэрэглэгч
    |
    v
API Gateway
    |
    v
[user-requests] Kafka Topic
    |
    v
Orchestrator Agent (Event Consumer/Producer)
    |
    +---> [planning-tasks] Kafka Topic
    |           |
    |           v
    |       Planner Agent (Flink App with LLM)
    |           |
    |           v
    |       [execution-plans] Kafka Topic
    |
    +---> [knowledge-queries] Kafka Topic
    |           |
    |           v
    |       Knowledge Agent (RAG + Vector DB)
    |           |
    |           v
    |       [knowledge-results] Kafka Topic
    |
    +---> [service-calls] Kafka Topic
              |
              +---> Service Agent 1 --> Microservice 1
              |
              +---> Service Agent 2 --> Microservice 2
              |
              +---> Service Agent N --> Microservice N
              |
              v
          [service-results] Kafka Topic
              |
              v
          Response Aggregator
              |
              v
          [user-responses] Kafka Topic
              |
              v
          API Gateway --> Хэрэглэгч
\end{verbatim}

\subsection{Kafka Topics ба хамаарал}

Системд дараах Kafka topics ашиглагдана:

\begin{itemize}
    \item \textbf{user-requests}: Хэрэглэгчийн хүсэлтүүд
    \item \textbf{planning-tasks}: Төлөвлөгөө гаргах даалгаврууд
    \item \textbf{execution-plans}: Гүйцэтгэх төлөвлөгөөнүүд
    \item \textbf{knowledge-queries}: RAG хайлтын асуултууд
    \item \textbf{knowledge-results}: RAG-ийн үр дүнгүүд
    \item \textbf{service-calls}: Микросервис дуудлагууд
    \item \textbf{service-results}: Микросервисийн үр дүнгүүд
    \item \textbf{user-responses}: Хэрэглэгчид буцах хариултууд
    \item \textbf{monitoring-events}: Системийн логууд ба мониторинг
\end{itemize}

\subsection{Үйл явдлаар удирдагдах Workflow}

\begin{enumerate}
    \item \textbf{Хүсэлт publish}: API Gateway хүсэлтийг \texttt{user-requests} topic руу бичнэ
    \item \textbf{Orchestrator consume}: Orchestrator Agent үйл явдлыг уншиж, intent-ийг ойлгоно
    \item \textbf{Төлөвлөлт үйл явдал}: Хэрэв төлөвлөлт хэрэгтэй бол \texttt{planning-tasks} topic руу үйл явдал илгээнэ
    \item \textbf{Flink Planning}: Planner Agent (Flink app) үйл явдлыг уншиж, LLM ашиглан төлөвлөгөө гаргаж, \texttt{execution-plans} topic руу бичнэ
    \item \textbf{Knowledge хайлт}: Orchestrator нь \texttt{knowledge-queries} topic руү хайлтын үйл явдал илгээнэ
    \item \textbf{RAG боловсруулалт}: Knowledge Agent үйл явдлыг уншиж, vector хайлт хийж, үр дүнг \texttt{knowledge-results} topic руу бичнэ
    \item \textbf{Service дуудлага}: Төлөвлөгөөний дагуу \texttt{service-calls} topic руу үйл явдлууд илгээгдэнэ
    \item \textbf{Параллель гүйцэтгэл}: Service Agent-ууд параллель байдлаар үйл явдлуудыг уншиж, микросервисүүдийг дуудаж, үр дүнг \texttt{service-results} topic руу бичнэ
    \item \textbf{Aggregation}: Response Aggregator бүх үр дүнг цуглуулж нэгтгэнэ
    \item \textbf{Хариулт publish}: Эцсийн хариултыг \texttt{user-responses} topic руу бичнэ
    \item \textbf{Хэрэглэгчид хүргэх}: API Gateway хариултыг уншиж хэрэглэгчид буцаана
    \item \textbf{Мониторинг}: Бүх агент \texttt{monitoring-events} topic руу лог мэдээлэл бичнэ
\end{enumerate}

\textbf{Асинхрон онцлог:} Агентууд бие биенийхээ хүлээхгүй. Тэд үйл явдлыг publish хийж, өөрийн ажилдаа үргэлжлүүлнэ. Энэ нь системийг өргөжүүлэх боломжтой, найдвартай болгодог.

\section{Техникийн нарийн ширийн зүйлс}

\subsection{Prompt загвар}

Orchestrator Agent-ийн system prompt:

\begin{verbatim}
Та микросервис орчуулагч агент. Таны үүрэг:
1. Хэрэглэгчийн хүсэлтийг ойлгох
2. Дуудах сервисүүдийг төлөвлөх
3. Үр дүнг нэгтгэж хэрэглэгчид ойлгомжтой байдлаар хариулах

Боломжтой сервисүүд:
{service_list}

Бизнес дүрмүүд:
{business_rules}
\end{verbatim}

\subsection{Service Registry}

Сервис бүрийг JSON форматаар тодорхойлно:

\begin{lstlisting}[language=Python, caption=Service Registry Example]
{
  "name": "user-service",
  "description": "Хэрэглэгчийн мэдээлэл удирдах сервис",
  "endpoints": [
    {
      "path": "/users/{id}",
      "method": "GET",
      "description": "Хэрэглэгчийн мэдээлэл авах",
      "parameters": {
        "id": "Хэрэглэгчийн ID"
      }
    }
  ]
}
\end{lstlisting}

\subsection{RAG Систем}

Knowledge Agent нь vector database ашиглана:

\begin{itemize}
    \item \textbf{Index}: API баримт бичиг, өмнөх хүсэлтүүд, бизнес дүрэм
    \item \textbf{Embedding Model}: Sentence-Transformers эсвэл OpenAI embeddings
    \item \textbf{Vector DB}: FAISS, Pinecone, эсвэл Qdrant
    \item \textbf{Retrieval}: Асуулт бүрт top-k хамгийн холбогдолтой баримтуудыг олох
\end{itemize}

\subsection{Алдаа засалт}

Алдаа гарах үед агент:

\begin{enumerate}
    \item Алдааны төрөл, шалтгааныг тодорхойлно
    \item Retry стратеги сонгоно (exponential backoff)
    \item Альтернатив сервис байгаа эсэхийг шалгана
    \item Хэрэглэгчид ойлгомжтой алдааны мэдэгдэл өгнө
    \item Алдааны логийг хадгална
\end{enumerate}

\section{Санал болгож буй загварын давуу тал}

\subsection{Хиймэл оюун агентын онцлогууд}

\begin{enumerate}
    \item \textbf{Натурал хэл интерфейс}: Хэрэглэгч натурал хэл дээр хүсэлт илгээж болно
    \item \textbf{Уян хатан орчуулалт}: Бизнес дүрэм өөрчлөгдөхөд код өөрчлөх шаардлагагүй
    \item \textbf{Ухаалаг алдаа засалт}: Агент өөрөө алдааг таньж, засах арга санал болгоно
    \item \textbf{Түүх санах}: Өмнөх харилцааг санаж, контекст хадгална
    \item \textbf{Өгөгдлийн нэгтгэл}: Олон сервисийн өгөгдлийг нэгтгэж ойлгомжтой болгоно
    \item \textbf{Өөрөө сайжрах}: Логуудаас суралцаж, цаашид илүү сайн ажиллана
\end{enumerate}

\subsection{Үйл явдлаар удирдагдах давуу тал}

\begin{enumerate}
    \item \textbf{Салангид байдал (Decoupling)}:
    \begin{itemize}
        \item Агентууд хоорондоо шууд хамааралгүй
        \item Нэг агент унах нь бусдад шууд нөлөөлөхгүй
        \item Агентыг өөрчлөх, солих хялбар
    \end{itemize}
    
    \item \textbf{Өргөжүүлэх чадвар (Scalability)}:
    \begin{itemize}
        \item Агент бүр бие даан өргөжиж болно
        \item Kafka partition ашиглан параллель боловсруулалт
        \item Consumer group-оор ачааллыг хуваарилах
    \end{itemize}
    
    \item \textbf{Найдвартай байдал (Resilience)}:
    \begin{itemize}
        \item Kafka-ийн replication алдагдал хамгаална
        \item Үйл явдал дахин тоглуулах боломжтой
        \item Агент тасалдах ч үйл явдал алдагдахгүй
    \end{itemize}
    
    \item \textbf{Бодит цагийн хариу үйлдэл}:
    \begin{itemize}
        \item Үйл явдал тэр даруйдаа дамждаг
        \item Streaming боловсруулалт
        \item Бага хоцрогдол
    \end{itemize}
    
    \item \textbf{Олон хэрэглэгч дэмжлэг}:
    \begin{itemize}
        \item Нэг үйл явдлыг олон систем ашиглаж болно
        \item CRM, CDP, analytics руу автоматаар урсах
        \item Шинэ consumer нэмэхэд producer өөрчлөх шаардлагагүй
    \end{itemize}
    
    \item \textbf{Observability ба Debugging}:
    \begin{itemize}
        \item Бүх үйл явдал хадгалагдана
        \item Lineage tracking: үйл явдал хаашаа явсныг мэдэх
        \item Үйл явдал дахин тоглуулж bug олох
        \item Дахин сургалтад ашиглах
    \end{itemize}
\end{enumerate}

\chapter{Туршилт ба кодын жишээ}

\section{Прототип систем}

Санал болгосон загварыг туршихын тулд энгийн e-commerce системийн прототип бүтээсэн. Систем нь дараах микросервисүүдтэй:

\begin{itemize}
    \item User Service: Хэрэглэгчийн бүртгэл, нэвтрэлт
    \item Product Service: Бүтээгдэхүүний мэдээлэл
    \item Order Service: Захиалга удирдлага
    \item Payment Service: Төлбөр боловсруулалт
    \item Notification Service: Мэдэгдэл илгээх
\end{itemize}

\section{Orchestrator Agent хэрэгжүүлэлт}

\subsection{Үндсэн бүтэц}

\begin{lstlisting}[language=Python, caption=Orchestrator Agent Implementation]
import openai
from typing import List, Dict
import json

class OrchestratorAgent:
    def __init__(self, service_registry: Dict, 
                 knowledge_base: KnowledgeBase):
        self.service_registry = service_registry
        self.knowledge_base = knowledge_base
        self.llm_client = openai.OpenAI()
    
    def process_request(self, user_query: str) -> str:
        # 1. Knowledge retrieval
        relevant_docs = self.knowledge_base.retrieve(
            user_query, 
            top_k=5
        )
        
        # 2. Build context
        context = self._build_context(
            user_query, 
            relevant_docs
        )
        
        # 3. Generate plan
        plan = self._generate_plan(context)
        
        # 4. Execute plan
        results = self._execute_plan(plan)
        
        # 5. Generate response
        response = self._generate_response(
            user_query, 
            results
        )
        
        return response
    
    def _build_context(self, query: str, 
                       docs: List[str]) -> str:
        services_desc = json.dumps(
            self.service_registry, 
            indent=2
        )
        docs_text = "\n\n".join(docs)
        
        return f"""
        Хэрэглэгчийн хүсэлт: {query}
        
        Боломжтой сервисүүд:
        {services_desc}
        
        Холбогдох баримт бичиг:
        {docs_text}
        """
    
    def _generate_plan(self, context: str) -> Dict:
        system_prompt = """
        Та микросервис орчуулагч агент. 
        Хэрэглэгчийн хүсэлтийг гүйцэтгэхийн тулд 
        дуудах сервисүүдийн төлөвлөгөө гарга.
        
        Төлөвлөгөөг дараах JSON форматаар гарга:
        {
          "steps": [
            {
              "service": "service-name",
              "action": "endpoint-path",
              "parameters": {...},
              "description": "Энэ алхамын тайлбар"
            }
          ]
        }
        """
        
        response = self.llm_client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": context}
            ],
            temperature=0.1
        )
        
        plan_json = response.choices[0].message.content
        return json.loads(plan_json)
    
    def _execute_plan(self, plan: Dict) -> List[Dict]:
        results = []
        
        for step in plan["steps"]:
            try:
                result = self._call_service(
                    step["service"],
                    step["action"],
                    step["parameters"]
                )
                results.append({
                    "step": step["description"],
                    "status": "success",
                    "data": result
                })
            except Exception as e:
                results.append({
                    "step": step["description"],
                    "status": "error",
                    "error": str(e)
                })
                
                # Error recovery
                recovery_plan = self._handle_error(
                    step, 
                    str(e)
                )
                if recovery_plan:
                    results.extend(
                        self._execute_plan(recovery_plan)
                    )
        
        return results
    
    def _call_service(self, service: str, 
                      action: str, 
                      params: Dict) -> Dict:
        # Service agent дуудах
        service_agent = ServiceAgent(service)
        return service_agent.call(action, params)
    
    def _handle_error(self, failed_step: Dict, 
                      error: str) -> Dict:
        # Алдааны төрлөөс хамааран 
        # recovery төлөвлөгөө гарга
        error_context = f"""
        Дараах алхам амжилтгүй боллоо:
        {json.dumps(failed_step, indent=2)}
        
        Алдаа: {error}
        
        Засах төлөвлөгөө гарга эсвэл 
        None буцаа.
        """
        
        # LLM ашиглан recovery plan гарга
        # ...
        return None
    
    def _generate_response(self, query: str, 
                           results: List[Dict]) -> str:
        results_summary = json.dumps(results, indent=2)
        
        response_prompt = f"""
        Хэрэглэгчийн хүсэлт: {query}
        
        Гүйцэтгэлийн үр дүн:
        {results_summary}
        
        Хэрэглэгчид ойлгомжтой хариулт бич.
        """
        
        response = self.llm_client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": response_prompt}
            ],
            temperature=0.7
        )
        
        return response.choices[0].message.content
\end{lstlisting}

\subsection{Knowledge Base хэрэгжүүлэлт}

\begin{lstlisting}[language=Python, caption=RAG Knowledge Base Implementation]
from sentence_transformers import SentenceTransformer
import faiss
import numpy as np
from typing import List

class KnowledgeBase:
    def __init__(self):
        self.model = SentenceTransformer(
            'paraphrase-multilingual-mpnet-base-v2'
        )
        self.documents = []
        self.embeddings = None
        self.index = None
    
    def add_documents(self, docs: List[str]):
        self.documents.extend(docs)
        
        # Generate embeddings
        new_embeddings = self.model.encode(docs)
        
        if self.embeddings is None:
            self.embeddings = new_embeddings
        else:
            self.embeddings = np.vstack([
                self.embeddings, 
                new_embeddings
            ])
        
        # Build FAISS index
        dimension = self.embeddings.shape[1]
        self.index = faiss.IndexFlatL2(dimension)
        self.index.add(self.embeddings.astype('float32'))
    
    def retrieve(self, query: str, 
                 top_k: int = 5) -> List[str]:
        # Query embedding үүсгэх
        query_embedding = self.model.encode([query])
        
        # Vector хайлт хийх
        distances, indices = self.index.search(
            query_embedding.astype('float32'), 
            top_k
        )
        
        # Хамгийн ойр баримтуудыг буцаах
        results = [
            self.documents[idx] 
            for idx in indices[0]
        ]
        
        return results
\end{lstlisting}

\subsection{Service Agent хэрэгжүүлэлт}

\begin{lstlisting}[language=Python, caption=Service Agent Implementation]
import requests
from typing import Dict

class ServiceAgent:
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.base_url = self._get_service_url()
    
    def _get_service_url(self) -> str:
        # Service discovery-оос URL авах
        service_map = {
            "user-service": "http://localhost:8001",
            "product-service": "http://localhost:8002",
            "order-service": "http://localhost:8003",
            "payment-service": "http://localhost:8004",
        }
        return service_map.get(self.service_name)
    
    def call(self, endpoint: str, 
             params: Dict) -> Dict:
        url = f"{self.base_url}{endpoint}"
        
        try:
            response = requests.post(
                url, 
                json=params, 
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(
                f"{self.service_name} алдаа: {str(e)}"
            )
\end{lstlisting}

\section{Туршилтын үр дүн}

\subsection{Туршилтын тохиргоо}

Прототип системийг дараах нөхцөлд туршсан:

\begin{itemize}
    \item \textbf{Загвар}: GPT-4 (OpenAI API)
    \item \textbf{Embedding Model}: paraphrase-multilingual-mpnet-base-v2
    \item \textbf{Vector Database}: FAISS
    \item \textbf{Програмчлалын хэл}: Python 3.10
    \item \textbf{Микросервисүүд}: FastAPI framework ашигласан 5 микросервис
\end{itemize}

\subsection{Туршилтын тохиолдлууд}

Систем нь дараах тохиолдлуудыг амжилттай гүйцэтгэсэн:

\subsubsection{Тохиолдол 1: Энгийн захиалга}

\textbf{Хэрэглэгчийн хүсэлт}: "Би утас захиалмаар байна. iPhone 15 Pro байгаа юу?"

\textbf{Агентын төлөвлөгөө}:
\begin{enumerate}
    \item Product Service: Бүтээгдэхүүн хайх
    \item Product Service: Үлдэгдэл шалгах
    \item Order Service: Захиалга үүсгэх (хэрэв хэрэглэгч баталвал)
\end{enumerate}

\textbf{Үр дүн}: Агент амжилттай бүтээгдэхүүнийг олж, үнэ болон үлдэгдлийн мэдээллийг хэрэглэгчид ойлгомжтой байдлаар хүргэсэн.

\subsubsection{Тохиолдол 2: Нарийн төвөгтэй захиалга}

\textbf{Хэрэглэгчийн хүсэлт}: "Би өчигдөр iPhone 15 захиалсан. Хаягаа солих боломжтой юу?"

\textbf{Агентын төлөвлөгөө}:
\begin{enumerate}
    \item User Service: Хэрэглэгчийн мэдээлэл авах
    \item Order Service: Хэрэглэгчийн сүүлийн захиалгыг олох
    \item Order Service: Захиалгын статус шалгах
    \item Order Service: Хүргэлтийн хаяг шинэчлэх
\end{enumerate}

\textbf{Үр дүн}: Агент амжилттай өмнөх захиалгыг олж, хаягийг шинэчилсэн.

\subsubsection{Тохиолдол 3: Алдаа засалт}

\textbf{Хэрэглэгчийн хүсэлт}: "Та Samsung Galaxy S24-г санал болгож чадах уу?"

\textbf{Тохиолдол}: Product Service түр зуур унасан.

\textbf{Агентын үйлдэл}:
\begin{enumerate}
    \item Анхны product service дуудлага амжилтгүй
    \item Агент алдааг таньж, 2 секундын дараа дахин оролдсон
    \item Хоёр дахь оролдлого амжилттай
    \item Үр дүнг хэрэглэгчид хүргэсэн
\end{enumerate}

\textbf{Үр дүн}: Агент алдааг амжилттай засч, хэрэглэгч алдаа гарснийг мэдэхгүй.

\subsection{Гүйцэтгэлийн үнэлгээ}

Туршилтын үр дүнгээс:

\begin{table}[H]
\centering
\caption{Агент суурилсан системийн гүйцэтгэл}
\begin{tabular}{|l|c|}
\hline
\textbf{Үзүүлэлт} & \textbf{Утга} \\
\hline
Дундаж хариултын хугацаа & 2.3 секунд \\
\hline
Зөв төлөвлөгөө гаргах хувь & 94\% \\
\hline
Амжилттай гүйцэтгэл & 89\% \\
\hline
Алдаа засах чадвар & 78\% \\
\hline
\end{tabular}
\end{table}

\subsection{Харьцуулалт}

Уламжлалт хатуу кодлосон (hard-coded) орчуулагчтай харьцуулбал:

\begin{table}[H]
\centering
\caption{Агент vs Уламжлалт систем}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Үзүүлэлт} & \textbf{Агент} & \textbf{Уламжлалт} \\
\hline
Код хэмжээ (мөр) & 450 & 1,200 \\
\hline
Шинэ сервис нэмэх хугацаа & 5 минут & 2 цаг \\
\hline
Уян хатан байдал & Өндөр & Бага \\
\hline
Дундаж хариултын хугацаа & 2.3с & 0.8с \\
\hline
Натурал хэл дэмжлэг & Тийм & Үгүй \\
\hline
\end{tabular}
\end{table}

\subsection{Олдсон асуудлууд}

Туршилтын явцад дараах асуудлуудыг олсон:

\begin{enumerate}
    \item \textbf{Хоцрогдол}: LLM дуудлага нь нэмэлт хоцрогдол авчирдаг. Энэ нь prompt кэш, streaming response ашиглан сайжруулж болно.
    \item \textbf{Өртөг}: GPT-4 API үнэтэй. Энгийн даалгавруудад илүү хямд загвар (GPT-3.5) ашиглаж болно.
    \item \textbf{Тогтворгүй байдал}: Ховорхон тохиолдолд агент буруу төлөвлөгөө гаргадаг. Few-shot examples нэмж сайжруулж болно.
    \item \textbf{Хэт ерөнхий төлөвлөгөө}: Заримдаа агент хэтэрхий их сервис дуудах төлөвлөгөө гаргадаг.
\end{enumerate}

\section{Хэлэлцүүлэг}

\subsection{Судалгааны үр дүн}

Энэхүү судалгааны ажил нь Хиймэл оюун агентуудыг микросервис архитектурт амжилттай нэвтрүүлж болохыг харуулсан. Гол үр дүнгүүд:

\begin{enumerate}
    \item Хиймэл оюун агентууд нь микросервис хоорондын нарийн төвөгтэй логикийг удирдаж чадна
    \item RAG систем нь олон сервисийн мэдээллийг нэгтгэхэд үр дүнтэй
    \item Натурал хэл интерфейс нь хэрэглэгчийн туршлагыг сайжруулна
    \item Агент нь алдаа засалтын чадвартай
    \item Систем нь уян хатан, өргөжүүлэх боломжтой
\end{enumerate}

\subsection{Хязгаарлалтууд}

Санал болгосон загвар нь дараах хязгаарлалтуудтай:

\begin{enumerate}
    \item \textbf{Хоцрогдол}: LLM inference хоцрогдолтой. Бодит цагийн шаардлагатай системд тохиромжгүй.
    \item \textbf{Өртөг}: API дуудлага бүр өртөгтэй. Өндөр ачаалалтай системд үнэтэй.
    \item \textbf{Найдвартай байдал}: LLM-ийн найдвартай байдал 100\% биш. Чухал системд баталгаат тохиргоо шаардлагатай.
    \item \textbf{Аюулгүй байдал}: Prompt injection довтолгооноос хамгаалах шаардлагатай.
\end{enumerate}

\subsection{Ирээдүйн судалгаа}

Цаашид дараах чиглэлээр судалгааг үргэлжлүүлж болно:

\begin{enumerate}
    \item \textbf{Хоцрогдол бууруулах}: Жижиг, хурдан загварууд (Llama 3, Mistral) туршиж үзэх
    \item \textbf{Finetuning}: Тодорхой domain-д зориулж загвар нарийвчлан сургах
    \item \textbf{Олон агентын систем}: Агентууд хоорондоо хамтран ажиллах
    \item \textbf{Өөрөө сайжрах}: Логуудаас суралцаж агентыг автоматаар сайжруулах
    \item \textbf{Аюулгүй байдал}: Prompt injection, алдаа засах механизмыг сайжруулах
    \item \textbf{Том хэмжээний туршилт}: Илүү олон микросервис, илүү их ачаалал дээр туршиx
\end{enumerate}

%----------------------------------------------------------------------------------------
%   Дүгнэлт эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\conclusion{Дүгнэлт}

Энэхүү судалгааны ажил нь Хиймэл оюун агентуудыг микросервис архитектурт нэвтрүүлэх боломжийг судалж, практик загвар санал болгосон. Судалгааны явцад дараах гол үр дүнд хүрсэн:

\textbf{Онолын хувьд:}

Хиймэл оюуны инженерчлэл нь програм хангамж хөгжүүлэлтийн шинэ салбар болж хөгжиж байгаа нь тодорхой. Суурь загваруудын гарч ирэх нь аппликейшн хөгжүүлэлтийн саад бэрхшээлийг эрс багасгасан. Хэл загваруудаас том хэлний загвар, цаашлаад суурь загвар руу хөгжих үйл явц нь хэдэн арван жилийн технологийн дэвшлийн үр дүн юм. Өөрийгөө удирдсан сургалт, Transformer архитектур, post-training аргууд зэрэг гол түлхүүр цэгүүд нь өнөөгийн хүчирхэг Хиймэл оюун системүүдийг бий болгосон.

Хиймэл оюун агентуудын онол нь орчин, үйлдэл, даалгавар гэсэн гурван гол бүрэлдэхүүн дээр суурилдаг. Агентууд нь төлөвлөлт, багаж ашиглалт, эргэцүүлэн бодох чадвартайгаараа уламжлалт програмуудаас давуу талтай. RAG систем нь агентуудын мэдлэгийг өргөтгөж, илүү найдвартай, бодит мэдээлэл дээр суурилсан хариулт өгөх боломжийг олгодог.

\textbf{Практик хувьд:}

Микросервис архитектур дахь сервис хоорондын нарийн төвөгтэй логик, өгөгдлийн нэгтгэл, динамик routing зэрэг асуудлуудыг Хиймэл оюун агентууд ашиглан шийдэж болох нь тодорхой болсон. Санал болгосон Orchestrator Agent, Service Agent, Knowledge Agent, Monitoring Agent зэрэг бүрэлдэхүүн хэсгүүд нь уян хатан, өргөжүүлэх боломжтой системийг бий болгодог.

Гэхдээ агентуудыг үйлдвэрлэлийн түвшинд өргөжүүлэхийн тулд зөвхөн агентын ур чадвар биш, тэдгээрийг холбодог архитектур чухал гэдгийг ойлгосон. Монолит болон RPC/API суурилсан холболт нь монолит архитектурт тулгарсан асуудалтай адил саад болдог. Үүнийг шийдэхийн тулд үйл явдлаар удирдагдах архитектур (EDA) ашиглан агентуудыг салангид микросервис болгон хөгжүүлэх шаардлагатай.

\textbf{Үйл явдлаар удирдагдах архитектурын үр дүн:}

Apache Kafka болон Apache Flink ашиглан үйл явдлаар удирдагдах агентын систем бүтээх нь:

\begin{itemize}
    \item \textbf{Салангид байдал}: Kafka topics-оор харилцах нь агентууд хоорондоо шууд хамааралгүй байхыг баталгаажуулна
    \item \textbf{Параллель боловсруулалт}: Kafka partitions ашиглан олон агент зэрэг ажиллаж, системийн дамжуулалтыг нэмэгдүүлнэ
    \item \textbf{Найдвартай байдал}: Үйл явдлын хадгалалт нь мэдээлэл алдагдахгүй, дахин тоглуулж болохыг баталгаажуулна
    \item \textbf{Bодит цагийн боловсруулалт}: Streaming архитектур нь тэр даруй хариу үйлдэл үзүүлэх боломжийг олгоно
    \item \textbf{Олон хэрэглэгч}: Агентын гаралт нь CRM, CDP, analytics зэрэг олон системд автоматаар урсах боломжтой
\end{itemize}

Flink AI Inference ашиглах нь төлөвлөгч агентыг stream processing app болгон хөгжүүлэх боломжийг олгож, Flink-ийн stateful боловсруулалт, exactly-once семантик зэрэг давуу талыг ашиглах боломжтой болгоно.

Прототип системийн туршилт нь 94\% зөв төлөвлөгөө гаргах, 89\% амжилттай гүйцэтгэл, 78\% алдаа засах чадварыг харуулсан. Энэ нь уламжлалт hard-coded орчуулагчтай харьцуулахад код хэмжээг 62\% бууруулж, шинэ сервис нэмэх хугацааг 24 дахин богиносгосон. Гэвч дундаж хариултын хугацаа 2.9 дахин удаан болсон нь анхаарал хандуулах асуудал юм.

\textbf{Цаашдын хөгжил:}

Хоцрогдол болон өртгийн асуудлыг шийдэхийн тулд дараах чиглэлүүд чухал:

\begin{itemize}
    \item Жижиг, хурдан загварууд (Llama 3, Mistral, Gemma) туршиж ашиглах
    \item Тодорхой domain-д зориулж загвар нарийвчлан сургах
    \item Prompt кэш, streaming response ашиглан хоцрогдол бууруулах
    \item Олон агентын систем бүтээж илүү нарийн төвөгтэй даалгавар гүйцэтгүүлэх
\end{itemize}

\textbf{Судалгааны ач холбогдол:}

Энэхүү судалгаа нь Хиймэл оюун агентууд болон микросервис архитектурын уялдааг судалсан анхны судалгаануудын нэг юм. Chip Huyen-ийн "AI Engineering" номонд дурдагдсан онол, практик аргуудыг Монгол хэл дээр нэгтгэн авч үзэж, микросервис орчинд хэрэглэх загвар санал болгосон нь энэхүү ажлын гол хувь нэмэр юм.

\textbf{Эцсийн дүгнэлт:}

Хиймэл оюуны инженерчлэлийн эрин үе эхэлж байна. Том хэмжээний хөрөнгө оруулалт, хурдацтай технологийн хөгжил, өргөн хүрээний хэрэглээ зэрэг нь энэ салбарын ирээдүй гэрэлтэй байгааг харуулж байна. Гэвч Хиймэл оюун агентуудын жинхэнэ боломжийг нээхийн тулд зөв архитектурын шийдэл чухал юм.

Энэхүү судалгаа нь Хиймэл оюун агентууд зөвхөн ухаалаг програм биш, үндсэндээ өргөжүүлэх боломжтой микросервисүүд болохыг харууллаа. Гэхдээ уламжлалт микросервисээс ялгаатай нь агентууд нь контекст баялаг, хуваалцсан мэдээлэлд найддаг. Энэ нь тэднийг үр дүнтэй холбохын тулд үйл явдлаар удирдагдах архитектур (EDA) шаардлагатай болгодог.

HubSpot-ийн CTO Dharmesh Shah-ийн хэлснээр "Агентууд бол шинэ апп юм." Хэрэв энэ нь үнэн бол агентуудыг микросервис болгон хөгжүүлэх хэрэгтэй. Хэрэв та агентуудыг үйл явдлаар харилцуулахгүй бол тэд зүгээр л LLM тархитай, хуучирч болзошгүй программууд хэвээр үлдэнэ.

Apache Kafka болон Apache Flink зэрэг технологиудыг ашиглан агентууд нь:
\begin{itemize}
    \item Бие даан өргөжиж чадна
    \item Бодит цагт өгөгдөл боловсруулна
    \item Системийн хэмжээнд мэдээллээ хуваалцана
    \item Алдаанаас сэргэж чадна
    \item Дахин тоглуулах замаар сайжирна
\end{itemize}

Микросервис архитектурт Хиймэл оюун агентууд нэвтрүүлэх нь системийг илүү ухаалаг, уян хатан, хэрэглэгчид ээлтэй болгох боломжийг олгоно. Хэдийгээр одоогоор хязгаарлалтууд байгаа ч - хоцрогдол, өртөг, найдвартай байдал - технологи хурдацтай хөгжиж байгаа тул ойрын ирээдүйд эдгээр асуудлууд шийдэгдэх болно гэж найдаж байна.

Энэхүү дипломын ажил нь Хиймэл оюуны инженерчлэлийн үндсийг тавьж, микросервис архитектурт агент суурилсан шийдлийг практикт хэрхэн хэрэглэж болохыг харуулсан. Хамгийн чухал нь, үйл явдлаар удирдагдах архитектур нь агентуудыг үйлдвэрлэлийн түвшинд өргөжүүлэх цорын ганц зам болохыг тогтоосон. Цаашдын судалгаа, хөгжүүлэлтээр энэ чиглэлийг улам бүр боловсронгуй болгож, бодит системүүдэд нэвтрүүлэх боломжтой гэж үзэж байна.

% Техникийн хөгжүүлэлтийн хувьд Next.js React фронтенд, Node.js Express бэкенд, TypeScript, MySQL ашиглан SOLID зарчмыг дагасан архитектур бүтээсэн. Merchant Super App OAuth механизм, ҮЦТХТ SOAP API интеграци, 300,000+ мөртэй өгөгдлөөс binary search алгоритмаар хурдан хайлт хийх(5-40ms), үнэт цаасны real-time дата WebSocket ашиглан дамжуулах систем зэрэг олон чухал арга техникийг амжилттай хэрэгжүүлсэн.

% Фүллстек веб хөгжүүлэлт, API интеграци, real-time дата боловсруулалт, Docker containerization, DevOps практик зэрэг олон чиглэлийн техникийн чадваруудыг эзэмшсэн. Мөн багийн ажиллагаа, төслийн удирдлага, Git workflow, CI/CD pipeline зэрэг мэргэжлийн ур чадваруудыг хөгжүүлсэн.

% Энэхүү дадлагын үр дүнд санхүүгийн технологийн салбарт бодит ажлын туршлага олж авч, ирээдүйд илүү том, нарийн төвөгтэй системүүд хөгжүүлэх, санхүүгийн технологийн салбарт хувь нэмрээ оруулах чадварыг эзэмшсэн.

%----------------------------------------------------------------------------------------
%   Дипломын номзүй, хавсралтын хэсэг эндээс эхэлнэ
%----------------------------------------------------------------------------------------

\singlespace
\addcontentsline{toc}{part}{НОМ ЗҮЙ}
\begin{thebibliography}{99}
	% Үндсэн ном зохиол
	\bibitem{huyen2024}
	Huyen, Chip. \textit{AI Engineering}. O'Reilly Media, 2024.
	
	\bibitem{goldman2023}
	Goldman Sachs Research. "Generative AI Could Raise Global GDP by 7\%", 2023. 
	\url{https://www.goldmansachs.com/intelligence/pages/generative-ai-could-raise-global-gdp-by-7-percent.html}
	
	% Foundation Models
	\bibitem{vaswani2017}
	Vaswani, A., et al. "Attention Is All You Need". \textit{Advances in Neural Information Processing Systems}, 2017.
	
	\bibitem{devlin2019}
	Devlin, J., et al. "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding". \textit{NAACL-HLT}, 2019.
	
	\bibitem{brown2020}
	Brown, T., et al. "Language Models are Few-Shot Learners". \textit{Advances in Neural Information Processing Systems}, 2020.
	
	\bibitem{touvron2023}
	Touvron, H., et al. "Llama 2: Open Foundation and Fine-Tuned Chat Models". \textit{arXiv preprint arXiv:2307.09288}, 2023.
	
	\bibitem{touvron2024}
	Touvron, H., et al. "The Llama 3 Herd of Models". \textit{arXiv preprint arXiv:2407.21783}, 2024.
	
	% RAG
	\bibitem{lewis2020}
	Lewis, P., et al. "Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks". \textit{Advances in Neural Information Processing Systems}, 2020.
	
	\bibitem{gao2023}
	Gao, Y., et al. "Retrieval-Augmented Generation for Large Language Models: A Survey". \textit{arXiv preprint arXiv:2312.10997}, 2023.
	
	% AI Agents
	\bibitem{wei2022}
	Wei, J., et al. "Chain-of-Thought Prompting Elicits Reasoning in Large Language Models". \textit{Advances in Neural Information Processing Systems}, 2022.
	
	\bibitem{yao2023}
	Yao, S., et al. "ReAct: Synergizing Reasoning and Acting in Language Models". \textit{ICLR}, 2023.
	
	\bibitem{schick2023}
	Schick, T., et al. "Toolformer: Language Models Can Teach Themselves to Use Tools". \textit{arXiv preprint arXiv:2302.04761}, 2023.
	
	% Evaluation & Hallucination
	\bibitem{ortega2021}
	Ortega, P.A., et al. "Shaping Representations Through Communication: Community Size and Stability Determine the Emergence of Shared Symbols". \textit{DeepMind Technical Report}, 2021.
	
	\bibitem{schulman2022}
	Schulman, J. "Reinforcement Learning from Human Feedback: Progress and Challenges". \textit{Berkeley EECS Colloquium}, 2022.
	
	% Prompt Engineering
	\bibitem{openai2023}
	OpenAI. "Prompt Engineering Guide", 2023. \url{https://platform.openai.com/docs/guides/prompt-engineering}
	
	\bibitem{liu2023}
	Liu, P., et al. "Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing". \textit{ACM Computing Surveys}, 2023.
	
	% Microservices
	\bibitem{newman2015}
	Newman, Sam. \textit{Building Microservices: Designing Fine-Grained Systems}. O'Reilly Media, 2015.
	
	\bibitem{richardson2018}
	Richardson, Chris. \textit{Microservices Patterns: With Examples in Java}. Manning Publications, 2018.
	
	\bibitem{fowler2014}
	Fowler, Martin and Lewis, James. "Microservices: A Definition of This New Architectural Term", 2014. \url{https://martinfowler.com/articles/microservices.html}
	
	% Vector Databases & Search
	\bibitem{johnson2019}
	Johnson, J., Douze, M., and Jégou, H. "Billion-scale Similarity Search with GPUs". \textit{IEEE Transactions on Big Data}, 2019.
	
	\bibitem{malkov2018}
	Malkov, Y.A. and Yashunin, D.A. "Efficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs". \textit{IEEE Transactions on Pattern Analysis and Machine Intelligence}, 2018.
	
	% Embeddings
	\bibitem{reimers2019}
	Reimers, N. and Gurevych, I. "Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks". \textit{EMNLP-IJCNLP}, 2019.
	
	\bibitem{muennighoff2023}
	Muennighoff, N., et al. "MTEB: Massive Text Embedding Benchmark". \textit{EACL}, 2023.
	
	% API & Integration
	\bibitem{fielding2000}
	Fielding, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.
	
	% Python & Tools
	\bibitem{python}
	Python Software Foundation. "Python 3 Documentation". \url{https://docs.python.org/3/}
	
	\bibitem{fastapi}
	Ramírez, Sebastián. "FastAPI Documentation". \url{https://fastapi.tiangolo.com/}
	
	\bibitem{openai-api}
	OpenAI. "OpenAI API Reference". \url{https://platform.openai.com/docs/api-reference}
	
	\bibitem{anthropic2024}
	Anthropic. "Claude 3 Model Card", 2024. \url{https://www.anthropic.com/claude}
	
	\bibitem{langchain}
	LangChain. "LangChain Documentation". \url{https://python.langchain.com/docs/}
	
	\bibitem{faiss}
	Facebook AI Research. "FAISS: A Library for Efficient Similarity Search". \url{https://github.com/facebookresearch/faiss}
	
	% Event-Driven Architecture & Streaming
	\bibitem{falconer2025agents}
	Falconer, Sean. "AI Agents are Microservices with Brains". Medium, March 2025. \url{https://medium.com/@seanfalconer}
	
	\bibitem{falconer2025future}
	Falconer, Sean. "The Future of AI Agents is Event-Driven". BigDataWire, March 2025.
	
	\bibitem{polak2025}
	Polak, Adi. "Building AI Agents with Event-Driven Microservices". Confluent Developer Advocate, 2025.
	
	\bibitem{kafka}
	Apache Kafka Documentation. "Apache Kafka: A Distributed Streaming Platform". \url{https://kafka.apache.org/documentation/}
	
	\bibitem{kreps2014}
	Kreps, Jay, Narkhede, Neha, and Rao, Jun. "Kafka: A Distributed Messaging System for Log Processing". \textit{Proceedings of the NetDB}, 2011.
	
	\bibitem{flink}
	Apache Flink Documentation. "Stateful Computations over Data Streams". \url{https://flink.apache.org/}
	
	\bibitem{carbone2017}
	Carbone, Paris, et al. "State Management in Apache Flink: Consistent Stateful Distributed Processing". \textit{Proceedings of the VLDB Endowment}, 2017.
	
	% Multi-Agent Systems
	\bibitem{wooldridge2009}
	Wooldridge, Michael. \textit{An Introduction to MultiAgent Systems}. John Wiley \& Sons, 2009.
	
	\bibitem{park2023}
	Park, Joon Sung, et al. "Generative Agents: Interactive Simulacra of Human Behavior". \textit{arXiv preprint arXiv:2304.03442}, 2023.
	
	% Microservices Evolution
	\bibitem{wolff2016}
	Wolff, Eberhard. \textit{Microservices: Flexible Software Architecture}. Addison-Wesley Professional, 2016.
	
	\bibitem{nadareishvili2016}
	Nadareishvili, Irakli, et al. \textit{Microservice Architecture: Aligning Principles, Practices, and Culture}. O'Reilly Media, 2016.
	
	% Anthropic MCP
	\bibitem{anthropic2024mcp}
	Anthropic. "Model Context Protocol: A Universal Standard for AI Integration", 2024. \url{https://www.anthropic.com/news/model-context-protocol}
	
\end{thebibliography}


%----------------------------------------------------------------------------------------
%   Хавсралтууд эндээс эхэлнэ
%----------------------------------------------------------------------------------------
\appendix
\addcontentsline{toc}{part}{ХАВСРАЛТ}

% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
\chapter{Нүүр хуудас}


% Хавсралтын нэр. Хавсралт гэдэг үг агуулахгүй
% \chapter{Кодын хэрэгжүүлэлт}

% \section{Merchant Super App OAuth нэвтрэлт}

% \begin{lstlisting}[language=Java, caption=Merchant App Authorization Redirect Handler]
% router.get("/merchantA", async (req, res) => {
%   const { code, scope } = req.query;
  
%   // Merchant OAuth code-г token-д солих
%   const tokenRes = await merchantService.getCode(code as string);
%   const merchantInformation = await merchantService.getUserInfo(
%     tokenRes.access_token
%   );
  
%   // Хэрэглэгч өгөгдлийн санд байгаа эсэхийг шалгах
%   const user = await db.user.findFirst({
%     where: { merchantUser: { userIdMerchant: merchantInformation.userId } },
%     include: { user: true, merchantUser: true }
%   });
  
%   let token;
%   if (user) {
%     // Хэрэглэгч бүртгэлтэй бол JWT токен үүсгэх
%     const payload = { id: user.user.id, role: "USER", type: "merchant" };
%     token = jwt.sign(payload, env.JWT_SECRET);
    
%     // Хэрэглэгчийн Refresh Token-ыг шинэчлэх
%   } else {
%     // Шинэ хэрэглэгч бүртгэх
%     token = jwt.sign({ id: merchantUser.id, role: "USER" }, env.JWT_SECRET);
%   }
  
%   // JWT токенийг cookie-д хадгалах
%   res.cookie("token", token, {
%     httpOnly: false,
%     secure: process.env.NODE_ENV === "production",
%     sameSite: "lax",
%     maxAge: 24 * 60 * 60 * 1000 // 1 day
%   });
  
%   res.redirect(process.env.PROD_FRONTURL);
% });
% \end{lstlisting}

% \section{Cron job болон тогтмол синхронизаци}



\end{document}
